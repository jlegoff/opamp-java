// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: opamp.proto

package opamp.proto;

public final class Opamp {
  private Opamp() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  /**
   * Protobuf enum {@code opamp.proto.AgentToServerFlags}
   */
  public enum AgentToServerFlags
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>AgentToServerFlags_Unspecified = 0;</code>
     */
    AgentToServerFlags_Unspecified(0),
    /**
     * <pre>
     * The Agent requests Server go generate a new instance_uid, which will
     * be sent back in ServerToAgent message
     * </pre>
     *
     * <code>AgentToServerFlags_RequestInstanceUid = 1;</code>
     */
    AgentToServerFlags_RequestInstanceUid(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>AgentToServerFlags_Unspecified = 0;</code>
     */
    public static final int AgentToServerFlags_Unspecified_VALUE = 0;
    /**
     * <pre>
     * The Agent requests Server go generate a new instance_uid, which will
     * be sent back in ServerToAgent message
     * </pre>
     *
     * <code>AgentToServerFlags_RequestInstanceUid = 1;</code>
     */
    public static final int AgentToServerFlags_RequestInstanceUid_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AgentToServerFlags valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AgentToServerFlags forNumber(int value) {
      switch (value) {
        case 0: return AgentToServerFlags_Unspecified;
        case 1: return AgentToServerFlags_RequestInstanceUid;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AgentToServerFlags>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        AgentToServerFlags> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AgentToServerFlags>() {
            public AgentToServerFlags findValueByNumber(int number) {
              return AgentToServerFlags.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opamp.proto.Opamp.getDescriptor().getEnumTypes().get(0);
    }

    private static final AgentToServerFlags[] VALUES = values();

    public static AgentToServerFlags valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AgentToServerFlags(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.AgentToServerFlags)
  }

  /**
   * Protobuf enum {@code opamp.proto.ServerToAgentFlags}
   */
  public enum ServerToAgentFlags
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>ServerToAgentFlags_Unspecified = 0;</code>
     */
    ServerToAgentFlags_Unspecified(0),
    /**
     * <pre>
     * ReportFullState flag can be used by the Server if the Agent did not include the
     * particular bit of information in the last status report (which is an allowed
     * optimization) but the Server detects that it does not have it (e.g. was
     * restarted and lost state). The detection happens using
     * AgentToServer.sequence_num values.
     * The Server asks the Agent to report full status.
     * </pre>
     *
     * <code>ServerToAgentFlags_ReportFullState = 1;</code>
     */
    ServerToAgentFlags_ReportFullState(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>ServerToAgentFlags_Unspecified = 0;</code>
     */
    public static final int ServerToAgentFlags_Unspecified_VALUE = 0;
    /**
     * <pre>
     * ReportFullState flag can be used by the Server if the Agent did not include the
     * particular bit of information in the last status report (which is an allowed
     * optimization) but the Server detects that it does not have it (e.g. was
     * restarted and lost state). The detection happens using
     * AgentToServer.sequence_num values.
     * The Server asks the Agent to report full status.
     * </pre>
     *
     * <code>ServerToAgentFlags_ReportFullState = 1;</code>
     */
    public static final int ServerToAgentFlags_ReportFullState_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ServerToAgentFlags valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ServerToAgentFlags forNumber(int value) {
      switch (value) {
        case 0: return ServerToAgentFlags_Unspecified;
        case 1: return ServerToAgentFlags_ReportFullState;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServerToAgentFlags>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ServerToAgentFlags> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ServerToAgentFlags>() {
            public ServerToAgentFlags findValueByNumber(int number) {
              return ServerToAgentFlags.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opamp.proto.Opamp.getDescriptor().getEnumTypes().get(1);
    }

    private static final ServerToAgentFlags[] VALUES = values();

    public static ServerToAgentFlags valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ServerToAgentFlags(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.ServerToAgentFlags)
  }

  /**
   * Protobuf enum {@code opamp.proto.ServerCapabilities}
   */
  public enum ServerCapabilities
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * The capabilities field is unspecified.
     * </pre>
     *
     * <code>ServerCapabilities_Unspecified = 0;</code>
     */
    ServerCapabilities_Unspecified(0),
    /**
     * <pre>
     * The Server can accept status reports. This bit MUST be set, since all Server
     * MUST be able to accept status reports.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsStatus = 1;</code>
     */
    ServerCapabilities_AcceptsStatus(1),
    /**
     * <pre>
     * The Server can offer remote configuration to the Agent.
     * </pre>
     *
     * <code>ServerCapabilities_OffersRemoteConfig = 2;</code>
     */
    ServerCapabilities_OffersRemoteConfig(2),
    /**
     * <pre>
     * The Server can accept EffectiveConfig in AgentToServer.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsEffectiveConfig = 4;</code>
     */
    ServerCapabilities_AcceptsEffectiveConfig(4),
    /**
     * <pre>
     * The Server can offer Packages.
     * </pre>
     *
     * <code>ServerCapabilities_OffersPackages = 8;</code>
     */
    ServerCapabilities_OffersPackages(8),
    /**
     * <pre>
     * The Server can accept Packages status.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsPackagesStatus = 16;</code>
     */
    ServerCapabilities_AcceptsPackagesStatus(16),
    /**
     * <pre>
     * The Server can offer connection settings.
     * </pre>
     *
     * <code>ServerCapabilities_OffersConnectionSettings = 32;</code>
     */
    ServerCapabilities_OffersConnectionSettings(32),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * The capabilities field is unspecified.
     * </pre>
     *
     * <code>ServerCapabilities_Unspecified = 0;</code>
     */
    public static final int ServerCapabilities_Unspecified_VALUE = 0;
    /**
     * <pre>
     * The Server can accept status reports. This bit MUST be set, since all Server
     * MUST be able to accept status reports.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsStatus = 1;</code>
     */
    public static final int ServerCapabilities_AcceptsStatus_VALUE = 1;
    /**
     * <pre>
     * The Server can offer remote configuration to the Agent.
     * </pre>
     *
     * <code>ServerCapabilities_OffersRemoteConfig = 2;</code>
     */
    public static final int ServerCapabilities_OffersRemoteConfig_VALUE = 2;
    /**
     * <pre>
     * The Server can accept EffectiveConfig in AgentToServer.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsEffectiveConfig = 4;</code>
     */
    public static final int ServerCapabilities_AcceptsEffectiveConfig_VALUE = 4;
    /**
     * <pre>
     * The Server can offer Packages.
     * </pre>
     *
     * <code>ServerCapabilities_OffersPackages = 8;</code>
     */
    public static final int ServerCapabilities_OffersPackages_VALUE = 8;
    /**
     * <pre>
     * The Server can accept Packages status.
     * </pre>
     *
     * <code>ServerCapabilities_AcceptsPackagesStatus = 16;</code>
     */
    public static final int ServerCapabilities_AcceptsPackagesStatus_VALUE = 16;
    /**
     * <pre>
     * The Server can offer connection settings.
     * </pre>
     *
     * <code>ServerCapabilities_OffersConnectionSettings = 32;</code>
     */
    public static final int ServerCapabilities_OffersConnectionSettings_VALUE = 32;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ServerCapabilities valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ServerCapabilities forNumber(int value) {
      switch (value) {
        case 0: return ServerCapabilities_Unspecified;
        case 1: return ServerCapabilities_AcceptsStatus;
        case 2: return ServerCapabilities_OffersRemoteConfig;
        case 4: return ServerCapabilities_AcceptsEffectiveConfig;
        case 8: return ServerCapabilities_OffersPackages;
        case 16: return ServerCapabilities_AcceptsPackagesStatus;
        case 32: return ServerCapabilities_OffersConnectionSettings;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServerCapabilities>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ServerCapabilities> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ServerCapabilities>() {
            public ServerCapabilities findValueByNumber(int number) {
              return ServerCapabilities.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opamp.proto.Opamp.getDescriptor().getEnumTypes().get(2);
    }

    private static final ServerCapabilities[] VALUES = values();

    public static ServerCapabilities valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ServerCapabilities(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.ServerCapabilities)
  }

  /**
   * <pre>
   * The type of the package, either an addon or a top-level package.
   * </pre>
   *
   * Protobuf enum {@code opamp.proto.PackageType}
   */
  public enum PackageType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <code>PackageType_TopLevel = 0;</code>
     */
    PackageType_TopLevel(0),
    /**
     * <code>PackageType_Addon = 1;</code>
     */
    PackageType_Addon(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <code>PackageType_TopLevel = 0;</code>
     */
    public static final int PackageType_TopLevel_VALUE = 0;
    /**
     * <code>PackageType_Addon = 1;</code>
     */
    public static final int PackageType_Addon_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static PackageType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static PackageType forNumber(int value) {
      switch (value) {
        case 0: return PackageType_TopLevel;
        case 1: return PackageType_Addon;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PackageType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        PackageType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<PackageType>() {
            public PackageType findValueByNumber(int number) {
              return PackageType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opamp.proto.Opamp.getDescriptor().getEnumTypes().get(3);
    }

    private static final PackageType[] VALUES = values();

    public static PackageType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private PackageType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.PackageType)
  }

  /**
   * Protobuf enum {@code opamp.proto.ServerErrorResponseType}
   */
  public enum ServerErrorResponseType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Unknown error. Something went wrong, but it is not known what exactly.
     * The Agent SHOULD NOT retry the message.
     * The error_message field may contain a description of the problem.
     * </pre>
     *
     * <code>ServerErrorResponseType_Unknown = 0;</code>
     */
    ServerErrorResponseType_Unknown(0),
    /**
     * <pre>
     * The AgentToServer message was malformed. The Agent SHOULD NOT retry
     * the message.
     * </pre>
     *
     * <code>ServerErrorResponseType_BadRequest = 1;</code>
     */
    ServerErrorResponseType_BadRequest(1),
    /**
     * <pre>
     * The Server is overloaded and unable to process the request. The Agent
     * should retry the message later. retry_info field may be optionally
     * set with additional information about retrying.
     * </pre>
     *
     * <code>ServerErrorResponseType_Unavailable = 2;</code>
     */
    ServerErrorResponseType_Unavailable(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Unknown error. Something went wrong, but it is not known what exactly.
     * The Agent SHOULD NOT retry the message.
     * The error_message field may contain a description of the problem.
     * </pre>
     *
     * <code>ServerErrorResponseType_Unknown = 0;</code>
     */
    public static final int ServerErrorResponseType_Unknown_VALUE = 0;
    /**
     * <pre>
     * The AgentToServer message was malformed. The Agent SHOULD NOT retry
     * the message.
     * </pre>
     *
     * <code>ServerErrorResponseType_BadRequest = 1;</code>
     */
    public static final int ServerErrorResponseType_BadRequest_VALUE = 1;
    /**
     * <pre>
     * The Server is overloaded and unable to process the request. The Agent
     * should retry the message later. retry_info field may be optionally
     * set with additional information about retrying.
     * </pre>
     *
     * <code>ServerErrorResponseType_Unavailable = 2;</code>
     */
    public static final int ServerErrorResponseType_Unavailable_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static ServerErrorResponseType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static ServerErrorResponseType forNumber(int value) {
      switch (value) {
        case 0: return ServerErrorResponseType_Unknown;
        case 1: return ServerErrorResponseType_BadRequest;
        case 2: return ServerErrorResponseType_Unavailable;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<ServerErrorResponseType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        ServerErrorResponseType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<ServerErrorResponseType>() {
            public ServerErrorResponseType findValueByNumber(int number) {
              return ServerErrorResponseType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opamp.proto.Opamp.getDescriptor().getEnumTypes().get(4);
    }

    private static final ServerErrorResponseType[] VALUES = values();

    public static ServerErrorResponseType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private ServerErrorResponseType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.ServerErrorResponseType)
  }

  /**
   * Protobuf enum {@code opamp.proto.CommandType}
   */
  public enum CommandType
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * The Agent should restart. This request will be ignored if the Agent does not
     * support restart.
     * </pre>
     *
     * <code>CommandType_Restart = 0;</code>
     */
    CommandType_Restart(0),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * The Agent should restart. This request will be ignored if the Agent does not
     * support restart.
     * </pre>
     *
     * <code>CommandType_Restart = 0;</code>
     */
    public static final int CommandType_Restart_VALUE = 0;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static CommandType valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static CommandType forNumber(int value) {
      switch (value) {
        case 0: return CommandType_Restart;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<CommandType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        CommandType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<CommandType>() {
            public CommandType findValueByNumber(int number) {
              return CommandType.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opamp.proto.Opamp.getDescriptor().getEnumTypes().get(5);
    }

    private static final CommandType[] VALUES = values();

    public static CommandType valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private CommandType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.CommandType)
  }

  /**
   * Protobuf enum {@code opamp.proto.AgentCapabilities}
   */
  public enum AgentCapabilities
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * The capabilities field is unspecified.
     * </pre>
     *
     * <code>AgentCapabilities_Unspecified = 0;</code>
     */
    AgentCapabilities_Unspecified(0),
    /**
     * <pre>
     * The Agent can report status. This bit MUST be set, since all Agents MUST
     * report status.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsStatus = 1;</code>
     */
    AgentCapabilities_ReportsStatus(1),
    /**
     * <pre>
     * The Agent can accept remote configuration from the Server.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsRemoteConfig = 2;</code>
     */
    AgentCapabilities_AcceptsRemoteConfig(2),
    /**
     * <pre>
     * The Agent will report EffectiveConfig in AgentToServer.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsEffectiveConfig = 4;</code>
     */
    AgentCapabilities_ReportsEffectiveConfig(4),
    /**
     * <pre>
     * The Agent can accept package offers.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsPackages = 8;</code>
     */
    AgentCapabilities_AcceptsPackages(8),
    /**
     * <pre>
     * The Agent can report package status.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsPackageStatuses = 16;</code>
     */
    AgentCapabilities_ReportsPackageStatuses(16),
    /**
     * <pre>
     * The Agent can report own trace to the destination specified by
     * the Server via ConnectionSettingsOffers.own_traces field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnTraces = 32;</code>
     */
    AgentCapabilities_ReportsOwnTraces(32),
    /**
     * <pre>
     * The Agent can report own metrics to the destination specified by
     * the Server via ConnectionSettingsOffers.own_metrics field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnMetrics = 64;</code>
     */
    AgentCapabilities_ReportsOwnMetrics(64),
    /**
     * <pre>
     * The Agent can report own logs to the destination specified by
     * the Server via ConnectionSettingsOffers.own_logs field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnLogs = 128;</code>
     */
    AgentCapabilities_ReportsOwnLogs(128),
    /**
     * <pre>
     * The can accept connections settings for OpAMP via
     * ConnectionSettingsOffers.opamp field.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsOpAMPConnectionSettings = 256;</code>
     */
    AgentCapabilities_AcceptsOpAMPConnectionSettings(256),
    /**
     * <pre>
     * The can accept connections settings for other destinations via
     * ConnectionSettingsOffers.other_connections field.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsOtherConnectionSettings = 512;</code>
     */
    AgentCapabilities_AcceptsOtherConnectionSettings(512),
    /**
     * <pre>
     * The Agent can accept restart requests.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsRestartCommand = 1024;</code>
     */
    AgentCapabilities_AcceptsRestartCommand(1024),
    /**
     * <pre>
     * The Agent will report Health via AgentToServer.health field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsHealth = 2048;</code>
     */
    AgentCapabilities_ReportsHealth(2048),
    /**
     * <pre>
     * The Agent will report RemoteConfig status via AgentToServer.remote_config_status field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsRemoteConfig = 4096;</code>
     */
    AgentCapabilities_ReportsRemoteConfig(4096),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * The capabilities field is unspecified.
     * </pre>
     *
     * <code>AgentCapabilities_Unspecified = 0;</code>
     */
    public static final int AgentCapabilities_Unspecified_VALUE = 0;
    /**
     * <pre>
     * The Agent can report status. This bit MUST be set, since all Agents MUST
     * report status.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsStatus = 1;</code>
     */
    public static final int AgentCapabilities_ReportsStatus_VALUE = 1;
    /**
     * <pre>
     * The Agent can accept remote configuration from the Server.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsRemoteConfig = 2;</code>
     */
    public static final int AgentCapabilities_AcceptsRemoteConfig_VALUE = 2;
    /**
     * <pre>
     * The Agent will report EffectiveConfig in AgentToServer.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsEffectiveConfig = 4;</code>
     */
    public static final int AgentCapabilities_ReportsEffectiveConfig_VALUE = 4;
    /**
     * <pre>
     * The Agent can accept package offers.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsPackages = 8;</code>
     */
    public static final int AgentCapabilities_AcceptsPackages_VALUE = 8;
    /**
     * <pre>
     * The Agent can report package status.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsPackageStatuses = 16;</code>
     */
    public static final int AgentCapabilities_ReportsPackageStatuses_VALUE = 16;
    /**
     * <pre>
     * The Agent can report own trace to the destination specified by
     * the Server via ConnectionSettingsOffers.own_traces field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnTraces = 32;</code>
     */
    public static final int AgentCapabilities_ReportsOwnTraces_VALUE = 32;
    /**
     * <pre>
     * The Agent can report own metrics to the destination specified by
     * the Server via ConnectionSettingsOffers.own_metrics field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnMetrics = 64;</code>
     */
    public static final int AgentCapabilities_ReportsOwnMetrics_VALUE = 64;
    /**
     * <pre>
     * The Agent can report own logs to the destination specified by
     * the Server via ConnectionSettingsOffers.own_logs field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsOwnLogs = 128;</code>
     */
    public static final int AgentCapabilities_ReportsOwnLogs_VALUE = 128;
    /**
     * <pre>
     * The can accept connections settings for OpAMP via
     * ConnectionSettingsOffers.opamp field.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsOpAMPConnectionSettings = 256;</code>
     */
    public static final int AgentCapabilities_AcceptsOpAMPConnectionSettings_VALUE = 256;
    /**
     * <pre>
     * The can accept connections settings for other destinations via
     * ConnectionSettingsOffers.other_connections field.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsOtherConnectionSettings = 512;</code>
     */
    public static final int AgentCapabilities_AcceptsOtherConnectionSettings_VALUE = 512;
    /**
     * <pre>
     * The Agent can accept restart requests.
     * </pre>
     *
     * <code>AgentCapabilities_AcceptsRestartCommand = 1024;</code>
     */
    public static final int AgentCapabilities_AcceptsRestartCommand_VALUE = 1024;
    /**
     * <pre>
     * The Agent will report Health via AgentToServer.health field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsHealth = 2048;</code>
     */
    public static final int AgentCapabilities_ReportsHealth_VALUE = 2048;
    /**
     * <pre>
     * The Agent will report RemoteConfig status via AgentToServer.remote_config_status field.
     * </pre>
     *
     * <code>AgentCapabilities_ReportsRemoteConfig = 4096;</code>
     */
    public static final int AgentCapabilities_ReportsRemoteConfig_VALUE = 4096;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static AgentCapabilities valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static AgentCapabilities forNumber(int value) {
      switch (value) {
        case 0: return AgentCapabilities_Unspecified;
        case 1: return AgentCapabilities_ReportsStatus;
        case 2: return AgentCapabilities_AcceptsRemoteConfig;
        case 4: return AgentCapabilities_ReportsEffectiveConfig;
        case 8: return AgentCapabilities_AcceptsPackages;
        case 16: return AgentCapabilities_ReportsPackageStatuses;
        case 32: return AgentCapabilities_ReportsOwnTraces;
        case 64: return AgentCapabilities_ReportsOwnMetrics;
        case 128: return AgentCapabilities_ReportsOwnLogs;
        case 256: return AgentCapabilities_AcceptsOpAMPConnectionSettings;
        case 512: return AgentCapabilities_AcceptsOtherConnectionSettings;
        case 1024: return AgentCapabilities_AcceptsRestartCommand;
        case 2048: return AgentCapabilities_ReportsHealth;
        case 4096: return AgentCapabilities_ReportsRemoteConfig;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<AgentCapabilities>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        AgentCapabilities> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<AgentCapabilities>() {
            public AgentCapabilities findValueByNumber(int number) {
              return AgentCapabilities.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opamp.proto.Opamp.getDescriptor().getEnumTypes().get(6);
    }

    private static final AgentCapabilities[] VALUES = values();

    public static AgentCapabilities valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private AgentCapabilities(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.AgentCapabilities)
  }

  /**
   * Protobuf enum {@code opamp.proto.RemoteConfigStatuses}
   */
  public enum RemoteConfigStatuses
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * The value of status field is not set.
     * </pre>
     *
     * <code>RemoteConfigStatuses_UNSET = 0;</code>
     */
    RemoteConfigStatuses_UNSET(0),
    /**
     * <pre>
     * Remote config was successfully applied by the Agent.
     * </pre>
     *
     * <code>RemoteConfigStatuses_APPLIED = 1;</code>
     */
    RemoteConfigStatuses_APPLIED(1),
    /**
     * <pre>
     * Agent is currently applying the remote config that it received earlier.
     * </pre>
     *
     * <code>RemoteConfigStatuses_APPLYING = 2;</code>
     */
    RemoteConfigStatuses_APPLYING(2),
    /**
     * <pre>
     * Agent tried to apply the config received earlier, but it failed.
     * See error_message for more details.
     * </pre>
     *
     * <code>RemoteConfigStatuses_FAILED = 3;</code>
     */
    RemoteConfigStatuses_FAILED(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * The value of status field is not set.
     * </pre>
     *
     * <code>RemoteConfigStatuses_UNSET = 0;</code>
     */
    public static final int RemoteConfigStatuses_UNSET_VALUE = 0;
    /**
     * <pre>
     * Remote config was successfully applied by the Agent.
     * </pre>
     *
     * <code>RemoteConfigStatuses_APPLIED = 1;</code>
     */
    public static final int RemoteConfigStatuses_APPLIED_VALUE = 1;
    /**
     * <pre>
     * Agent is currently applying the remote config that it received earlier.
     * </pre>
     *
     * <code>RemoteConfigStatuses_APPLYING = 2;</code>
     */
    public static final int RemoteConfigStatuses_APPLYING_VALUE = 2;
    /**
     * <pre>
     * Agent tried to apply the config received earlier, but it failed.
     * See error_message for more details.
     * </pre>
     *
     * <code>RemoteConfigStatuses_FAILED = 3;</code>
     */
    public static final int RemoteConfigStatuses_FAILED_VALUE = 3;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static RemoteConfigStatuses valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static RemoteConfigStatuses forNumber(int value) {
      switch (value) {
        case 0: return RemoteConfigStatuses_UNSET;
        case 1: return RemoteConfigStatuses_APPLIED;
        case 2: return RemoteConfigStatuses_APPLYING;
        case 3: return RemoteConfigStatuses_FAILED;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<RemoteConfigStatuses>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        RemoteConfigStatuses> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<RemoteConfigStatuses>() {
            public RemoteConfigStatuses findValueByNumber(int number) {
              return RemoteConfigStatuses.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opamp.proto.Opamp.getDescriptor().getEnumTypes().get(7);
    }

    private static final RemoteConfigStatuses[] VALUES = values();

    public static RemoteConfigStatuses valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private RemoteConfigStatuses(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.RemoteConfigStatuses)
  }

  /**
   * <pre>
   * The status of this package.
   * </pre>
   *
   * Protobuf enum {@code opamp.proto.PackageStatusEnum}
   */
  public enum PackageStatusEnum
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Package is successfully installed by the Agent.
     * The error_message field MUST NOT be set.
     * </pre>
     *
     * <code>PackageStatusEnum_Installed = 0;</code>
     */
    PackageStatusEnum_Installed(0),
    /**
     * <pre>
     * Installation of this package has not yet started.
     * </pre>
     *
     * <code>PackageStatusEnum_InstallPending = 1;</code>
     */
    PackageStatusEnum_InstallPending(1),
    /**
     * <pre>
     * Agent is currently downloading and installing the package.
     * server_offered_hash field MUST be set to indicate the version that the
     * Agent is installing. The error_message field MUST NOT be set.
     * </pre>
     *
     * <code>PackageStatusEnum_Installing = 2;</code>
     */
    PackageStatusEnum_Installing(2),
    /**
     * <pre>
     * Agent tried to install the package but installation failed.
     * server_offered_hash field MUST be set to indicate the version that the Agent
     * tried to install. The error_message may also contain more details about
     * the failure.
     * </pre>
     *
     * <code>PackageStatusEnum_InstallFailed = 3;</code>
     */
    PackageStatusEnum_InstallFailed(3),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Package is successfully installed by the Agent.
     * The error_message field MUST NOT be set.
     * </pre>
     *
     * <code>PackageStatusEnum_Installed = 0;</code>
     */
    public static final int PackageStatusEnum_Installed_VALUE = 0;
    /**
     * <pre>
     * Installation of this package has not yet started.
     * </pre>
     *
     * <code>PackageStatusEnum_InstallPending = 1;</code>
     */
    public static final int PackageStatusEnum_InstallPending_VALUE = 1;
    /**
     * <pre>
     * Agent is currently downloading and installing the package.
     * server_offered_hash field MUST be set to indicate the version that the
     * Agent is installing. The error_message field MUST NOT be set.
     * </pre>
     *
     * <code>PackageStatusEnum_Installing = 2;</code>
     */
    public static final int PackageStatusEnum_Installing_VALUE = 2;
    /**
     * <pre>
     * Agent tried to install the package but installation failed.
     * server_offered_hash field MUST be set to indicate the version that the Agent
     * tried to install. The error_message may also contain more details about
     * the failure.
     * </pre>
     *
     * <code>PackageStatusEnum_InstallFailed = 3;</code>
     */
    public static final int PackageStatusEnum_InstallFailed_VALUE = 3;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static PackageStatusEnum valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static PackageStatusEnum forNumber(int value) {
      switch (value) {
        case 0: return PackageStatusEnum_Installed;
        case 1: return PackageStatusEnum_InstallPending;
        case 2: return PackageStatusEnum_Installing;
        case 3: return PackageStatusEnum_InstallFailed;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PackageStatusEnum>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        PackageStatusEnum> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<PackageStatusEnum>() {
            public PackageStatusEnum findValueByNumber(int number) {
              return PackageStatusEnum.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return opamp.proto.Opamp.getDescriptor().getEnumTypes().get(8);
    }

    private static final PackageStatusEnum[] VALUES = values();

    public static PackageStatusEnum valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private PackageStatusEnum(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:opamp.proto.PackageStatusEnum)
  }

  public interface AgentToServerOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentToServer)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Globally unique identifier of the running instance of the Agent. SHOULD remain
     * unchanged for the lifetime of the Agent process.
     * Recommended format: https://github.com/ulid/spec
     * </pre>
     *
     * <code>string instance_uid = 1;</code>
     * @return The instanceUid.
     */
    java.lang.String getInstanceUid();
    /**
     * <pre>
     * Globally unique identifier of the running instance of the Agent. SHOULD remain
     * unchanged for the lifetime of the Agent process.
     * Recommended format: https://github.com/ulid/spec
     * </pre>
     *
     * <code>string instance_uid = 1;</code>
     * @return The bytes for instanceUid.
     */
    com.google.protobuf.ByteString
        getInstanceUidBytes();

    /**
     * <pre>
     * The sequence number is incremented by 1 for every AgentToServer sent
     * by the Agent. This allows the Server to detect that it missed a message when
     * it notices that the sequence_num is not exactly by 1 greater than the previously
     * received one.
     * </pre>
     *
     * <code>uint64 sequence_num = 2;</code>
     * @return The sequenceNum.
     */
    long getSequenceNum();

    /**
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     * @return Whether the agentDescription field is set.
     */
    boolean hasAgentDescription();
    /**
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     * @return The agentDescription.
     */
    opamp.proto.Opamp.AgentDescription getAgentDescription();
    /**
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     */
    opamp.proto.Opamp.AgentDescriptionOrBuilder getAgentDescriptionOrBuilder();

    /**
     * <pre>
     * Bitmask of flags defined by AgentCapabilities enum.
     * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
     * the Agent. This allows extending the protocol and the AgentCapabilities enum
     * in the future such that old Agents automatically report that they don't
     * support the new capability.
     * This field MUST be always set.
     * </pre>
     *
     * <code>uint64 capabilities = 4;</code>
     * @return The capabilities.
     */
    long getCapabilities();

    /**
     * <pre>
     * The current health of the Agent.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentHealth health = 5;</code>
     * @return Whether the health field is set.
     */
    boolean hasHealth();
    /**
     * <pre>
     * The current health of the Agent.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentHealth health = 5;</code>
     * @return The health.
     */
    opamp.proto.Opamp.AgentHealth getHealth();
    /**
     * <pre>
     * The current health of the Agent.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentHealth health = 5;</code>
     */
    opamp.proto.Opamp.AgentHealthOrBuilder getHealthOrBuilder();

    /**
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     * @return Whether the effectiveConfig field is set.
     */
    boolean hasEffectiveConfig();
    /**
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     * @return The effectiveConfig.
     */
    opamp.proto.Opamp.EffectiveConfig getEffectiveConfig();
    /**
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     */
    opamp.proto.Opamp.EffectiveConfigOrBuilder getEffectiveConfigOrBuilder();

    /**
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     * @return Whether the remoteConfigStatus field is set.
     */
    boolean hasRemoteConfigStatus();
    /**
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     * @return The remoteConfigStatus.
     */
    opamp.proto.Opamp.RemoteConfigStatus getRemoteConfigStatus();
    /**
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     */
    opamp.proto.Opamp.RemoteConfigStatusOrBuilder getRemoteConfigStatusOrBuilder();

    /**
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     * @return Whether the packageStatuses field is set.
     */
    boolean hasPackageStatuses();
    /**
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     * @return The packageStatuses.
     */
    opamp.proto.Opamp.PackageStatuses getPackageStatuses();
    /**
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     */
    opamp.proto.Opamp.PackageStatusesOrBuilder getPackageStatusesOrBuilder();

    /**
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     * @return Whether the agentDisconnect field is set.
     */
    boolean hasAgentDisconnect();
    /**
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     * @return The agentDisconnect.
     */
    opamp.proto.Opamp.AgentDisconnect getAgentDisconnect();
    /**
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     */
    opamp.proto.Opamp.AgentDisconnectOrBuilder getAgentDisconnectOrBuilder();

    /**
     * <pre>
     * Bit flags as defined by AgentToServerFlags bit masks.
     * </pre>
     *
     * <code>uint64 flags = 10;</code>
     * @return The flags.
     */
    long getFlags();
  }
  /**
   * Protobuf type {@code opamp.proto.AgentToServer}
   */
  public static final class AgentToServer extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentToServer)
      AgentToServerOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AgentToServer.newBuilder() to construct.
    private AgentToServer(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AgentToServer() {
      instanceUid_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AgentToServer();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AgentToServer(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              instanceUid_ = s;
              break;
            }
            case 16: {

              sequenceNum_ = input.readUInt64();
              break;
            }
            case 26: {
              opamp.proto.Opamp.AgentDescription.Builder subBuilder = null;
              if (agentDescription_ != null) {
                subBuilder = agentDescription_.toBuilder();
              }
              agentDescription_ = input.readMessage(opamp.proto.Opamp.AgentDescription.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(agentDescription_);
                agentDescription_ = subBuilder.buildPartial();
              }

              break;
            }
            case 32: {

              capabilities_ = input.readUInt64();
              break;
            }
            case 42: {
              opamp.proto.Opamp.AgentHealth.Builder subBuilder = null;
              if (health_ != null) {
                subBuilder = health_.toBuilder();
              }
              health_ = input.readMessage(opamp.proto.Opamp.AgentHealth.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(health_);
                health_ = subBuilder.buildPartial();
              }

              break;
            }
            case 50: {
              opamp.proto.Opamp.EffectiveConfig.Builder subBuilder = null;
              if (effectiveConfig_ != null) {
                subBuilder = effectiveConfig_.toBuilder();
              }
              effectiveConfig_ = input.readMessage(opamp.proto.Opamp.EffectiveConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(effectiveConfig_);
                effectiveConfig_ = subBuilder.buildPartial();
              }

              break;
            }
            case 58: {
              opamp.proto.Opamp.RemoteConfigStatus.Builder subBuilder = null;
              if (remoteConfigStatus_ != null) {
                subBuilder = remoteConfigStatus_.toBuilder();
              }
              remoteConfigStatus_ = input.readMessage(opamp.proto.Opamp.RemoteConfigStatus.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(remoteConfigStatus_);
                remoteConfigStatus_ = subBuilder.buildPartial();
              }

              break;
            }
            case 66: {
              opamp.proto.Opamp.PackageStatuses.Builder subBuilder = null;
              if (packageStatuses_ != null) {
                subBuilder = packageStatuses_.toBuilder();
              }
              packageStatuses_ = input.readMessage(opamp.proto.Opamp.PackageStatuses.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(packageStatuses_);
                packageStatuses_ = subBuilder.buildPartial();
              }

              break;
            }
            case 74: {
              opamp.proto.Opamp.AgentDisconnect.Builder subBuilder = null;
              if (agentDisconnect_ != null) {
                subBuilder = agentDisconnect_.toBuilder();
              }
              agentDisconnect_ = input.readMessage(opamp.proto.Opamp.AgentDisconnect.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(agentDisconnect_);
                agentDisconnect_ = subBuilder.buildPartial();
              }

              break;
            }
            case 80: {

              flags_ = input.readUInt64();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentToServer_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentToServer_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.AgentToServer.class, opamp.proto.Opamp.AgentToServer.Builder.class);
    }

    public static final int INSTANCE_UID_FIELD_NUMBER = 1;
    private volatile java.lang.Object instanceUid_;
    /**
     * <pre>
     * Globally unique identifier of the running instance of the Agent. SHOULD remain
     * unchanged for the lifetime of the Agent process.
     * Recommended format: https://github.com/ulid/spec
     * </pre>
     *
     * <code>string instance_uid = 1;</code>
     * @return The instanceUid.
     */
    @java.lang.Override
    public java.lang.String getInstanceUid() {
      java.lang.Object ref = instanceUid_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        instanceUid_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Globally unique identifier of the running instance of the Agent. SHOULD remain
     * unchanged for the lifetime of the Agent process.
     * Recommended format: https://github.com/ulid/spec
     * </pre>
     *
     * <code>string instance_uid = 1;</code>
     * @return The bytes for instanceUid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getInstanceUidBytes() {
      java.lang.Object ref = instanceUid_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        instanceUid_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SEQUENCE_NUM_FIELD_NUMBER = 2;
    private long sequenceNum_;
    /**
     * <pre>
     * The sequence number is incremented by 1 for every AgentToServer sent
     * by the Agent. This allows the Server to detect that it missed a message when
     * it notices that the sequence_num is not exactly by 1 greater than the previously
     * received one.
     * </pre>
     *
     * <code>uint64 sequence_num = 2;</code>
     * @return The sequenceNum.
     */
    @java.lang.Override
    public long getSequenceNum() {
      return sequenceNum_;
    }

    public static final int AGENT_DESCRIPTION_FIELD_NUMBER = 3;
    private opamp.proto.Opamp.AgentDescription agentDescription_;
    /**
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     * @return Whether the agentDescription field is set.
     */
    @java.lang.Override
    public boolean hasAgentDescription() {
      return agentDescription_ != null;
    }
    /**
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     * @return The agentDescription.
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentDescription getAgentDescription() {
      return agentDescription_ == null ? opamp.proto.Opamp.AgentDescription.getDefaultInstance() : agentDescription_;
    }
    /**
     * <pre>
     * Data that describes the Agent, its type, where it runs, etc.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentDescriptionOrBuilder getAgentDescriptionOrBuilder() {
      return getAgentDescription();
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 4;
    private long capabilities_;
    /**
     * <pre>
     * Bitmask of flags defined by AgentCapabilities enum.
     * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
     * the Agent. This allows extending the protocol and the AgentCapabilities enum
     * in the future such that old Agents automatically report that they don't
     * support the new capability.
     * This field MUST be always set.
     * </pre>
     *
     * <code>uint64 capabilities = 4;</code>
     * @return The capabilities.
     */
    @java.lang.Override
    public long getCapabilities() {
      return capabilities_;
    }

    public static final int HEALTH_FIELD_NUMBER = 5;
    private opamp.proto.Opamp.AgentHealth health_;
    /**
     * <pre>
     * The current health of the Agent.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentHealth health = 5;</code>
     * @return Whether the health field is set.
     */
    @java.lang.Override
    public boolean hasHealth() {
      return health_ != null;
    }
    /**
     * <pre>
     * The current health of the Agent.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentHealth health = 5;</code>
     * @return The health.
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentHealth getHealth() {
      return health_ == null ? opamp.proto.Opamp.AgentHealth.getDefaultInstance() : health_;
    }
    /**
     * <pre>
     * The current health of the Agent.
     * May be omitted if nothing changed since last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.AgentHealth health = 5;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentHealthOrBuilder getHealthOrBuilder() {
      return getHealth();
    }

    public static final int EFFECTIVE_CONFIG_FIELD_NUMBER = 6;
    private opamp.proto.Opamp.EffectiveConfig effectiveConfig_;
    /**
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     * @return Whether the effectiveConfig field is set.
     */
    @java.lang.Override
    public boolean hasEffectiveConfig() {
      return effectiveConfig_ != null;
    }
    /**
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     * @return The effectiveConfig.
     */
    @java.lang.Override
    public opamp.proto.Opamp.EffectiveConfig getEffectiveConfig() {
      return effectiveConfig_ == null ? opamp.proto.Opamp.EffectiveConfig.getDefaultInstance() : effectiveConfig_;
    }
    /**
     * <pre>
     * The current effective configuration of the Agent. The effective configuration is
     * the one that is currently used by the Agent. The effective configuration may be
     * different from the remote configuration received from the Server earlier, e.g.
     * because the Agent uses a local configuration instead (or in addition).
     * This field SHOULD be unset if the effective config is unchanged since the last
     * AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.EffectiveConfigOrBuilder getEffectiveConfigOrBuilder() {
      return getEffectiveConfig();
    }

    public static final int REMOTE_CONFIG_STATUS_FIELD_NUMBER = 7;
    private opamp.proto.Opamp.RemoteConfigStatus remoteConfigStatus_;
    /**
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     * @return Whether the remoteConfigStatus field is set.
     */
    @java.lang.Override
    public boolean hasRemoteConfigStatus() {
      return remoteConfigStatus_ != null;
    }
    /**
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     * @return The remoteConfigStatus.
     */
    @java.lang.Override
    public opamp.proto.Opamp.RemoteConfigStatus getRemoteConfigStatus() {
      return remoteConfigStatus_ == null ? opamp.proto.Opamp.RemoteConfigStatus.getDefaultInstance() : remoteConfigStatus_;
    }
    /**
     * <pre>
     * The status of the remote config that was previously received from the Server.
     * This field SHOULD be unset if the remote config status is unchanged since the
     * last AgentToServer message.
     * </pre>
     *
     * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.RemoteConfigStatusOrBuilder getRemoteConfigStatusOrBuilder() {
      return getRemoteConfigStatus();
    }

    public static final int PACKAGE_STATUSES_FIELD_NUMBER = 8;
    private opamp.proto.Opamp.PackageStatuses packageStatuses_;
    /**
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     * @return Whether the packageStatuses field is set.
     */
    @java.lang.Override
    public boolean hasPackageStatuses() {
      return packageStatuses_ != null;
    }
    /**
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     * @return The packageStatuses.
     */
    @java.lang.Override
    public opamp.proto.Opamp.PackageStatuses getPackageStatuses() {
      return packageStatuses_ == null ? opamp.proto.Opamp.PackageStatuses.getDefaultInstance() : packageStatuses_;
    }
    /**
     * <pre>
     * The list of the Agent packages, including package statuses. This field SHOULD be
     * unset if this information is unchanged since the last AgentToServer message for
     * this Agent was sent in the stream.
     * </pre>
     *
     * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.PackageStatusesOrBuilder getPackageStatusesOrBuilder() {
      return getPackageStatuses();
    }

    public static final int AGENT_DISCONNECT_FIELD_NUMBER = 9;
    private opamp.proto.Opamp.AgentDisconnect agentDisconnect_;
    /**
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     * @return Whether the agentDisconnect field is set.
     */
    @java.lang.Override
    public boolean hasAgentDisconnect() {
      return agentDisconnect_ != null;
    }
    /**
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     * @return The agentDisconnect.
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentDisconnect getAgentDisconnect() {
      return agentDisconnect_ == null ? opamp.proto.Opamp.AgentDisconnect.getDefaultInstance() : agentDisconnect_;
    }
    /**
     * <pre>
     * AgentDisconnect MUST be set in the last AgentToServer message sent from the
     * Agent to the Server.
     * </pre>
     *
     * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentDisconnectOrBuilder getAgentDisconnectOrBuilder() {
      return getAgentDisconnect();
    }

    public static final int FLAGS_FIELD_NUMBER = 10;
    private long flags_;
    /**
     * <pre>
     * Bit flags as defined by AgentToServerFlags bit masks.
     * </pre>
     *
     * <code>uint64 flags = 10;</code>
     * @return The flags.
     */
    @java.lang.Override
    public long getFlags() {
      return flags_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(instanceUid_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, instanceUid_);
      }
      if (sequenceNum_ != 0L) {
        output.writeUInt64(2, sequenceNum_);
      }
      if (agentDescription_ != null) {
        output.writeMessage(3, getAgentDescription());
      }
      if (capabilities_ != 0L) {
        output.writeUInt64(4, capabilities_);
      }
      if (health_ != null) {
        output.writeMessage(5, getHealth());
      }
      if (effectiveConfig_ != null) {
        output.writeMessage(6, getEffectiveConfig());
      }
      if (remoteConfigStatus_ != null) {
        output.writeMessage(7, getRemoteConfigStatus());
      }
      if (packageStatuses_ != null) {
        output.writeMessage(8, getPackageStatuses());
      }
      if (agentDisconnect_ != null) {
        output.writeMessage(9, getAgentDisconnect());
      }
      if (flags_ != 0L) {
        output.writeUInt64(10, flags_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(instanceUid_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, instanceUid_);
      }
      if (sequenceNum_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(2, sequenceNum_);
      }
      if (agentDescription_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAgentDescription());
      }
      if (capabilities_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, capabilities_);
      }
      if (health_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getHealth());
      }
      if (effectiveConfig_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(6, getEffectiveConfig());
      }
      if (remoteConfigStatus_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(7, getRemoteConfigStatus());
      }
      if (packageStatuses_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getPackageStatuses());
      }
      if (agentDisconnect_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getAgentDisconnect());
      }
      if (flags_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(10, flags_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.AgentToServer)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.AgentToServer other = (opamp.proto.Opamp.AgentToServer) obj;

      if (!getInstanceUid()
          .equals(other.getInstanceUid())) return false;
      if (getSequenceNum()
          != other.getSequenceNum()) return false;
      if (hasAgentDescription() != other.hasAgentDescription()) return false;
      if (hasAgentDescription()) {
        if (!getAgentDescription()
            .equals(other.getAgentDescription())) return false;
      }
      if (getCapabilities()
          != other.getCapabilities()) return false;
      if (hasHealth() != other.hasHealth()) return false;
      if (hasHealth()) {
        if (!getHealth()
            .equals(other.getHealth())) return false;
      }
      if (hasEffectiveConfig() != other.hasEffectiveConfig()) return false;
      if (hasEffectiveConfig()) {
        if (!getEffectiveConfig()
            .equals(other.getEffectiveConfig())) return false;
      }
      if (hasRemoteConfigStatus() != other.hasRemoteConfigStatus()) return false;
      if (hasRemoteConfigStatus()) {
        if (!getRemoteConfigStatus()
            .equals(other.getRemoteConfigStatus())) return false;
      }
      if (hasPackageStatuses() != other.hasPackageStatuses()) return false;
      if (hasPackageStatuses()) {
        if (!getPackageStatuses()
            .equals(other.getPackageStatuses())) return false;
      }
      if (hasAgentDisconnect() != other.hasAgentDisconnect()) return false;
      if (hasAgentDisconnect()) {
        if (!getAgentDisconnect()
            .equals(other.getAgentDisconnect())) return false;
      }
      if (getFlags()
          != other.getFlags()) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + INSTANCE_UID_FIELD_NUMBER;
      hash = (53 * hash) + getInstanceUid().hashCode();
      hash = (37 * hash) + SEQUENCE_NUM_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getSequenceNum());
      if (hasAgentDescription()) {
        hash = (37 * hash) + AGENT_DESCRIPTION_FIELD_NUMBER;
        hash = (53 * hash) + getAgentDescription().hashCode();
      }
      hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCapabilities());
      if (hasHealth()) {
        hash = (37 * hash) + HEALTH_FIELD_NUMBER;
        hash = (53 * hash) + getHealth().hashCode();
      }
      if (hasEffectiveConfig()) {
        hash = (37 * hash) + EFFECTIVE_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getEffectiveConfig().hashCode();
      }
      if (hasRemoteConfigStatus()) {
        hash = (37 * hash) + REMOTE_CONFIG_STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getRemoteConfigStatus().hashCode();
      }
      if (hasPackageStatuses()) {
        hash = (37 * hash) + PACKAGE_STATUSES_FIELD_NUMBER;
        hash = (53 * hash) + getPackageStatuses().hashCode();
      }
      if (hasAgentDisconnect()) {
        hash = (37 * hash) + AGENT_DISCONNECT_FIELD_NUMBER;
        hash = (53 * hash) + getAgentDisconnect().hashCode();
      }
      hash = (37 * hash) + FLAGS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getFlags());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.AgentToServer parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentToServer parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentToServer parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentToServer parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentToServer parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentToServer parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentToServer parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentToServer parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentToServer parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentToServer parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentToServer parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentToServer parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.AgentToServer prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.AgentToServer}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentToServer)
        opamp.proto.Opamp.AgentToServerOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentToServer_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentToServer_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.AgentToServer.class, opamp.proto.Opamp.AgentToServer.Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentToServer.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        instanceUid_ = "";

        sequenceNum_ = 0L;

        if (agentDescriptionBuilder_ == null) {
          agentDescription_ = null;
        } else {
          agentDescription_ = null;
          agentDescriptionBuilder_ = null;
        }
        capabilities_ = 0L;

        if (healthBuilder_ == null) {
          health_ = null;
        } else {
          health_ = null;
          healthBuilder_ = null;
        }
        if (effectiveConfigBuilder_ == null) {
          effectiveConfig_ = null;
        } else {
          effectiveConfig_ = null;
          effectiveConfigBuilder_ = null;
        }
        if (remoteConfigStatusBuilder_ == null) {
          remoteConfigStatus_ = null;
        } else {
          remoteConfigStatus_ = null;
          remoteConfigStatusBuilder_ = null;
        }
        if (packageStatusesBuilder_ == null) {
          packageStatuses_ = null;
        } else {
          packageStatuses_ = null;
          packageStatusesBuilder_ = null;
        }
        if (agentDisconnectBuilder_ == null) {
          agentDisconnect_ = null;
        } else {
          agentDisconnect_ = null;
          agentDisconnectBuilder_ = null;
        }
        flags_ = 0L;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentToServer_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentToServer getDefaultInstanceForType() {
        return opamp.proto.Opamp.AgentToServer.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentToServer build() {
        opamp.proto.Opamp.AgentToServer result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentToServer buildPartial() {
        opamp.proto.Opamp.AgentToServer result = new opamp.proto.Opamp.AgentToServer(this);
        result.instanceUid_ = instanceUid_;
        result.sequenceNum_ = sequenceNum_;
        if (agentDescriptionBuilder_ == null) {
          result.agentDescription_ = agentDescription_;
        } else {
          result.agentDescription_ = agentDescriptionBuilder_.build();
        }
        result.capabilities_ = capabilities_;
        if (healthBuilder_ == null) {
          result.health_ = health_;
        } else {
          result.health_ = healthBuilder_.build();
        }
        if (effectiveConfigBuilder_ == null) {
          result.effectiveConfig_ = effectiveConfig_;
        } else {
          result.effectiveConfig_ = effectiveConfigBuilder_.build();
        }
        if (remoteConfigStatusBuilder_ == null) {
          result.remoteConfigStatus_ = remoteConfigStatus_;
        } else {
          result.remoteConfigStatus_ = remoteConfigStatusBuilder_.build();
        }
        if (packageStatusesBuilder_ == null) {
          result.packageStatuses_ = packageStatuses_;
        } else {
          result.packageStatuses_ = packageStatusesBuilder_.build();
        }
        if (agentDisconnectBuilder_ == null) {
          result.agentDisconnect_ = agentDisconnect_;
        } else {
          result.agentDisconnect_ = agentDisconnectBuilder_.build();
        }
        result.flags_ = flags_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.AgentToServer) {
          return mergeFrom((opamp.proto.Opamp.AgentToServer)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.AgentToServer other) {
        if (other == opamp.proto.Opamp.AgentToServer.getDefaultInstance()) return this;
        if (!other.getInstanceUid().isEmpty()) {
          instanceUid_ = other.instanceUid_;
          onChanged();
        }
        if (other.getSequenceNum() != 0L) {
          setSequenceNum(other.getSequenceNum());
        }
        if (other.hasAgentDescription()) {
          mergeAgentDescription(other.getAgentDescription());
        }
        if (other.getCapabilities() != 0L) {
          setCapabilities(other.getCapabilities());
        }
        if (other.hasHealth()) {
          mergeHealth(other.getHealth());
        }
        if (other.hasEffectiveConfig()) {
          mergeEffectiveConfig(other.getEffectiveConfig());
        }
        if (other.hasRemoteConfigStatus()) {
          mergeRemoteConfigStatus(other.getRemoteConfigStatus());
        }
        if (other.hasPackageStatuses()) {
          mergePackageStatuses(other.getPackageStatuses());
        }
        if (other.hasAgentDisconnect()) {
          mergeAgentDisconnect(other.getAgentDisconnect());
        }
        if (other.getFlags() != 0L) {
          setFlags(other.getFlags());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.AgentToServer parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.AgentToServer) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object instanceUid_ = "";
      /**
       * <pre>
       * Globally unique identifier of the running instance of the Agent. SHOULD remain
       * unchanged for the lifetime of the Agent process.
       * Recommended format: https://github.com/ulid/spec
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @return The instanceUid.
       */
      public java.lang.String getInstanceUid() {
        java.lang.Object ref = instanceUid_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          instanceUid_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Globally unique identifier of the running instance of the Agent. SHOULD remain
       * unchanged for the lifetime of the Agent process.
       * Recommended format: https://github.com/ulid/spec
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @return The bytes for instanceUid.
       */
      public com.google.protobuf.ByteString
          getInstanceUidBytes() {
        java.lang.Object ref = instanceUid_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          instanceUid_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Globally unique identifier of the running instance of the Agent. SHOULD remain
       * unchanged for the lifetime of the Agent process.
       * Recommended format: https://github.com/ulid/spec
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @param value The instanceUid to set.
       * @return This builder for chaining.
       */
      public Builder setInstanceUid(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        instanceUid_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Globally unique identifier of the running instance of the Agent. SHOULD remain
       * unchanged for the lifetime of the Agent process.
       * Recommended format: https://github.com/ulid/spec
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearInstanceUid() {
        
        instanceUid_ = getDefaultInstance().getInstanceUid();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Globally unique identifier of the running instance of the Agent. SHOULD remain
       * unchanged for the lifetime of the Agent process.
       * Recommended format: https://github.com/ulid/spec
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @param value The bytes for instanceUid to set.
       * @return This builder for chaining.
       */
      public Builder setInstanceUidBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        instanceUid_ = value;
        onChanged();
        return this;
      }

      private long sequenceNum_ ;
      /**
       * <pre>
       * The sequence number is incremented by 1 for every AgentToServer sent
       * by the Agent. This allows the Server to detect that it missed a message when
       * it notices that the sequence_num is not exactly by 1 greater than the previously
       * received one.
       * </pre>
       *
       * <code>uint64 sequence_num = 2;</code>
       * @return The sequenceNum.
       */
      @java.lang.Override
      public long getSequenceNum() {
        return sequenceNum_;
      }
      /**
       * <pre>
       * The sequence number is incremented by 1 for every AgentToServer sent
       * by the Agent. This allows the Server to detect that it missed a message when
       * it notices that the sequence_num is not exactly by 1 greater than the previously
       * received one.
       * </pre>
       *
       * <code>uint64 sequence_num = 2;</code>
       * @param value The sequenceNum to set.
       * @return This builder for chaining.
       */
      public Builder setSequenceNum(long value) {
        
        sequenceNum_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The sequence number is incremented by 1 for every AgentToServer sent
       * by the Agent. This allows the Server to detect that it missed a message when
       * it notices that the sequence_num is not exactly by 1 greater than the previously
       * received one.
       * </pre>
       *
       * <code>uint64 sequence_num = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearSequenceNum() {
        
        sequenceNum_ = 0L;
        onChanged();
        return this;
      }

      private opamp.proto.Opamp.AgentDescription agentDescription_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentDescription, opamp.proto.Opamp.AgentDescription.Builder, opamp.proto.Opamp.AgentDescriptionOrBuilder> agentDescriptionBuilder_;
      /**
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       * @return Whether the agentDescription field is set.
       */
      public boolean hasAgentDescription() {
        return agentDescriptionBuilder_ != null || agentDescription_ != null;
      }
      /**
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       * @return The agentDescription.
       */
      public opamp.proto.Opamp.AgentDescription getAgentDescription() {
        if (agentDescriptionBuilder_ == null) {
          return agentDescription_ == null ? opamp.proto.Opamp.AgentDescription.getDefaultInstance() : agentDescription_;
        } else {
          return agentDescriptionBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public Builder setAgentDescription(opamp.proto.Opamp.AgentDescription value) {
        if (agentDescriptionBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          agentDescription_ = value;
          onChanged();
        } else {
          agentDescriptionBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public Builder setAgentDescription(
          opamp.proto.Opamp.AgentDescription.Builder builderForValue) {
        if (agentDescriptionBuilder_ == null) {
          agentDescription_ = builderForValue.build();
          onChanged();
        } else {
          agentDescriptionBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public Builder mergeAgentDescription(opamp.proto.Opamp.AgentDescription value) {
        if (agentDescriptionBuilder_ == null) {
          if (agentDescription_ != null) {
            agentDescription_ =
              opamp.proto.Opamp.AgentDescription.newBuilder(agentDescription_).mergeFrom(value).buildPartial();
          } else {
            agentDescription_ = value;
          }
          onChanged();
        } else {
          agentDescriptionBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public Builder clearAgentDescription() {
        if (agentDescriptionBuilder_ == null) {
          agentDescription_ = null;
          onChanged();
        } else {
          agentDescription_ = null;
          agentDescriptionBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public opamp.proto.Opamp.AgentDescription.Builder getAgentDescriptionBuilder() {
        
        onChanged();
        return getAgentDescriptionFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      public opamp.proto.Opamp.AgentDescriptionOrBuilder getAgentDescriptionOrBuilder() {
        if (agentDescriptionBuilder_ != null) {
          return agentDescriptionBuilder_.getMessageOrBuilder();
        } else {
          return agentDescription_ == null ?
              opamp.proto.Opamp.AgentDescription.getDefaultInstance() : agentDescription_;
        }
      }
      /**
       * <pre>
       * Data that describes the Agent, its type, where it runs, etc.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentDescription agent_description = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentDescription, opamp.proto.Opamp.AgentDescription.Builder, opamp.proto.Opamp.AgentDescriptionOrBuilder> 
          getAgentDescriptionFieldBuilder() {
        if (agentDescriptionBuilder_ == null) {
          agentDescriptionBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.AgentDescription, opamp.proto.Opamp.AgentDescription.Builder, opamp.proto.Opamp.AgentDescriptionOrBuilder>(
                  getAgentDescription(),
                  getParentForChildren(),
                  isClean());
          agentDescription_ = null;
        }
        return agentDescriptionBuilder_;
      }

      private long capabilities_ ;
      /**
       * <pre>
       * Bitmask of flags defined by AgentCapabilities enum.
       * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
       * the Agent. This allows extending the protocol and the AgentCapabilities enum
       * in the future such that old Agents automatically report that they don't
       * support the new capability.
       * This field MUST be always set.
       * </pre>
       *
       * <code>uint64 capabilities = 4;</code>
       * @return The capabilities.
       */
      @java.lang.Override
      public long getCapabilities() {
        return capabilities_;
      }
      /**
       * <pre>
       * Bitmask of flags defined by AgentCapabilities enum.
       * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
       * the Agent. This allows extending the protocol and the AgentCapabilities enum
       * in the future such that old Agents automatically report that they don't
       * support the new capability.
       * This field MUST be always set.
       * </pre>
       *
       * <code>uint64 capabilities = 4;</code>
       * @param value The capabilities to set.
       * @return This builder for chaining.
       */
      public Builder setCapabilities(long value) {
        
        capabilities_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Bitmask of flags defined by AgentCapabilities enum.
       * All bits that are not defined in AgentCapabilities enum MUST be set to 0 by
       * the Agent. This allows extending the protocol and the AgentCapabilities enum
       * in the future such that old Agents automatically report that they don't
       * support the new capability.
       * This field MUST be always set.
       * </pre>
       *
       * <code>uint64 capabilities = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearCapabilities() {
        
        capabilities_ = 0L;
        onChanged();
        return this;
      }

      private opamp.proto.Opamp.AgentHealth health_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentHealth, opamp.proto.Opamp.AgentHealth.Builder, opamp.proto.Opamp.AgentHealthOrBuilder> healthBuilder_;
      /**
       * <pre>
       * The current health of the Agent.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentHealth health = 5;</code>
       * @return Whether the health field is set.
       */
      public boolean hasHealth() {
        return healthBuilder_ != null || health_ != null;
      }
      /**
       * <pre>
       * The current health of the Agent.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentHealth health = 5;</code>
       * @return The health.
       */
      public opamp.proto.Opamp.AgentHealth getHealth() {
        if (healthBuilder_ == null) {
          return health_ == null ? opamp.proto.Opamp.AgentHealth.getDefaultInstance() : health_;
        } else {
          return healthBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The current health of the Agent.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentHealth health = 5;</code>
       */
      public Builder setHealth(opamp.proto.Opamp.AgentHealth value) {
        if (healthBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          health_ = value;
          onChanged();
        } else {
          healthBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The current health of the Agent.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentHealth health = 5;</code>
       */
      public Builder setHealth(
          opamp.proto.Opamp.AgentHealth.Builder builderForValue) {
        if (healthBuilder_ == null) {
          health_ = builderForValue.build();
          onChanged();
        } else {
          healthBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The current health of the Agent.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentHealth health = 5;</code>
       */
      public Builder mergeHealth(opamp.proto.Opamp.AgentHealth value) {
        if (healthBuilder_ == null) {
          if (health_ != null) {
            health_ =
              opamp.proto.Opamp.AgentHealth.newBuilder(health_).mergeFrom(value).buildPartial();
          } else {
            health_ = value;
          }
          onChanged();
        } else {
          healthBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The current health of the Agent.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentHealth health = 5;</code>
       */
      public Builder clearHealth() {
        if (healthBuilder_ == null) {
          health_ = null;
          onChanged();
        } else {
          health_ = null;
          healthBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The current health of the Agent.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentHealth health = 5;</code>
       */
      public opamp.proto.Opamp.AgentHealth.Builder getHealthBuilder() {
        
        onChanged();
        return getHealthFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The current health of the Agent.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentHealth health = 5;</code>
       */
      public opamp.proto.Opamp.AgentHealthOrBuilder getHealthOrBuilder() {
        if (healthBuilder_ != null) {
          return healthBuilder_.getMessageOrBuilder();
        } else {
          return health_ == null ?
              opamp.proto.Opamp.AgentHealth.getDefaultInstance() : health_;
        }
      }
      /**
       * <pre>
       * The current health of the Agent.
       * May be omitted if nothing changed since last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.AgentHealth health = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentHealth, opamp.proto.Opamp.AgentHealth.Builder, opamp.proto.Opamp.AgentHealthOrBuilder> 
          getHealthFieldBuilder() {
        if (healthBuilder_ == null) {
          healthBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.AgentHealth, opamp.proto.Opamp.AgentHealth.Builder, opamp.proto.Opamp.AgentHealthOrBuilder>(
                  getHealth(),
                  getParentForChildren(),
                  isClean());
          health_ = null;
        }
        return healthBuilder_;
      }

      private opamp.proto.Opamp.EffectiveConfig effectiveConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.EffectiveConfig, opamp.proto.Opamp.EffectiveConfig.Builder, opamp.proto.Opamp.EffectiveConfigOrBuilder> effectiveConfigBuilder_;
      /**
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       * @return Whether the effectiveConfig field is set.
       */
      public boolean hasEffectiveConfig() {
        return effectiveConfigBuilder_ != null || effectiveConfig_ != null;
      }
      /**
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       * @return The effectiveConfig.
       */
      public opamp.proto.Opamp.EffectiveConfig getEffectiveConfig() {
        if (effectiveConfigBuilder_ == null) {
          return effectiveConfig_ == null ? opamp.proto.Opamp.EffectiveConfig.getDefaultInstance() : effectiveConfig_;
        } else {
          return effectiveConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public Builder setEffectiveConfig(opamp.proto.Opamp.EffectiveConfig value) {
        if (effectiveConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          effectiveConfig_ = value;
          onChanged();
        } else {
          effectiveConfigBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public Builder setEffectiveConfig(
          opamp.proto.Opamp.EffectiveConfig.Builder builderForValue) {
        if (effectiveConfigBuilder_ == null) {
          effectiveConfig_ = builderForValue.build();
          onChanged();
        } else {
          effectiveConfigBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public Builder mergeEffectiveConfig(opamp.proto.Opamp.EffectiveConfig value) {
        if (effectiveConfigBuilder_ == null) {
          if (effectiveConfig_ != null) {
            effectiveConfig_ =
              opamp.proto.Opamp.EffectiveConfig.newBuilder(effectiveConfig_).mergeFrom(value).buildPartial();
          } else {
            effectiveConfig_ = value;
          }
          onChanged();
        } else {
          effectiveConfigBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public Builder clearEffectiveConfig() {
        if (effectiveConfigBuilder_ == null) {
          effectiveConfig_ = null;
          onChanged();
        } else {
          effectiveConfig_ = null;
          effectiveConfigBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public opamp.proto.Opamp.EffectiveConfig.Builder getEffectiveConfigBuilder() {
        
        onChanged();
        return getEffectiveConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      public opamp.proto.Opamp.EffectiveConfigOrBuilder getEffectiveConfigOrBuilder() {
        if (effectiveConfigBuilder_ != null) {
          return effectiveConfigBuilder_.getMessageOrBuilder();
        } else {
          return effectiveConfig_ == null ?
              opamp.proto.Opamp.EffectiveConfig.getDefaultInstance() : effectiveConfig_;
        }
      }
      /**
       * <pre>
       * The current effective configuration of the Agent. The effective configuration is
       * the one that is currently used by the Agent. The effective configuration may be
       * different from the remote configuration received from the Server earlier, e.g.
       * because the Agent uses a local configuration instead (or in addition).
       * This field SHOULD be unset if the effective config is unchanged since the last
       * AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.EffectiveConfig effective_config = 6;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.EffectiveConfig, opamp.proto.Opamp.EffectiveConfig.Builder, opamp.proto.Opamp.EffectiveConfigOrBuilder> 
          getEffectiveConfigFieldBuilder() {
        if (effectiveConfigBuilder_ == null) {
          effectiveConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.EffectiveConfig, opamp.proto.Opamp.EffectiveConfig.Builder, opamp.proto.Opamp.EffectiveConfigOrBuilder>(
                  getEffectiveConfig(),
                  getParentForChildren(),
                  isClean());
          effectiveConfig_ = null;
        }
        return effectiveConfigBuilder_;
      }

      private opamp.proto.Opamp.RemoteConfigStatus remoteConfigStatus_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.RemoteConfigStatus, opamp.proto.Opamp.RemoteConfigStatus.Builder, opamp.proto.Opamp.RemoteConfigStatusOrBuilder> remoteConfigStatusBuilder_;
      /**
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       * @return Whether the remoteConfigStatus field is set.
       */
      public boolean hasRemoteConfigStatus() {
        return remoteConfigStatusBuilder_ != null || remoteConfigStatus_ != null;
      }
      /**
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       * @return The remoteConfigStatus.
       */
      public opamp.proto.Opamp.RemoteConfigStatus getRemoteConfigStatus() {
        if (remoteConfigStatusBuilder_ == null) {
          return remoteConfigStatus_ == null ? opamp.proto.Opamp.RemoteConfigStatus.getDefaultInstance() : remoteConfigStatus_;
        } else {
          return remoteConfigStatusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public Builder setRemoteConfigStatus(opamp.proto.Opamp.RemoteConfigStatus value) {
        if (remoteConfigStatusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          remoteConfigStatus_ = value;
          onChanged();
        } else {
          remoteConfigStatusBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public Builder setRemoteConfigStatus(
          opamp.proto.Opamp.RemoteConfigStatus.Builder builderForValue) {
        if (remoteConfigStatusBuilder_ == null) {
          remoteConfigStatus_ = builderForValue.build();
          onChanged();
        } else {
          remoteConfigStatusBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public Builder mergeRemoteConfigStatus(opamp.proto.Opamp.RemoteConfigStatus value) {
        if (remoteConfigStatusBuilder_ == null) {
          if (remoteConfigStatus_ != null) {
            remoteConfigStatus_ =
              opamp.proto.Opamp.RemoteConfigStatus.newBuilder(remoteConfigStatus_).mergeFrom(value).buildPartial();
          } else {
            remoteConfigStatus_ = value;
          }
          onChanged();
        } else {
          remoteConfigStatusBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public Builder clearRemoteConfigStatus() {
        if (remoteConfigStatusBuilder_ == null) {
          remoteConfigStatus_ = null;
          onChanged();
        } else {
          remoteConfigStatus_ = null;
          remoteConfigStatusBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public opamp.proto.Opamp.RemoteConfigStatus.Builder getRemoteConfigStatusBuilder() {
        
        onChanged();
        return getRemoteConfigStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      public opamp.proto.Opamp.RemoteConfigStatusOrBuilder getRemoteConfigStatusOrBuilder() {
        if (remoteConfigStatusBuilder_ != null) {
          return remoteConfigStatusBuilder_.getMessageOrBuilder();
        } else {
          return remoteConfigStatus_ == null ?
              opamp.proto.Opamp.RemoteConfigStatus.getDefaultInstance() : remoteConfigStatus_;
        }
      }
      /**
       * <pre>
       * The status of the remote config that was previously received from the Server.
       * This field SHOULD be unset if the remote config status is unchanged since the
       * last AgentToServer message.
       * </pre>
       *
       * <code>.opamp.proto.RemoteConfigStatus remote_config_status = 7;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.RemoteConfigStatus, opamp.proto.Opamp.RemoteConfigStatus.Builder, opamp.proto.Opamp.RemoteConfigStatusOrBuilder> 
          getRemoteConfigStatusFieldBuilder() {
        if (remoteConfigStatusBuilder_ == null) {
          remoteConfigStatusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.RemoteConfigStatus, opamp.proto.Opamp.RemoteConfigStatus.Builder, opamp.proto.Opamp.RemoteConfigStatusOrBuilder>(
                  getRemoteConfigStatus(),
                  getParentForChildren(),
                  isClean());
          remoteConfigStatus_ = null;
        }
        return remoteConfigStatusBuilder_;
      }

      private opamp.proto.Opamp.PackageStatuses packageStatuses_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.PackageStatuses, opamp.proto.Opamp.PackageStatuses.Builder, opamp.proto.Opamp.PackageStatusesOrBuilder> packageStatusesBuilder_;
      /**
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       * @return Whether the packageStatuses field is set.
       */
      public boolean hasPackageStatuses() {
        return packageStatusesBuilder_ != null || packageStatuses_ != null;
      }
      /**
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       * @return The packageStatuses.
       */
      public opamp.proto.Opamp.PackageStatuses getPackageStatuses() {
        if (packageStatusesBuilder_ == null) {
          return packageStatuses_ == null ? opamp.proto.Opamp.PackageStatuses.getDefaultInstance() : packageStatuses_;
        } else {
          return packageStatusesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public Builder setPackageStatuses(opamp.proto.Opamp.PackageStatuses value) {
        if (packageStatusesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          packageStatuses_ = value;
          onChanged();
        } else {
          packageStatusesBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public Builder setPackageStatuses(
          opamp.proto.Opamp.PackageStatuses.Builder builderForValue) {
        if (packageStatusesBuilder_ == null) {
          packageStatuses_ = builderForValue.build();
          onChanged();
        } else {
          packageStatusesBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public Builder mergePackageStatuses(opamp.proto.Opamp.PackageStatuses value) {
        if (packageStatusesBuilder_ == null) {
          if (packageStatuses_ != null) {
            packageStatuses_ =
              opamp.proto.Opamp.PackageStatuses.newBuilder(packageStatuses_).mergeFrom(value).buildPartial();
          } else {
            packageStatuses_ = value;
          }
          onChanged();
        } else {
          packageStatusesBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public Builder clearPackageStatuses() {
        if (packageStatusesBuilder_ == null) {
          packageStatuses_ = null;
          onChanged();
        } else {
          packageStatuses_ = null;
          packageStatusesBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public opamp.proto.Opamp.PackageStatuses.Builder getPackageStatusesBuilder() {
        
        onChanged();
        return getPackageStatusesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      public opamp.proto.Opamp.PackageStatusesOrBuilder getPackageStatusesOrBuilder() {
        if (packageStatusesBuilder_ != null) {
          return packageStatusesBuilder_.getMessageOrBuilder();
        } else {
          return packageStatuses_ == null ?
              opamp.proto.Opamp.PackageStatuses.getDefaultInstance() : packageStatuses_;
        }
      }
      /**
       * <pre>
       * The list of the Agent packages, including package statuses. This field SHOULD be
       * unset if this information is unchanged since the last AgentToServer message for
       * this Agent was sent in the stream.
       * </pre>
       *
       * <code>.opamp.proto.PackageStatuses package_statuses = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.PackageStatuses, opamp.proto.Opamp.PackageStatuses.Builder, opamp.proto.Opamp.PackageStatusesOrBuilder> 
          getPackageStatusesFieldBuilder() {
        if (packageStatusesBuilder_ == null) {
          packageStatusesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.PackageStatuses, opamp.proto.Opamp.PackageStatuses.Builder, opamp.proto.Opamp.PackageStatusesOrBuilder>(
                  getPackageStatuses(),
                  getParentForChildren(),
                  isClean());
          packageStatuses_ = null;
        }
        return packageStatusesBuilder_;
      }

      private opamp.proto.Opamp.AgentDisconnect agentDisconnect_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentDisconnect, opamp.proto.Opamp.AgentDisconnect.Builder, opamp.proto.Opamp.AgentDisconnectOrBuilder> agentDisconnectBuilder_;
      /**
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       * @return Whether the agentDisconnect field is set.
       */
      public boolean hasAgentDisconnect() {
        return agentDisconnectBuilder_ != null || agentDisconnect_ != null;
      }
      /**
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       * @return The agentDisconnect.
       */
      public opamp.proto.Opamp.AgentDisconnect getAgentDisconnect() {
        if (agentDisconnectBuilder_ == null) {
          return agentDisconnect_ == null ? opamp.proto.Opamp.AgentDisconnect.getDefaultInstance() : agentDisconnect_;
        } else {
          return agentDisconnectBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public Builder setAgentDisconnect(opamp.proto.Opamp.AgentDisconnect value) {
        if (agentDisconnectBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          agentDisconnect_ = value;
          onChanged();
        } else {
          agentDisconnectBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public Builder setAgentDisconnect(
          opamp.proto.Opamp.AgentDisconnect.Builder builderForValue) {
        if (agentDisconnectBuilder_ == null) {
          agentDisconnect_ = builderForValue.build();
          onChanged();
        } else {
          agentDisconnectBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public Builder mergeAgentDisconnect(opamp.proto.Opamp.AgentDisconnect value) {
        if (agentDisconnectBuilder_ == null) {
          if (agentDisconnect_ != null) {
            agentDisconnect_ =
              opamp.proto.Opamp.AgentDisconnect.newBuilder(agentDisconnect_).mergeFrom(value).buildPartial();
          } else {
            agentDisconnect_ = value;
          }
          onChanged();
        } else {
          agentDisconnectBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public Builder clearAgentDisconnect() {
        if (agentDisconnectBuilder_ == null) {
          agentDisconnect_ = null;
          onChanged();
        } else {
          agentDisconnect_ = null;
          agentDisconnectBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public opamp.proto.Opamp.AgentDisconnect.Builder getAgentDisconnectBuilder() {
        
        onChanged();
        return getAgentDisconnectFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      public opamp.proto.Opamp.AgentDisconnectOrBuilder getAgentDisconnectOrBuilder() {
        if (agentDisconnectBuilder_ != null) {
          return agentDisconnectBuilder_.getMessageOrBuilder();
        } else {
          return agentDisconnect_ == null ?
              opamp.proto.Opamp.AgentDisconnect.getDefaultInstance() : agentDisconnect_;
        }
      }
      /**
       * <pre>
       * AgentDisconnect MUST be set in the last AgentToServer message sent from the
       * Agent to the Server.
       * </pre>
       *
       * <code>.opamp.proto.AgentDisconnect agent_disconnect = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentDisconnect, opamp.proto.Opamp.AgentDisconnect.Builder, opamp.proto.Opamp.AgentDisconnectOrBuilder> 
          getAgentDisconnectFieldBuilder() {
        if (agentDisconnectBuilder_ == null) {
          agentDisconnectBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.AgentDisconnect, opamp.proto.Opamp.AgentDisconnect.Builder, opamp.proto.Opamp.AgentDisconnectOrBuilder>(
                  getAgentDisconnect(),
                  getParentForChildren(),
                  isClean());
          agentDisconnect_ = null;
        }
        return agentDisconnectBuilder_;
      }

      private long flags_ ;
      /**
       * <pre>
       * Bit flags as defined by AgentToServerFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 10;</code>
       * @return The flags.
       */
      @java.lang.Override
      public long getFlags() {
        return flags_;
      }
      /**
       * <pre>
       * Bit flags as defined by AgentToServerFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 10;</code>
       * @param value The flags to set.
       * @return This builder for chaining.
       */
      public Builder setFlags(long value) {
        
        flags_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Bit flags as defined by AgentToServerFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 10;</code>
       * @return This builder for chaining.
       */
      public Builder clearFlags() {
        
        flags_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentToServer)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentToServer)
    private static final opamp.proto.Opamp.AgentToServer DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.AgentToServer();
    }

    public static opamp.proto.Opamp.AgentToServer getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentToServer>
        PARSER = new com.google.protobuf.AbstractParser<AgentToServer>() {
      @java.lang.Override
      public AgentToServer parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AgentToServer(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AgentToServer> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AgentToServer> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.AgentToServer getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AgentDisconnectOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentDisconnect)
      com.google.protobuf.MessageOrBuilder {
  }
  /**
   * <pre>
   * AgentDisconnect is the last message sent from the Agent to the Server. The Server
   * SHOULD forget the association of the Agent instance with the message stream.
   * If the message stream is closed in the transport layer then the Server SHOULD
   * forget association of all Agent instances that were previously established for
   * this message stream using AgentConnect message, even if the corresponding
   * AgentDisconnect message were not explicitly received from the Agent.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.AgentDisconnect}
   */
  public static final class AgentDisconnect extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentDisconnect)
      AgentDisconnectOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AgentDisconnect.newBuilder() to construct.
    private AgentDisconnect(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AgentDisconnect() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AgentDisconnect();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AgentDisconnect(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentDisconnect_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentDisconnect_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.AgentDisconnect.class, opamp.proto.Opamp.AgentDisconnect.Builder.class);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.AgentDisconnect)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.AgentDisconnect other = (opamp.proto.Opamp.AgentDisconnect) obj;

      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.AgentDisconnect parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentDisconnect parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.AgentDisconnect prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * AgentDisconnect is the last message sent from the Agent to the Server. The Server
     * SHOULD forget the association of the Agent instance with the message stream.
     * If the message stream is closed in the transport layer then the Server SHOULD
     * forget association of all Agent instances that were previously established for
     * this message stream using AgentConnect message, even if the corresponding
     * AgentDisconnect message were not explicitly received from the Agent.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.AgentDisconnect}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentDisconnect)
        opamp.proto.Opamp.AgentDisconnectOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentDisconnect_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentDisconnect_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.AgentDisconnect.class, opamp.proto.Opamp.AgentDisconnect.Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentDisconnect.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentDisconnect_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentDisconnect getDefaultInstanceForType() {
        return opamp.proto.Opamp.AgentDisconnect.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentDisconnect build() {
        opamp.proto.Opamp.AgentDisconnect result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentDisconnect buildPartial() {
        opamp.proto.Opamp.AgentDisconnect result = new opamp.proto.Opamp.AgentDisconnect(this);
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.AgentDisconnect) {
          return mergeFrom((opamp.proto.Opamp.AgentDisconnect)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.AgentDisconnect other) {
        if (other == opamp.proto.Opamp.AgentDisconnect.getDefaultInstance()) return this;
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.AgentDisconnect parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.AgentDisconnect) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentDisconnect)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentDisconnect)
    private static final opamp.proto.Opamp.AgentDisconnect DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.AgentDisconnect();
    }

    public static opamp.proto.Opamp.AgentDisconnect getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentDisconnect>
        PARSER = new com.google.protobuf.AbstractParser<AgentDisconnect>() {
      @java.lang.Override
      public AgentDisconnect parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AgentDisconnect(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AgentDisconnect> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AgentDisconnect> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.AgentDisconnect getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ServerToAgentOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ServerToAgent)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
     * Used for multiplexing messages from/to multiple agents using one message stream.
     * </pre>
     *
     * <code>string instance_uid = 1;</code>
     * @return The instanceUid.
     */
    java.lang.String getInstanceUid();
    /**
     * <pre>
     * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
     * Used for multiplexing messages from/to multiple agents using one message stream.
     * </pre>
     *
     * <code>string instance_uid = 1;</code>
     * @return The bytes for instanceUid.
     */
    com.google.protobuf.ByteString
        getInstanceUidBytes();

    /**
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     * @return Whether the errorResponse field is set.
     */
    boolean hasErrorResponse();
    /**
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     * @return The errorResponse.
     */
    opamp.proto.Opamp.ServerErrorResponse getErrorResponse();
    /**
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     */
    opamp.proto.Opamp.ServerErrorResponseOrBuilder getErrorResponseOrBuilder();

    /**
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     * @return Whether the remoteConfig field is set.
     */
    boolean hasRemoteConfig();
    /**
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     * @return The remoteConfig.
     */
    opamp.proto.Opamp.AgentRemoteConfig getRemoteConfig();
    /**
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     */
    opamp.proto.Opamp.AgentRemoteConfigOrBuilder getRemoteConfigOrBuilder();

    /**
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     * @return Whether the connectionSettings field is set.
     */
    boolean hasConnectionSettings();
    /**
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     * @return The connectionSettings.
     */
    opamp.proto.Opamp.ConnectionSettingsOffers getConnectionSettings();
    /**
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     */
    opamp.proto.Opamp.ConnectionSettingsOffersOrBuilder getConnectionSettingsOrBuilder();

    /**
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     * @return Whether the packagesAvailable field is set.
     */
    boolean hasPackagesAvailable();
    /**
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     * @return The packagesAvailable.
     */
    opamp.proto.Opamp.PackagesAvailable getPackagesAvailable();
    /**
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     */
    opamp.proto.Opamp.PackagesAvailableOrBuilder getPackagesAvailableOrBuilder();

    /**
     * <pre>
     * Bit flags as defined by ServerToAgentFlags bit masks.
     * </pre>
     *
     * <code>uint64 flags = 6;</code>
     * @return The flags.
     */
    long getFlags();

    /**
     * <pre>
     * Bitmask of flags defined by ServerCapabilities enum.
     * All bits that are not defined in ServerCapabilities enum MUST be set to 0
     * by the Server. This allows extending the protocol and the ServerCapabilities
     * enum in the future such that old Servers automatically report that they
     * don't support the new capability.
     * This field MUST be set in the first ServerToAgent sent by the Server and MAY
     * be omitted in subsequent ServerToAgent messages by setting it to
     * UnspecifiedServerCapability value.
     * </pre>
     *
     * <code>uint64 capabilities = 7;</code>
     * @return The capabilities.
     */
    long getCapabilities();

    /**
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     * @return Whether the agentIdentification field is set.
     */
    boolean hasAgentIdentification();
    /**
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     * @return The agentIdentification.
     */
    opamp.proto.Opamp.AgentIdentification getAgentIdentification();
    /**
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     */
    opamp.proto.Opamp.AgentIdentificationOrBuilder getAgentIdentificationOrBuilder();

    /**
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     * @return Whether the command field is set.
     */
    boolean hasCommand();
    /**
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     * @return The command.
     */
    opamp.proto.Opamp.ServerToAgentCommand getCommand();
    /**
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     */
    opamp.proto.Opamp.ServerToAgentCommandOrBuilder getCommandOrBuilder();
  }
  /**
   * Protobuf type {@code opamp.proto.ServerToAgent}
   */
  public static final class ServerToAgent extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ServerToAgent)
      ServerToAgentOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ServerToAgent.newBuilder() to construct.
    private ServerToAgent(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ServerToAgent() {
      instanceUid_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ServerToAgent();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ServerToAgent(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              instanceUid_ = s;
              break;
            }
            case 18: {
              opamp.proto.Opamp.ServerErrorResponse.Builder subBuilder = null;
              if (errorResponse_ != null) {
                subBuilder = errorResponse_.toBuilder();
              }
              errorResponse_ = input.readMessage(opamp.proto.Opamp.ServerErrorResponse.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(errorResponse_);
                errorResponse_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              opamp.proto.Opamp.AgentRemoteConfig.Builder subBuilder = null;
              if (remoteConfig_ != null) {
                subBuilder = remoteConfig_.toBuilder();
              }
              remoteConfig_ = input.readMessage(opamp.proto.Opamp.AgentRemoteConfig.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(remoteConfig_);
                remoteConfig_ = subBuilder.buildPartial();
              }

              break;
            }
            case 34: {
              opamp.proto.Opamp.ConnectionSettingsOffers.Builder subBuilder = null;
              if (connectionSettings_ != null) {
                subBuilder = connectionSettings_.toBuilder();
              }
              connectionSettings_ = input.readMessage(opamp.proto.Opamp.ConnectionSettingsOffers.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(connectionSettings_);
                connectionSettings_ = subBuilder.buildPartial();
              }

              break;
            }
            case 42: {
              opamp.proto.Opamp.PackagesAvailable.Builder subBuilder = null;
              if (packagesAvailable_ != null) {
                subBuilder = packagesAvailable_.toBuilder();
              }
              packagesAvailable_ = input.readMessage(opamp.proto.Opamp.PackagesAvailable.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(packagesAvailable_);
                packagesAvailable_ = subBuilder.buildPartial();
              }

              break;
            }
            case 48: {

              flags_ = input.readUInt64();
              break;
            }
            case 56: {

              capabilities_ = input.readUInt64();
              break;
            }
            case 66: {
              opamp.proto.Opamp.AgentIdentification.Builder subBuilder = null;
              if (agentIdentification_ != null) {
                subBuilder = agentIdentification_.toBuilder();
              }
              agentIdentification_ = input.readMessage(opamp.proto.Opamp.AgentIdentification.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(agentIdentification_);
                agentIdentification_ = subBuilder.buildPartial();
              }

              break;
            }
            case 74: {
              opamp.proto.Opamp.ServerToAgentCommand.Builder subBuilder = null;
              if (command_ != null) {
                subBuilder = command_.toBuilder();
              }
              command_ = input.readMessage(opamp.proto.Opamp.ServerToAgentCommand.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(command_);
                command_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgent_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgent_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.ServerToAgent.class, opamp.proto.Opamp.ServerToAgent.Builder.class);
    }

    public static final int INSTANCE_UID_FIELD_NUMBER = 1;
    private volatile java.lang.Object instanceUid_;
    /**
     * <pre>
     * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
     * Used for multiplexing messages from/to multiple agents using one message stream.
     * </pre>
     *
     * <code>string instance_uid = 1;</code>
     * @return The instanceUid.
     */
    @java.lang.Override
    public java.lang.String getInstanceUid() {
      java.lang.Object ref = instanceUid_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        instanceUid_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
     * Used for multiplexing messages from/to multiple agents using one message stream.
     * </pre>
     *
     * <code>string instance_uid = 1;</code>
     * @return The bytes for instanceUid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getInstanceUidBytes() {
      java.lang.Object ref = instanceUid_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        instanceUid_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ERROR_RESPONSE_FIELD_NUMBER = 2;
    private opamp.proto.Opamp.ServerErrorResponse errorResponse_;
    /**
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     * @return Whether the errorResponse field is set.
     */
    @java.lang.Override
    public boolean hasErrorResponse() {
      return errorResponse_ != null;
    }
    /**
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     * @return The errorResponse.
     */
    @java.lang.Override
    public opamp.proto.Opamp.ServerErrorResponse getErrorResponse() {
      return errorResponse_ == null ? opamp.proto.Opamp.ServerErrorResponse.getDefaultInstance() : errorResponse_;
    }
    /**
     * <pre>
     * error_response is set if the Server wants to indicate that something went wrong
     * during processing of an AgentToServer message. If error_response is set then
     * all other fields below must be unset and vice versa, if any of the fields below is
     * set then error_response must be unset.
     * </pre>
     *
     * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.ServerErrorResponseOrBuilder getErrorResponseOrBuilder() {
      return getErrorResponse();
    }

    public static final int REMOTE_CONFIG_FIELD_NUMBER = 3;
    private opamp.proto.Opamp.AgentRemoteConfig remoteConfig_;
    /**
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     * @return Whether the remoteConfig field is set.
     */
    @java.lang.Override
    public boolean hasRemoteConfig() {
      return remoteConfig_ != null;
    }
    /**
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     * @return The remoteConfig.
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentRemoteConfig getRemoteConfig() {
      return remoteConfig_ == null ? opamp.proto.Opamp.AgentRemoteConfig.getDefaultInstance() : remoteConfig_;
    }
    /**
     * <pre>
     * remote_config field is set when the Server has a remote config offer for the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentRemoteConfigOrBuilder getRemoteConfigOrBuilder() {
      return getRemoteConfig();
    }

    public static final int CONNECTION_SETTINGS_FIELD_NUMBER = 4;
    private opamp.proto.Opamp.ConnectionSettingsOffers connectionSettings_;
    /**
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     * @return Whether the connectionSettings field is set.
     */
    @java.lang.Override
    public boolean hasConnectionSettings() {
      return connectionSettings_ != null;
    }
    /**
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     * @return The connectionSettings.
     */
    @java.lang.Override
    public opamp.proto.Opamp.ConnectionSettingsOffers getConnectionSettings() {
      return connectionSettings_ == null ? opamp.proto.Opamp.ConnectionSettingsOffers.getDefaultInstance() : connectionSettings_;
    }
    /**
     * <pre>
     * This field is set when the Server wants the Agent to change one or more
     * of its client connection settings (destination, headers, certificate, etc).
     * </pre>
     *
     * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.ConnectionSettingsOffersOrBuilder getConnectionSettingsOrBuilder() {
      return getConnectionSettings();
    }

    public static final int PACKAGES_AVAILABLE_FIELD_NUMBER = 5;
    private opamp.proto.Opamp.PackagesAvailable packagesAvailable_;
    /**
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     * @return Whether the packagesAvailable field is set.
     */
    @java.lang.Override
    public boolean hasPackagesAvailable() {
      return packagesAvailable_ != null;
    }
    /**
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     * @return The packagesAvailable.
     */
    @java.lang.Override
    public opamp.proto.Opamp.PackagesAvailable getPackagesAvailable() {
      return packagesAvailable_ == null ? opamp.proto.Opamp.PackagesAvailable.getDefaultInstance() : packagesAvailable_;
    }
    /**
     * <pre>
     * This field is set when the Server has packages to offer to the Agent.
     * </pre>
     *
     * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.PackagesAvailableOrBuilder getPackagesAvailableOrBuilder() {
      return getPackagesAvailable();
    }

    public static final int FLAGS_FIELD_NUMBER = 6;
    private long flags_;
    /**
     * <pre>
     * Bit flags as defined by ServerToAgentFlags bit masks.
     * </pre>
     *
     * <code>uint64 flags = 6;</code>
     * @return The flags.
     */
    @java.lang.Override
    public long getFlags() {
      return flags_;
    }

    public static final int CAPABILITIES_FIELD_NUMBER = 7;
    private long capabilities_;
    /**
     * <pre>
     * Bitmask of flags defined by ServerCapabilities enum.
     * All bits that are not defined in ServerCapabilities enum MUST be set to 0
     * by the Server. This allows extending the protocol and the ServerCapabilities
     * enum in the future such that old Servers automatically report that they
     * don't support the new capability.
     * This field MUST be set in the first ServerToAgent sent by the Server and MAY
     * be omitted in subsequent ServerToAgent messages by setting it to
     * UnspecifiedServerCapability value.
     * </pre>
     *
     * <code>uint64 capabilities = 7;</code>
     * @return The capabilities.
     */
    @java.lang.Override
    public long getCapabilities() {
      return capabilities_;
    }

    public static final int AGENT_IDENTIFICATION_FIELD_NUMBER = 8;
    private opamp.proto.Opamp.AgentIdentification agentIdentification_;
    /**
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     * @return Whether the agentIdentification field is set.
     */
    @java.lang.Override
    public boolean hasAgentIdentification() {
      return agentIdentification_ != null;
    }
    /**
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     * @return The agentIdentification.
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentIdentification getAgentIdentification() {
      return agentIdentification_ == null ? opamp.proto.Opamp.AgentIdentification.getDefaultInstance() : agentIdentification_;
    }
    /**
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed.
     * </pre>
     *
     * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentIdentificationOrBuilder getAgentIdentificationOrBuilder() {
      return getAgentIdentification();
    }

    public static final int COMMAND_FIELD_NUMBER = 9;
    private opamp.proto.Opamp.ServerToAgentCommand command_;
    /**
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     * @return Whether the command field is set.
     */
    @java.lang.Override
    public boolean hasCommand() {
      return command_ != null;
    }
    /**
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     * @return The command.
     */
    @java.lang.Override
    public opamp.proto.Opamp.ServerToAgentCommand getCommand() {
      return command_ == null ? opamp.proto.Opamp.ServerToAgentCommand.getDefaultInstance() : command_;
    }
    /**
     * <pre>
     * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
     * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
     * will be performed.
     * </pre>
     *
     * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.ServerToAgentCommandOrBuilder getCommandOrBuilder() {
      return getCommand();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(instanceUid_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, instanceUid_);
      }
      if (errorResponse_ != null) {
        output.writeMessage(2, getErrorResponse());
      }
      if (remoteConfig_ != null) {
        output.writeMessage(3, getRemoteConfig());
      }
      if (connectionSettings_ != null) {
        output.writeMessage(4, getConnectionSettings());
      }
      if (packagesAvailable_ != null) {
        output.writeMessage(5, getPackagesAvailable());
      }
      if (flags_ != 0L) {
        output.writeUInt64(6, flags_);
      }
      if (capabilities_ != 0L) {
        output.writeUInt64(7, capabilities_);
      }
      if (agentIdentification_ != null) {
        output.writeMessage(8, getAgentIdentification());
      }
      if (command_ != null) {
        output.writeMessage(9, getCommand());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(instanceUid_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, instanceUid_);
      }
      if (errorResponse_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getErrorResponse());
      }
      if (remoteConfig_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getRemoteConfig());
      }
      if (connectionSettings_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getConnectionSettings());
      }
      if (packagesAvailable_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getPackagesAvailable());
      }
      if (flags_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(6, flags_);
      }
      if (capabilities_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(7, capabilities_);
      }
      if (agentIdentification_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(8, getAgentIdentification());
      }
      if (command_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(9, getCommand());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.ServerToAgent)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.ServerToAgent other = (opamp.proto.Opamp.ServerToAgent) obj;

      if (!getInstanceUid()
          .equals(other.getInstanceUid())) return false;
      if (hasErrorResponse() != other.hasErrorResponse()) return false;
      if (hasErrorResponse()) {
        if (!getErrorResponse()
            .equals(other.getErrorResponse())) return false;
      }
      if (hasRemoteConfig() != other.hasRemoteConfig()) return false;
      if (hasRemoteConfig()) {
        if (!getRemoteConfig()
            .equals(other.getRemoteConfig())) return false;
      }
      if (hasConnectionSettings() != other.hasConnectionSettings()) return false;
      if (hasConnectionSettings()) {
        if (!getConnectionSettings()
            .equals(other.getConnectionSettings())) return false;
      }
      if (hasPackagesAvailable() != other.hasPackagesAvailable()) return false;
      if (hasPackagesAvailable()) {
        if (!getPackagesAvailable()
            .equals(other.getPackagesAvailable())) return false;
      }
      if (getFlags()
          != other.getFlags()) return false;
      if (getCapabilities()
          != other.getCapabilities()) return false;
      if (hasAgentIdentification() != other.hasAgentIdentification()) return false;
      if (hasAgentIdentification()) {
        if (!getAgentIdentification()
            .equals(other.getAgentIdentification())) return false;
      }
      if (hasCommand() != other.hasCommand()) return false;
      if (hasCommand()) {
        if (!getCommand()
            .equals(other.getCommand())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + INSTANCE_UID_FIELD_NUMBER;
      hash = (53 * hash) + getInstanceUid().hashCode();
      if (hasErrorResponse()) {
        hash = (37 * hash) + ERROR_RESPONSE_FIELD_NUMBER;
        hash = (53 * hash) + getErrorResponse().hashCode();
      }
      if (hasRemoteConfig()) {
        hash = (37 * hash) + REMOTE_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getRemoteConfig().hashCode();
      }
      if (hasConnectionSettings()) {
        hash = (37 * hash) + CONNECTION_SETTINGS_FIELD_NUMBER;
        hash = (53 * hash) + getConnectionSettings().hashCode();
      }
      if (hasPackagesAvailable()) {
        hash = (37 * hash) + PACKAGES_AVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getPackagesAvailable().hashCode();
      }
      hash = (37 * hash) + FLAGS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getFlags());
      hash = (37 * hash) + CAPABILITIES_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getCapabilities());
      if (hasAgentIdentification()) {
        hash = (37 * hash) + AGENT_IDENTIFICATION_FIELD_NUMBER;
        hash = (53 * hash) + getAgentIdentification().hashCode();
      }
      if (hasCommand()) {
        hash = (37 * hash) + COMMAND_FIELD_NUMBER;
        hash = (53 * hash) + getCommand().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.ServerToAgent parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ServerToAgent parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgent parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ServerToAgent parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgent parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ServerToAgent parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgent parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ServerToAgent parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgent parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ServerToAgent parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgent parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ServerToAgent parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.ServerToAgent prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.ServerToAgent}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ServerToAgent)
        opamp.proto.Opamp.ServerToAgentOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgent_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgent_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.ServerToAgent.class, opamp.proto.Opamp.ServerToAgent.Builder.class);
      }

      // Construct using opamp.proto.Opamp.ServerToAgent.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        instanceUid_ = "";

        if (errorResponseBuilder_ == null) {
          errorResponse_ = null;
        } else {
          errorResponse_ = null;
          errorResponseBuilder_ = null;
        }
        if (remoteConfigBuilder_ == null) {
          remoteConfig_ = null;
        } else {
          remoteConfig_ = null;
          remoteConfigBuilder_ = null;
        }
        if (connectionSettingsBuilder_ == null) {
          connectionSettings_ = null;
        } else {
          connectionSettings_ = null;
          connectionSettingsBuilder_ = null;
        }
        if (packagesAvailableBuilder_ == null) {
          packagesAvailable_ = null;
        } else {
          packagesAvailable_ = null;
          packagesAvailableBuilder_ = null;
        }
        flags_ = 0L;

        capabilities_ = 0L;

        if (agentIdentificationBuilder_ == null) {
          agentIdentification_ = null;
        } else {
          agentIdentification_ = null;
          agentIdentificationBuilder_ = null;
        }
        if (commandBuilder_ == null) {
          command_ = null;
        } else {
          command_ = null;
          commandBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgent_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.ServerToAgent getDefaultInstanceForType() {
        return opamp.proto.Opamp.ServerToAgent.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.ServerToAgent build() {
        opamp.proto.Opamp.ServerToAgent result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.ServerToAgent buildPartial() {
        opamp.proto.Opamp.ServerToAgent result = new opamp.proto.Opamp.ServerToAgent(this);
        result.instanceUid_ = instanceUid_;
        if (errorResponseBuilder_ == null) {
          result.errorResponse_ = errorResponse_;
        } else {
          result.errorResponse_ = errorResponseBuilder_.build();
        }
        if (remoteConfigBuilder_ == null) {
          result.remoteConfig_ = remoteConfig_;
        } else {
          result.remoteConfig_ = remoteConfigBuilder_.build();
        }
        if (connectionSettingsBuilder_ == null) {
          result.connectionSettings_ = connectionSettings_;
        } else {
          result.connectionSettings_ = connectionSettingsBuilder_.build();
        }
        if (packagesAvailableBuilder_ == null) {
          result.packagesAvailable_ = packagesAvailable_;
        } else {
          result.packagesAvailable_ = packagesAvailableBuilder_.build();
        }
        result.flags_ = flags_;
        result.capabilities_ = capabilities_;
        if (agentIdentificationBuilder_ == null) {
          result.agentIdentification_ = agentIdentification_;
        } else {
          result.agentIdentification_ = agentIdentificationBuilder_.build();
        }
        if (commandBuilder_ == null) {
          result.command_ = command_;
        } else {
          result.command_ = commandBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.ServerToAgent) {
          return mergeFrom((opamp.proto.Opamp.ServerToAgent)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.ServerToAgent other) {
        if (other == opamp.proto.Opamp.ServerToAgent.getDefaultInstance()) return this;
        if (!other.getInstanceUid().isEmpty()) {
          instanceUid_ = other.instanceUid_;
          onChanged();
        }
        if (other.hasErrorResponse()) {
          mergeErrorResponse(other.getErrorResponse());
        }
        if (other.hasRemoteConfig()) {
          mergeRemoteConfig(other.getRemoteConfig());
        }
        if (other.hasConnectionSettings()) {
          mergeConnectionSettings(other.getConnectionSettings());
        }
        if (other.hasPackagesAvailable()) {
          mergePackagesAvailable(other.getPackagesAvailable());
        }
        if (other.getFlags() != 0L) {
          setFlags(other.getFlags());
        }
        if (other.getCapabilities() != 0L) {
          setCapabilities(other.getCapabilities());
        }
        if (other.hasAgentIdentification()) {
          mergeAgentIdentification(other.getAgentIdentification());
        }
        if (other.hasCommand()) {
          mergeCommand(other.getCommand());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.ServerToAgent parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.ServerToAgent) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object instanceUid_ = "";
      /**
       * <pre>
       * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
       * Used for multiplexing messages from/to multiple agents using one message stream.
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @return The instanceUid.
       */
      public java.lang.String getInstanceUid() {
        java.lang.Object ref = instanceUid_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          instanceUid_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
       * Used for multiplexing messages from/to multiple agents using one message stream.
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @return The bytes for instanceUid.
       */
      public com.google.protobuf.ByteString
          getInstanceUidBytes() {
        java.lang.Object ref = instanceUid_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          instanceUid_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
       * Used for multiplexing messages from/to multiple agents using one message stream.
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @param value The instanceUid to set.
       * @return This builder for chaining.
       */
      public Builder setInstanceUid(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        instanceUid_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
       * Used for multiplexing messages from/to multiple agents using one message stream.
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearInstanceUid() {
        
        instanceUid_ = getDefaultInstance().getInstanceUid();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Agent instance uid. MUST match the instance_uid field in AgentToServer message.
       * Used for multiplexing messages from/to multiple agents using one message stream.
       * </pre>
       *
       * <code>string instance_uid = 1;</code>
       * @param value The bytes for instanceUid to set.
       * @return This builder for chaining.
       */
      public Builder setInstanceUidBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        instanceUid_ = value;
        onChanged();
        return this;
      }

      private opamp.proto.Opamp.ServerErrorResponse errorResponse_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.ServerErrorResponse, opamp.proto.Opamp.ServerErrorResponse.Builder, opamp.proto.Opamp.ServerErrorResponseOrBuilder> errorResponseBuilder_;
      /**
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       * @return Whether the errorResponse field is set.
       */
      public boolean hasErrorResponse() {
        return errorResponseBuilder_ != null || errorResponse_ != null;
      }
      /**
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       * @return The errorResponse.
       */
      public opamp.proto.Opamp.ServerErrorResponse getErrorResponse() {
        if (errorResponseBuilder_ == null) {
          return errorResponse_ == null ? opamp.proto.Opamp.ServerErrorResponse.getDefaultInstance() : errorResponse_;
        } else {
          return errorResponseBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public Builder setErrorResponse(opamp.proto.Opamp.ServerErrorResponse value) {
        if (errorResponseBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          errorResponse_ = value;
          onChanged();
        } else {
          errorResponseBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public Builder setErrorResponse(
          opamp.proto.Opamp.ServerErrorResponse.Builder builderForValue) {
        if (errorResponseBuilder_ == null) {
          errorResponse_ = builderForValue.build();
          onChanged();
        } else {
          errorResponseBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public Builder mergeErrorResponse(opamp.proto.Opamp.ServerErrorResponse value) {
        if (errorResponseBuilder_ == null) {
          if (errorResponse_ != null) {
            errorResponse_ =
              opamp.proto.Opamp.ServerErrorResponse.newBuilder(errorResponse_).mergeFrom(value).buildPartial();
          } else {
            errorResponse_ = value;
          }
          onChanged();
        } else {
          errorResponseBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public Builder clearErrorResponse() {
        if (errorResponseBuilder_ == null) {
          errorResponse_ = null;
          onChanged();
        } else {
          errorResponse_ = null;
          errorResponseBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public opamp.proto.Opamp.ServerErrorResponse.Builder getErrorResponseBuilder() {
        
        onChanged();
        return getErrorResponseFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      public opamp.proto.Opamp.ServerErrorResponseOrBuilder getErrorResponseOrBuilder() {
        if (errorResponseBuilder_ != null) {
          return errorResponseBuilder_.getMessageOrBuilder();
        } else {
          return errorResponse_ == null ?
              opamp.proto.Opamp.ServerErrorResponse.getDefaultInstance() : errorResponse_;
        }
      }
      /**
       * <pre>
       * error_response is set if the Server wants to indicate that something went wrong
       * during processing of an AgentToServer message. If error_response is set then
       * all other fields below must be unset and vice versa, if any of the fields below is
       * set then error_response must be unset.
       * </pre>
       *
       * <code>.opamp.proto.ServerErrorResponse error_response = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.ServerErrorResponse, opamp.proto.Opamp.ServerErrorResponse.Builder, opamp.proto.Opamp.ServerErrorResponseOrBuilder> 
          getErrorResponseFieldBuilder() {
        if (errorResponseBuilder_ == null) {
          errorResponseBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.ServerErrorResponse, opamp.proto.Opamp.ServerErrorResponse.Builder, opamp.proto.Opamp.ServerErrorResponseOrBuilder>(
                  getErrorResponse(),
                  getParentForChildren(),
                  isClean());
          errorResponse_ = null;
        }
        return errorResponseBuilder_;
      }

      private opamp.proto.Opamp.AgentRemoteConfig remoteConfig_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentRemoteConfig, opamp.proto.Opamp.AgentRemoteConfig.Builder, opamp.proto.Opamp.AgentRemoteConfigOrBuilder> remoteConfigBuilder_;
      /**
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       * @return Whether the remoteConfig field is set.
       */
      public boolean hasRemoteConfig() {
        return remoteConfigBuilder_ != null || remoteConfig_ != null;
      }
      /**
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       * @return The remoteConfig.
       */
      public opamp.proto.Opamp.AgentRemoteConfig getRemoteConfig() {
        if (remoteConfigBuilder_ == null) {
          return remoteConfig_ == null ? opamp.proto.Opamp.AgentRemoteConfig.getDefaultInstance() : remoteConfig_;
        } else {
          return remoteConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public Builder setRemoteConfig(opamp.proto.Opamp.AgentRemoteConfig value) {
        if (remoteConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          remoteConfig_ = value;
          onChanged();
        } else {
          remoteConfigBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public Builder setRemoteConfig(
          opamp.proto.Opamp.AgentRemoteConfig.Builder builderForValue) {
        if (remoteConfigBuilder_ == null) {
          remoteConfig_ = builderForValue.build();
          onChanged();
        } else {
          remoteConfigBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public Builder mergeRemoteConfig(opamp.proto.Opamp.AgentRemoteConfig value) {
        if (remoteConfigBuilder_ == null) {
          if (remoteConfig_ != null) {
            remoteConfig_ =
              opamp.proto.Opamp.AgentRemoteConfig.newBuilder(remoteConfig_).mergeFrom(value).buildPartial();
          } else {
            remoteConfig_ = value;
          }
          onChanged();
        } else {
          remoteConfigBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public Builder clearRemoteConfig() {
        if (remoteConfigBuilder_ == null) {
          remoteConfig_ = null;
          onChanged();
        } else {
          remoteConfig_ = null;
          remoteConfigBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public opamp.proto.Opamp.AgentRemoteConfig.Builder getRemoteConfigBuilder() {
        
        onChanged();
        return getRemoteConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      public opamp.proto.Opamp.AgentRemoteConfigOrBuilder getRemoteConfigOrBuilder() {
        if (remoteConfigBuilder_ != null) {
          return remoteConfigBuilder_.getMessageOrBuilder();
        } else {
          return remoteConfig_ == null ?
              opamp.proto.Opamp.AgentRemoteConfig.getDefaultInstance() : remoteConfig_;
        }
      }
      /**
       * <pre>
       * remote_config field is set when the Server has a remote config offer for the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentRemoteConfig remote_config = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentRemoteConfig, opamp.proto.Opamp.AgentRemoteConfig.Builder, opamp.proto.Opamp.AgentRemoteConfigOrBuilder> 
          getRemoteConfigFieldBuilder() {
        if (remoteConfigBuilder_ == null) {
          remoteConfigBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.AgentRemoteConfig, opamp.proto.Opamp.AgentRemoteConfig.Builder, opamp.proto.Opamp.AgentRemoteConfigOrBuilder>(
                  getRemoteConfig(),
                  getParentForChildren(),
                  isClean());
          remoteConfig_ = null;
        }
        return remoteConfigBuilder_;
      }

      private opamp.proto.Opamp.ConnectionSettingsOffers connectionSettings_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.ConnectionSettingsOffers, opamp.proto.Opamp.ConnectionSettingsOffers.Builder, opamp.proto.Opamp.ConnectionSettingsOffersOrBuilder> connectionSettingsBuilder_;
      /**
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       * @return Whether the connectionSettings field is set.
       */
      public boolean hasConnectionSettings() {
        return connectionSettingsBuilder_ != null || connectionSettings_ != null;
      }
      /**
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       * @return The connectionSettings.
       */
      public opamp.proto.Opamp.ConnectionSettingsOffers getConnectionSettings() {
        if (connectionSettingsBuilder_ == null) {
          return connectionSettings_ == null ? opamp.proto.Opamp.ConnectionSettingsOffers.getDefaultInstance() : connectionSettings_;
        } else {
          return connectionSettingsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public Builder setConnectionSettings(opamp.proto.Opamp.ConnectionSettingsOffers value) {
        if (connectionSettingsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          connectionSettings_ = value;
          onChanged();
        } else {
          connectionSettingsBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public Builder setConnectionSettings(
          opamp.proto.Opamp.ConnectionSettingsOffers.Builder builderForValue) {
        if (connectionSettingsBuilder_ == null) {
          connectionSettings_ = builderForValue.build();
          onChanged();
        } else {
          connectionSettingsBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public Builder mergeConnectionSettings(opamp.proto.Opamp.ConnectionSettingsOffers value) {
        if (connectionSettingsBuilder_ == null) {
          if (connectionSettings_ != null) {
            connectionSettings_ =
              opamp.proto.Opamp.ConnectionSettingsOffers.newBuilder(connectionSettings_).mergeFrom(value).buildPartial();
          } else {
            connectionSettings_ = value;
          }
          onChanged();
        } else {
          connectionSettingsBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public Builder clearConnectionSettings() {
        if (connectionSettingsBuilder_ == null) {
          connectionSettings_ = null;
          onChanged();
        } else {
          connectionSettings_ = null;
          connectionSettingsBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public opamp.proto.Opamp.ConnectionSettingsOffers.Builder getConnectionSettingsBuilder() {
        
        onChanged();
        return getConnectionSettingsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      public opamp.proto.Opamp.ConnectionSettingsOffersOrBuilder getConnectionSettingsOrBuilder() {
        if (connectionSettingsBuilder_ != null) {
          return connectionSettingsBuilder_.getMessageOrBuilder();
        } else {
          return connectionSettings_ == null ?
              opamp.proto.Opamp.ConnectionSettingsOffers.getDefaultInstance() : connectionSettings_;
        }
      }
      /**
       * <pre>
       * This field is set when the Server wants the Agent to change one or more
       * of its client connection settings (destination, headers, certificate, etc).
       * </pre>
       *
       * <code>.opamp.proto.ConnectionSettingsOffers connection_settings = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.ConnectionSettingsOffers, opamp.proto.Opamp.ConnectionSettingsOffers.Builder, opamp.proto.Opamp.ConnectionSettingsOffersOrBuilder> 
          getConnectionSettingsFieldBuilder() {
        if (connectionSettingsBuilder_ == null) {
          connectionSettingsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.ConnectionSettingsOffers, opamp.proto.Opamp.ConnectionSettingsOffers.Builder, opamp.proto.Opamp.ConnectionSettingsOffersOrBuilder>(
                  getConnectionSettings(),
                  getParentForChildren(),
                  isClean());
          connectionSettings_ = null;
        }
        return connectionSettingsBuilder_;
      }

      private opamp.proto.Opamp.PackagesAvailable packagesAvailable_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.PackagesAvailable, opamp.proto.Opamp.PackagesAvailable.Builder, opamp.proto.Opamp.PackagesAvailableOrBuilder> packagesAvailableBuilder_;
      /**
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       * @return Whether the packagesAvailable field is set.
       */
      public boolean hasPackagesAvailable() {
        return packagesAvailableBuilder_ != null || packagesAvailable_ != null;
      }
      /**
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       * @return The packagesAvailable.
       */
      public opamp.proto.Opamp.PackagesAvailable getPackagesAvailable() {
        if (packagesAvailableBuilder_ == null) {
          return packagesAvailable_ == null ? opamp.proto.Opamp.PackagesAvailable.getDefaultInstance() : packagesAvailable_;
        } else {
          return packagesAvailableBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public Builder setPackagesAvailable(opamp.proto.Opamp.PackagesAvailable value) {
        if (packagesAvailableBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          packagesAvailable_ = value;
          onChanged();
        } else {
          packagesAvailableBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public Builder setPackagesAvailable(
          opamp.proto.Opamp.PackagesAvailable.Builder builderForValue) {
        if (packagesAvailableBuilder_ == null) {
          packagesAvailable_ = builderForValue.build();
          onChanged();
        } else {
          packagesAvailableBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public Builder mergePackagesAvailable(opamp.proto.Opamp.PackagesAvailable value) {
        if (packagesAvailableBuilder_ == null) {
          if (packagesAvailable_ != null) {
            packagesAvailable_ =
              opamp.proto.Opamp.PackagesAvailable.newBuilder(packagesAvailable_).mergeFrom(value).buildPartial();
          } else {
            packagesAvailable_ = value;
          }
          onChanged();
        } else {
          packagesAvailableBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public Builder clearPackagesAvailable() {
        if (packagesAvailableBuilder_ == null) {
          packagesAvailable_ = null;
          onChanged();
        } else {
          packagesAvailable_ = null;
          packagesAvailableBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public opamp.proto.Opamp.PackagesAvailable.Builder getPackagesAvailableBuilder() {
        
        onChanged();
        return getPackagesAvailableFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      public opamp.proto.Opamp.PackagesAvailableOrBuilder getPackagesAvailableOrBuilder() {
        if (packagesAvailableBuilder_ != null) {
          return packagesAvailableBuilder_.getMessageOrBuilder();
        } else {
          return packagesAvailable_ == null ?
              opamp.proto.Opamp.PackagesAvailable.getDefaultInstance() : packagesAvailable_;
        }
      }
      /**
       * <pre>
       * This field is set when the Server has packages to offer to the Agent.
       * </pre>
       *
       * <code>.opamp.proto.PackagesAvailable packages_available = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.PackagesAvailable, opamp.proto.Opamp.PackagesAvailable.Builder, opamp.proto.Opamp.PackagesAvailableOrBuilder> 
          getPackagesAvailableFieldBuilder() {
        if (packagesAvailableBuilder_ == null) {
          packagesAvailableBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.PackagesAvailable, opamp.proto.Opamp.PackagesAvailable.Builder, opamp.proto.Opamp.PackagesAvailableOrBuilder>(
                  getPackagesAvailable(),
                  getParentForChildren(),
                  isClean());
          packagesAvailable_ = null;
        }
        return packagesAvailableBuilder_;
      }

      private long flags_ ;
      /**
       * <pre>
       * Bit flags as defined by ServerToAgentFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 6;</code>
       * @return The flags.
       */
      @java.lang.Override
      public long getFlags() {
        return flags_;
      }
      /**
       * <pre>
       * Bit flags as defined by ServerToAgentFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 6;</code>
       * @param value The flags to set.
       * @return This builder for chaining.
       */
      public Builder setFlags(long value) {
        
        flags_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Bit flags as defined by ServerToAgentFlags bit masks.
       * </pre>
       *
       * <code>uint64 flags = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearFlags() {
        
        flags_ = 0L;
        onChanged();
        return this;
      }

      private long capabilities_ ;
      /**
       * <pre>
       * Bitmask of flags defined by ServerCapabilities enum.
       * All bits that are not defined in ServerCapabilities enum MUST be set to 0
       * by the Server. This allows extending the protocol and the ServerCapabilities
       * enum in the future such that old Servers automatically report that they
       * don't support the new capability.
       * This field MUST be set in the first ServerToAgent sent by the Server and MAY
       * be omitted in subsequent ServerToAgent messages by setting it to
       * UnspecifiedServerCapability value.
       * </pre>
       *
       * <code>uint64 capabilities = 7;</code>
       * @return The capabilities.
       */
      @java.lang.Override
      public long getCapabilities() {
        return capabilities_;
      }
      /**
       * <pre>
       * Bitmask of flags defined by ServerCapabilities enum.
       * All bits that are not defined in ServerCapabilities enum MUST be set to 0
       * by the Server. This allows extending the protocol and the ServerCapabilities
       * enum in the future such that old Servers automatically report that they
       * don't support the new capability.
       * This field MUST be set in the first ServerToAgent sent by the Server and MAY
       * be omitted in subsequent ServerToAgent messages by setting it to
       * UnspecifiedServerCapability value.
       * </pre>
       *
       * <code>uint64 capabilities = 7;</code>
       * @param value The capabilities to set.
       * @return This builder for chaining.
       */
      public Builder setCapabilities(long value) {
        
        capabilities_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Bitmask of flags defined by ServerCapabilities enum.
       * All bits that are not defined in ServerCapabilities enum MUST be set to 0
       * by the Server. This allows extending the protocol and the ServerCapabilities
       * enum in the future such that old Servers automatically report that they
       * don't support the new capability.
       * This field MUST be set in the first ServerToAgent sent by the Server and MAY
       * be omitted in subsequent ServerToAgent messages by setting it to
       * UnspecifiedServerCapability value.
       * </pre>
       *
       * <code>uint64 capabilities = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearCapabilities() {
        
        capabilities_ = 0L;
        onChanged();
        return this;
      }

      private opamp.proto.Opamp.AgentIdentification agentIdentification_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentIdentification, opamp.proto.Opamp.AgentIdentification.Builder, opamp.proto.Opamp.AgentIdentificationOrBuilder> agentIdentificationBuilder_;
      /**
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       * @return Whether the agentIdentification field is set.
       */
      public boolean hasAgentIdentification() {
        return agentIdentificationBuilder_ != null || agentIdentification_ != null;
      }
      /**
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       * @return The agentIdentification.
       */
      public opamp.proto.Opamp.AgentIdentification getAgentIdentification() {
        if (agentIdentificationBuilder_ == null) {
          return agentIdentification_ == null ? opamp.proto.Opamp.AgentIdentification.getDefaultInstance() : agentIdentification_;
        } else {
          return agentIdentificationBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public Builder setAgentIdentification(opamp.proto.Opamp.AgentIdentification value) {
        if (agentIdentificationBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          agentIdentification_ = value;
          onChanged();
        } else {
          agentIdentificationBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public Builder setAgentIdentification(
          opamp.proto.Opamp.AgentIdentification.Builder builderForValue) {
        if (agentIdentificationBuilder_ == null) {
          agentIdentification_ = builderForValue.build();
          onChanged();
        } else {
          agentIdentificationBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public Builder mergeAgentIdentification(opamp.proto.Opamp.AgentIdentification value) {
        if (agentIdentificationBuilder_ == null) {
          if (agentIdentification_ != null) {
            agentIdentification_ =
              opamp.proto.Opamp.AgentIdentification.newBuilder(agentIdentification_).mergeFrom(value).buildPartial();
          } else {
            agentIdentification_ = value;
          }
          onChanged();
        } else {
          agentIdentificationBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public Builder clearAgentIdentification() {
        if (agentIdentificationBuilder_ == null) {
          agentIdentification_ = null;
          onChanged();
        } else {
          agentIdentification_ = null;
          agentIdentificationBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public opamp.proto.Opamp.AgentIdentification.Builder getAgentIdentificationBuilder() {
        
        onChanged();
        return getAgentIdentificationFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      public opamp.proto.Opamp.AgentIdentificationOrBuilder getAgentIdentificationOrBuilder() {
        if (agentIdentificationBuilder_ != null) {
          return agentIdentificationBuilder_.getMessageOrBuilder();
        } else {
          return agentIdentification_ == null ?
              opamp.proto.Opamp.AgentIdentification.getDefaultInstance() : agentIdentification_;
        }
      }
      /**
       * <pre>
       * Properties related to identification of the Agent, which can be overridden
       * by the Server if needed.
       * </pre>
       *
       * <code>.opamp.proto.AgentIdentification agent_identification = 8;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentIdentification, opamp.proto.Opamp.AgentIdentification.Builder, opamp.proto.Opamp.AgentIdentificationOrBuilder> 
          getAgentIdentificationFieldBuilder() {
        if (agentIdentificationBuilder_ == null) {
          agentIdentificationBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.AgentIdentification, opamp.proto.Opamp.AgentIdentification.Builder, opamp.proto.Opamp.AgentIdentificationOrBuilder>(
                  getAgentIdentification(),
                  getParentForChildren(),
                  isClean());
          agentIdentification_ = null;
        }
        return agentIdentificationBuilder_;
      }

      private opamp.proto.Opamp.ServerToAgentCommand command_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.ServerToAgentCommand, opamp.proto.Opamp.ServerToAgentCommand.Builder, opamp.proto.Opamp.ServerToAgentCommandOrBuilder> commandBuilder_;
      /**
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       * @return Whether the command field is set.
       */
      public boolean hasCommand() {
        return commandBuilder_ != null || command_ != null;
      }
      /**
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       * @return The command.
       */
      public opamp.proto.Opamp.ServerToAgentCommand getCommand() {
        if (commandBuilder_ == null) {
          return command_ == null ? opamp.proto.Opamp.ServerToAgentCommand.getDefaultInstance() : command_;
        } else {
          return commandBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public Builder setCommand(opamp.proto.Opamp.ServerToAgentCommand value) {
        if (commandBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          command_ = value;
          onChanged();
        } else {
          commandBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public Builder setCommand(
          opamp.proto.Opamp.ServerToAgentCommand.Builder builderForValue) {
        if (commandBuilder_ == null) {
          command_ = builderForValue.build();
          onChanged();
        } else {
          commandBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public Builder mergeCommand(opamp.proto.Opamp.ServerToAgentCommand value) {
        if (commandBuilder_ == null) {
          if (command_ != null) {
            command_ =
              opamp.proto.Opamp.ServerToAgentCommand.newBuilder(command_).mergeFrom(value).buildPartial();
          } else {
            command_ = value;
          }
          onChanged();
        } else {
          commandBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public Builder clearCommand() {
        if (commandBuilder_ == null) {
          command_ = null;
          onChanged();
        } else {
          command_ = null;
          commandBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public opamp.proto.Opamp.ServerToAgentCommand.Builder getCommandBuilder() {
        
        onChanged();
        return getCommandFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      public opamp.proto.Opamp.ServerToAgentCommandOrBuilder getCommandOrBuilder() {
        if (commandBuilder_ != null) {
          return commandBuilder_.getMessageOrBuilder();
        } else {
          return command_ == null ?
              opamp.proto.Opamp.ServerToAgentCommand.getDefaultInstance() : command_;
        }
      }
      /**
       * <pre>
       * Allows the Server to instruct the Agent to perform a command, e.g. RESTART. This field should not be specified
       * with fields other than instance_uid and capabilities. If specified, other fields will be ignored and the command
       * will be performed.
       * </pre>
       *
       * <code>.opamp.proto.ServerToAgentCommand command = 9;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.ServerToAgentCommand, opamp.proto.Opamp.ServerToAgentCommand.Builder, opamp.proto.Opamp.ServerToAgentCommandOrBuilder> 
          getCommandFieldBuilder() {
        if (commandBuilder_ == null) {
          commandBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.ServerToAgentCommand, opamp.proto.Opamp.ServerToAgentCommand.Builder, opamp.proto.Opamp.ServerToAgentCommandOrBuilder>(
                  getCommand(),
                  getParentForChildren(),
                  isClean());
          command_ = null;
        }
        return commandBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.ServerToAgent)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ServerToAgent)
    private static final opamp.proto.Opamp.ServerToAgent DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.ServerToAgent();
    }

    public static opamp.proto.Opamp.ServerToAgent getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ServerToAgent>
        PARSER = new com.google.protobuf.AbstractParser<ServerToAgent>() {
      @java.lang.Override
      public ServerToAgent parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ServerToAgent(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ServerToAgent> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ServerToAgent> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.ServerToAgent getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OpAMPConnectionSettingsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.OpAMPConnectionSettings)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
     * example: "wss://example.com:4318/v1/opamp"
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The destinationEndpoint.
     */
    java.lang.String getDestinationEndpoint();
    /**
     * <pre>
     * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
     * example: "wss://example.com:4318/v1/opamp"
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The bytes for destinationEndpoint.
     */
    com.google.protobuf.ByteString
        getDestinationEndpointBytes();

    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return Whether the headers field is set.
     */
    boolean hasHeaders();
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return The headers.
     */
    opamp.proto.Opamp.Headers getHeaders();
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    opamp.proto.Opamp.HeadersOrBuilder getHeadersOrBuilder();

    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return Whether the certificate field is set.
     */
    boolean hasCertificate();
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return The certificate.
     */
    opamp.proto.Opamp.TLSCertificate getCertificate();
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    opamp.proto.Opamp.TLSCertificateOrBuilder getCertificateOrBuilder();
  }
  /**
   * <pre>
   * The OpAMPConnectionSettings message is a collection of fields which comprise an
   * offer from the Server to the Agent to use the specified settings for OpAMP
   * connection.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.OpAMPConnectionSettings}
   */
  public static final class OpAMPConnectionSettings extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.OpAMPConnectionSettings)
      OpAMPConnectionSettingsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use OpAMPConnectionSettings.newBuilder() to construct.
    private OpAMPConnectionSettings(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private OpAMPConnectionSettings() {
      destinationEndpoint_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new OpAMPConnectionSettings();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private OpAMPConnectionSettings(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              destinationEndpoint_ = s;
              break;
            }
            case 18: {
              opamp.proto.Opamp.Headers.Builder subBuilder = null;
              if (headers_ != null) {
                subBuilder = headers_.toBuilder();
              }
              headers_ = input.readMessage(opamp.proto.Opamp.Headers.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(headers_);
                headers_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              opamp.proto.Opamp.TLSCertificate.Builder subBuilder = null;
              if (certificate_ != null) {
                subBuilder = certificate_.toBuilder();
              }
              certificate_ = input.readMessage(opamp.proto.Opamp.TLSCertificate.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(certificate_);
                certificate_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.OpAMPConnectionSettings.class, opamp.proto.Opamp.OpAMPConnectionSettings.Builder.class);
    }

    public static final int DESTINATION_ENDPOINT_FIELD_NUMBER = 1;
    private volatile java.lang.Object destinationEndpoint_;
    /**
     * <pre>
     * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
     * example: "wss://example.com:4318/v1/opamp"
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The destinationEndpoint.
     */
    @java.lang.Override
    public java.lang.String getDestinationEndpoint() {
      java.lang.Object ref = destinationEndpoint_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        destinationEndpoint_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
     * example: "wss://example.com:4318/v1/opamp"
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The bytes for destinationEndpoint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDestinationEndpointBytes() {
      java.lang.Object ref = destinationEndpoint_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        destinationEndpoint_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HEADERS_FIELD_NUMBER = 2;
    private opamp.proto.Opamp.Headers headers_;
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return Whether the headers field is set.
     */
    @java.lang.Override
    public boolean hasHeaders() {
      return headers_ != null;
    }
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return The headers.
     */
    @java.lang.Override
    public opamp.proto.Opamp.Headers getHeaders() {
      return headers_ == null ? opamp.proto.Opamp.Headers.getDefaultInstance() : headers_;
    }
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.HeadersOrBuilder getHeadersOrBuilder() {
      return getHeaders();
    }

    public static final int CERTIFICATE_FIELD_NUMBER = 3;
    private opamp.proto.Opamp.TLSCertificate certificate_;
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return Whether the certificate field is set.
     */
    @java.lang.Override
    public boolean hasCertificate() {
      return certificate_ != null;
    }
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return The certificate.
     */
    @java.lang.Override
    public opamp.proto.Opamp.TLSCertificate getCertificate() {
      return certificate_ == null ? opamp.proto.Opamp.TLSCertificate.getDefaultInstance() : certificate_;
    }
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.TLSCertificateOrBuilder getCertificateOrBuilder() {
      return getCertificate();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, destinationEndpoint_);
      }
      if (headers_ != null) {
        output.writeMessage(2, getHeaders());
      }
      if (certificate_ != null) {
        output.writeMessage(3, getCertificate());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, destinationEndpoint_);
      }
      if (headers_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getHeaders());
      }
      if (certificate_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getCertificate());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.OpAMPConnectionSettings)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.OpAMPConnectionSettings other = (opamp.proto.Opamp.OpAMPConnectionSettings) obj;

      if (!getDestinationEndpoint()
          .equals(other.getDestinationEndpoint())) return false;
      if (hasHeaders() != other.hasHeaders()) return false;
      if (hasHeaders()) {
        if (!getHeaders()
            .equals(other.getHeaders())) return false;
      }
      if (hasCertificate() != other.hasCertificate()) return false;
      if (hasCertificate()) {
        if (!getCertificate()
            .equals(other.getCertificate())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + DESTINATION_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getDestinationEndpoint().hashCode();
      if (hasHeaders()) {
        hash = (37 * hash) + HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getHeaders().hashCode();
      }
      if (hasCertificate()) {
        hash = (37 * hash) + CERTIFICATE_FIELD_NUMBER;
        hash = (53 * hash) + getCertificate().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.OpAMPConnectionSettings parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.OpAMPConnectionSettings prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The OpAMPConnectionSettings message is a collection of fields which comprise an
     * offer from the Server to the Agent to use the specified settings for OpAMP
     * connection.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.OpAMPConnectionSettings}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.OpAMPConnectionSettings)
        opamp.proto.Opamp.OpAMPConnectionSettingsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.OpAMPConnectionSettings.class, opamp.proto.Opamp.OpAMPConnectionSettings.Builder.class);
      }

      // Construct using opamp.proto.Opamp.OpAMPConnectionSettings.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        destinationEndpoint_ = "";

        if (headersBuilder_ == null) {
          headers_ = null;
        } else {
          headers_ = null;
          headersBuilder_ = null;
        }
        if (certificateBuilder_ == null) {
          certificate_ = null;
        } else {
          certificate_ = null;
          certificateBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_OpAMPConnectionSettings_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.OpAMPConnectionSettings getDefaultInstanceForType() {
        return opamp.proto.Opamp.OpAMPConnectionSettings.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.OpAMPConnectionSettings build() {
        opamp.proto.Opamp.OpAMPConnectionSettings result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.OpAMPConnectionSettings buildPartial() {
        opamp.proto.Opamp.OpAMPConnectionSettings result = new opamp.proto.Opamp.OpAMPConnectionSettings(this);
        result.destinationEndpoint_ = destinationEndpoint_;
        if (headersBuilder_ == null) {
          result.headers_ = headers_;
        } else {
          result.headers_ = headersBuilder_.build();
        }
        if (certificateBuilder_ == null) {
          result.certificate_ = certificate_;
        } else {
          result.certificate_ = certificateBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.OpAMPConnectionSettings) {
          return mergeFrom((opamp.proto.Opamp.OpAMPConnectionSettings)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.OpAMPConnectionSettings other) {
        if (other == opamp.proto.Opamp.OpAMPConnectionSettings.getDefaultInstance()) return this;
        if (!other.getDestinationEndpoint().isEmpty()) {
          destinationEndpoint_ = other.destinationEndpoint_;
          onChanged();
        }
        if (other.hasHeaders()) {
          mergeHeaders(other.getHeaders());
        }
        if (other.hasCertificate()) {
          mergeCertificate(other.getCertificate());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.OpAMPConnectionSettings parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.OpAMPConnectionSettings) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object destinationEndpoint_ = "";
      /**
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @return The destinationEndpoint.
       */
      public java.lang.String getDestinationEndpoint() {
        java.lang.Object ref = destinationEndpoint_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          destinationEndpoint_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @return The bytes for destinationEndpoint.
       */
      public com.google.protobuf.ByteString
          getDestinationEndpointBytes() {
        java.lang.Object ref = destinationEndpoint_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          destinationEndpoint_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @param value The destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpoint(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        destinationEndpoint_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDestinationEndpoint() {
        
        destinationEndpoint_ = getDefaultInstance().getDestinationEndpoint();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * OpAMP Server URL This MUST be a WebSocket or HTTP URL and MUST be non-empty, for
       * example: "wss://example.com:4318/v1/opamp"
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @param value The bytes for destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpointBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        destinationEndpoint_ = value;
        onChanged();
        return this;
      }

      private opamp.proto.Opamp.Headers headers_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.Headers, opamp.proto.Opamp.Headers.Builder, opamp.proto.Opamp.HeadersOrBuilder> headersBuilder_;
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       * @return Whether the headers field is set.
       */
      public boolean hasHeaders() {
        return headersBuilder_ != null || headers_ != null;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       * @return The headers.
       */
      public opamp.proto.Opamp.Headers getHeaders() {
        if (headersBuilder_ == null) {
          return headers_ == null ? opamp.proto.Opamp.Headers.getDefaultInstance() : headers_;
        } else {
          return headersBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(opamp.proto.Opamp.Headers value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          headers_ = value;
          onChanged();
        } else {
          headersBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(
          opamp.proto.Opamp.Headers.Builder builderForValue) {
        if (headersBuilder_ == null) {
          headers_ = builderForValue.build();
          onChanged();
        } else {
          headersBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder mergeHeaders(opamp.proto.Opamp.Headers value) {
        if (headersBuilder_ == null) {
          if (headers_ != null) {
            headers_ =
              opamp.proto.Opamp.Headers.newBuilder(headers_).mergeFrom(value).buildPartial();
          } else {
            headers_ = value;
          }
          onChanged();
        } else {
          headersBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder clearHeaders() {
        if (headersBuilder_ == null) {
          headers_ = null;
          onChanged();
        } else {
          headers_ = null;
          headersBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public opamp.proto.Opamp.Headers.Builder getHeadersBuilder() {
        
        onChanged();
        return getHeadersFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public opamp.proto.Opamp.HeadersOrBuilder getHeadersOrBuilder() {
        if (headersBuilder_ != null) {
          return headersBuilder_.getMessageOrBuilder();
        } else {
          return headers_ == null ?
              opamp.proto.Opamp.Headers.getDefaultInstance() : headers_;
        }
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.Headers, opamp.proto.Opamp.Headers.Builder, opamp.proto.Opamp.HeadersOrBuilder> 
          getHeadersFieldBuilder() {
        if (headersBuilder_ == null) {
          headersBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.Headers, opamp.proto.Opamp.Headers.Builder, opamp.proto.Opamp.HeadersOrBuilder>(
                  getHeaders(),
                  getParentForChildren(),
                  isClean());
          headers_ = null;
        }
        return headersBuilder_;
      }

      private opamp.proto.Opamp.TLSCertificate certificate_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TLSCertificate, opamp.proto.Opamp.TLSCertificate.Builder, opamp.proto.Opamp.TLSCertificateOrBuilder> certificateBuilder_;
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       * @return Whether the certificate field is set.
       */
      public boolean hasCertificate() {
        return certificateBuilder_ != null || certificate_ != null;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       * @return The certificate.
       */
      public opamp.proto.Opamp.TLSCertificate getCertificate() {
        if (certificateBuilder_ == null) {
          return certificate_ == null ? opamp.proto.Opamp.TLSCertificate.getDefaultInstance() : certificate_;
        } else {
          return certificateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(opamp.proto.Opamp.TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          certificate_ = value;
          onChanged();
        } else {
          certificateBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(
          opamp.proto.Opamp.TLSCertificate.Builder builderForValue) {
        if (certificateBuilder_ == null) {
          certificate_ = builderForValue.build();
          onChanged();
        } else {
          certificateBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder mergeCertificate(opamp.proto.Opamp.TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (certificate_ != null) {
            certificate_ =
              opamp.proto.Opamp.TLSCertificate.newBuilder(certificate_).mergeFrom(value).buildPartial();
          } else {
            certificate_ = value;
          }
          onChanged();
        } else {
          certificateBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder clearCertificate() {
        if (certificateBuilder_ == null) {
          certificate_ = null;
          onChanged();
        } else {
          certificate_ = null;
          certificateBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public opamp.proto.Opamp.TLSCertificate.Builder getCertificateBuilder() {
        
        onChanged();
        return getCertificateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public opamp.proto.Opamp.TLSCertificateOrBuilder getCertificateOrBuilder() {
        if (certificateBuilder_ != null) {
          return certificateBuilder_.getMessageOrBuilder();
        } else {
          return certificate_ == null ?
              opamp.proto.Opamp.TLSCertificate.getDefaultInstance() : certificate_;
        }
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TLSCertificate, opamp.proto.Opamp.TLSCertificate.Builder, opamp.proto.Opamp.TLSCertificateOrBuilder> 
          getCertificateFieldBuilder() {
        if (certificateBuilder_ == null) {
          certificateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.TLSCertificate, opamp.proto.Opamp.TLSCertificate.Builder, opamp.proto.Opamp.TLSCertificateOrBuilder>(
                  getCertificate(),
                  getParentForChildren(),
                  isClean());
          certificate_ = null;
        }
        return certificateBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.OpAMPConnectionSettings)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.OpAMPConnectionSettings)
    private static final opamp.proto.Opamp.OpAMPConnectionSettings DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.OpAMPConnectionSettings();
    }

    public static opamp.proto.Opamp.OpAMPConnectionSettings getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OpAMPConnectionSettings>
        PARSER = new com.google.protobuf.AbstractParser<OpAMPConnectionSettings>() {
      @java.lang.Override
      public OpAMPConnectionSettings parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new OpAMPConnectionSettings(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<OpAMPConnectionSettings> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OpAMPConnectionSettings> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.OpAMPConnectionSettings getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TelemetryConnectionSettingsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.TelemetryConnectionSettings)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
     * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
     * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The destinationEndpoint.
     */
    java.lang.String getDestinationEndpoint();
    /**
     * <pre>
     * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
     * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
     * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The bytes for destinationEndpoint.
     */
    com.google.protobuf.ByteString
        getDestinationEndpointBytes();

    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return Whether the headers field is set.
     */
    boolean hasHeaders();
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return The headers.
     */
    opamp.proto.Opamp.Headers getHeaders();
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    opamp.proto.Opamp.HeadersOrBuilder getHeadersOrBuilder();

    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return Whether the certificate field is set.
     */
    boolean hasCertificate();
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return The certificate.
     */
    opamp.proto.Opamp.TLSCertificate getCertificate();
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    opamp.proto.Opamp.TLSCertificateOrBuilder getCertificateOrBuilder();
  }
  /**
   * <pre>
   * The TelemetryConnectionSettings message is a collection of fields which comprise an
   * offer from the Server to the Agent to use the specified settings for a network
   * connection to report own telemetry.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.TelemetryConnectionSettings}
   */
  public static final class TelemetryConnectionSettings extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.TelemetryConnectionSettings)
      TelemetryConnectionSettingsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TelemetryConnectionSettings.newBuilder() to construct.
    private TelemetryConnectionSettings(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TelemetryConnectionSettings() {
      destinationEndpoint_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TelemetryConnectionSettings();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TelemetryConnectionSettings(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              destinationEndpoint_ = s;
              break;
            }
            case 18: {
              opamp.proto.Opamp.Headers.Builder subBuilder = null;
              if (headers_ != null) {
                subBuilder = headers_.toBuilder();
              }
              headers_ = input.readMessage(opamp.proto.Opamp.Headers.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(headers_);
                headers_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              opamp.proto.Opamp.TLSCertificate.Builder subBuilder = null;
              if (certificate_ != null) {
                subBuilder = certificate_.toBuilder();
              }
              certificate_ = input.readMessage(opamp.proto.Opamp.TLSCertificate.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(certificate_);
                certificate_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.TelemetryConnectionSettings.class, opamp.proto.Opamp.TelemetryConnectionSettings.Builder.class);
    }

    public static final int DESTINATION_ENDPOINT_FIELD_NUMBER = 1;
    private volatile java.lang.Object destinationEndpoint_;
    /**
     * <pre>
     * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
     * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
     * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The destinationEndpoint.
     */
    @java.lang.Override
    public java.lang.String getDestinationEndpoint() {
      java.lang.Object ref = destinationEndpoint_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        destinationEndpoint_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
     * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
     * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The bytes for destinationEndpoint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDestinationEndpointBytes() {
      java.lang.Object ref = destinationEndpoint_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        destinationEndpoint_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HEADERS_FIELD_NUMBER = 2;
    private opamp.proto.Opamp.Headers headers_;
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return Whether the headers field is set.
     */
    @java.lang.Override
    public boolean hasHeaders() {
      return headers_ != null;
    }
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return The headers.
     */
    @java.lang.Override
    public opamp.proto.Opamp.Headers getHeaders() {
      return headers_ == null ? opamp.proto.Opamp.Headers.getDefaultInstance() : headers_;
    }
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.HeadersOrBuilder getHeadersOrBuilder() {
      return getHeaders();
    }

    public static final int CERTIFICATE_FIELD_NUMBER = 3;
    private opamp.proto.Opamp.TLSCertificate certificate_;
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return Whether the certificate field is set.
     */
    @java.lang.Override
    public boolean hasCertificate() {
      return certificate_ != null;
    }
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return The certificate.
     */
    @java.lang.Override
    public opamp.proto.Opamp.TLSCertificate getCertificate() {
      return certificate_ == null ? opamp.proto.Opamp.TLSCertificate.getDefaultInstance() : certificate_;
    }
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.TLSCertificateOrBuilder getCertificateOrBuilder() {
      return getCertificate();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, destinationEndpoint_);
      }
      if (headers_ != null) {
        output.writeMessage(2, getHeaders());
      }
      if (certificate_ != null) {
        output.writeMessage(3, getCertificate());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, destinationEndpoint_);
      }
      if (headers_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getHeaders());
      }
      if (certificate_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getCertificate());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.TelemetryConnectionSettings)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.TelemetryConnectionSettings other = (opamp.proto.Opamp.TelemetryConnectionSettings) obj;

      if (!getDestinationEndpoint()
          .equals(other.getDestinationEndpoint())) return false;
      if (hasHeaders() != other.hasHeaders()) return false;
      if (hasHeaders()) {
        if (!getHeaders()
            .equals(other.getHeaders())) return false;
      }
      if (hasCertificate() != other.hasCertificate()) return false;
      if (hasCertificate()) {
        if (!getCertificate()
            .equals(other.getCertificate())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + DESTINATION_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getDestinationEndpoint().hashCode();
      if (hasHeaders()) {
        hash = (37 * hash) + HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getHeaders().hashCode();
      }
      if (hasCertificate()) {
        hash = (37 * hash) + CERTIFICATE_FIELD_NUMBER;
        hash = (53 * hash) + getCertificate().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.TelemetryConnectionSettings parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.TelemetryConnectionSettings prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The TelemetryConnectionSettings message is a collection of fields which comprise an
     * offer from the Server to the Agent to use the specified settings for a network
     * connection to report own telemetry.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.TelemetryConnectionSettings}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.TelemetryConnectionSettings)
        opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.TelemetryConnectionSettings.class, opamp.proto.Opamp.TelemetryConnectionSettings.Builder.class);
      }

      // Construct using opamp.proto.Opamp.TelemetryConnectionSettings.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        destinationEndpoint_ = "";

        if (headersBuilder_ == null) {
          headers_ = null;
        } else {
          headers_ = null;
          headersBuilder_ = null;
        }
        if (certificateBuilder_ == null) {
          certificate_ = null;
        } else {
          certificate_ = null;
          certificateBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_TelemetryConnectionSettings_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.TelemetryConnectionSettings getDefaultInstanceForType() {
        return opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.TelemetryConnectionSettings build() {
        opamp.proto.Opamp.TelemetryConnectionSettings result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.TelemetryConnectionSettings buildPartial() {
        opamp.proto.Opamp.TelemetryConnectionSettings result = new opamp.proto.Opamp.TelemetryConnectionSettings(this);
        result.destinationEndpoint_ = destinationEndpoint_;
        if (headersBuilder_ == null) {
          result.headers_ = headers_;
        } else {
          result.headers_ = headersBuilder_.build();
        }
        if (certificateBuilder_ == null) {
          result.certificate_ = certificate_;
        } else {
          result.certificate_ = certificateBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.TelemetryConnectionSettings) {
          return mergeFrom((opamp.proto.Opamp.TelemetryConnectionSettings)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.TelemetryConnectionSettings other) {
        if (other == opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance()) return this;
        if (!other.getDestinationEndpoint().isEmpty()) {
          destinationEndpoint_ = other.destinationEndpoint_;
          onChanged();
        }
        if (other.hasHeaders()) {
          mergeHeaders(other.getHeaders());
        }
        if (other.hasCertificate()) {
          mergeCertificate(other.getCertificate());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.TelemetryConnectionSettings parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.TelemetryConnectionSettings) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object destinationEndpoint_ = "";
      /**
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @return The destinationEndpoint.
       */
      public java.lang.String getDestinationEndpoint() {
        java.lang.Object ref = destinationEndpoint_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          destinationEndpoint_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @return The bytes for destinationEndpoint.
       */
      public com.google.protobuf.ByteString
          getDestinationEndpointBytes() {
        java.lang.Object ref = destinationEndpoint_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          destinationEndpoint_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @param value The destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpoint(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        destinationEndpoint_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDestinationEndpoint() {
        
        destinationEndpoint_ = getDefaultInstance().getDestinationEndpoint();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The value MUST be a full URL an OTLP/HTTP/Protobuf receiver with path. Schema
       * SHOULD begin with "https://", for example "https://example.com:4318/v1/metrics"
       * The Agent MAY refuse to send the telemetry if the URL begins with "http://".
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @param value The bytes for destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpointBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        destinationEndpoint_ = value;
        onChanged();
        return this;
      }

      private opamp.proto.Opamp.Headers headers_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.Headers, opamp.proto.Opamp.Headers.Builder, opamp.proto.Opamp.HeadersOrBuilder> headersBuilder_;
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       * @return Whether the headers field is set.
       */
      public boolean hasHeaders() {
        return headersBuilder_ != null || headers_ != null;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       * @return The headers.
       */
      public opamp.proto.Opamp.Headers getHeaders() {
        if (headersBuilder_ == null) {
          return headers_ == null ? opamp.proto.Opamp.Headers.getDefaultInstance() : headers_;
        } else {
          return headersBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(opamp.proto.Opamp.Headers value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          headers_ = value;
          onChanged();
        } else {
          headersBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(
          opamp.proto.Opamp.Headers.Builder builderForValue) {
        if (headersBuilder_ == null) {
          headers_ = builderForValue.build();
          onChanged();
        } else {
          headersBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder mergeHeaders(opamp.proto.Opamp.Headers value) {
        if (headersBuilder_ == null) {
          if (headers_ != null) {
            headers_ =
              opamp.proto.Opamp.Headers.newBuilder(headers_).mergeFrom(value).buildPartial();
          } else {
            headers_ = value;
          }
          onChanged();
        } else {
          headersBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder clearHeaders() {
        if (headersBuilder_ == null) {
          headers_ = null;
          onChanged();
        } else {
          headers_ = null;
          headersBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public opamp.proto.Opamp.Headers.Builder getHeadersBuilder() {
        
        onChanged();
        return getHeadersFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public opamp.proto.Opamp.HeadersOrBuilder getHeadersOrBuilder() {
        if (headersBuilder_ != null) {
          return headersBuilder_.getMessageOrBuilder();
        } else {
          return headers_ == null ?
              opamp.proto.Opamp.Headers.getDefaultInstance() : headers_;
        }
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.Headers, opamp.proto.Opamp.Headers.Builder, opamp.proto.Opamp.HeadersOrBuilder> 
          getHeadersFieldBuilder() {
        if (headersBuilder_ == null) {
          headersBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.Headers, opamp.proto.Opamp.Headers.Builder, opamp.proto.Opamp.HeadersOrBuilder>(
                  getHeaders(),
                  getParentForChildren(),
                  isClean());
          headers_ = null;
        }
        return headersBuilder_;
      }

      private opamp.proto.Opamp.TLSCertificate certificate_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TLSCertificate, opamp.proto.Opamp.TLSCertificate.Builder, opamp.proto.Opamp.TLSCertificateOrBuilder> certificateBuilder_;
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       * @return Whether the certificate field is set.
       */
      public boolean hasCertificate() {
        return certificateBuilder_ != null || certificate_ != null;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       * @return The certificate.
       */
      public opamp.proto.Opamp.TLSCertificate getCertificate() {
        if (certificateBuilder_ == null) {
          return certificate_ == null ? opamp.proto.Opamp.TLSCertificate.getDefaultInstance() : certificate_;
        } else {
          return certificateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(opamp.proto.Opamp.TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          certificate_ = value;
          onChanged();
        } else {
          certificateBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(
          opamp.proto.Opamp.TLSCertificate.Builder builderForValue) {
        if (certificateBuilder_ == null) {
          certificate_ = builderForValue.build();
          onChanged();
        } else {
          certificateBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder mergeCertificate(opamp.proto.Opamp.TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (certificate_ != null) {
            certificate_ =
              opamp.proto.Opamp.TLSCertificate.newBuilder(certificate_).mergeFrom(value).buildPartial();
          } else {
            certificate_ = value;
          }
          onChanged();
        } else {
          certificateBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder clearCertificate() {
        if (certificateBuilder_ == null) {
          certificate_ = null;
          onChanged();
        } else {
          certificate_ = null;
          certificateBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public opamp.proto.Opamp.TLSCertificate.Builder getCertificateBuilder() {
        
        onChanged();
        return getCertificateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public opamp.proto.Opamp.TLSCertificateOrBuilder getCertificateOrBuilder() {
        if (certificateBuilder_ != null) {
          return certificateBuilder_.getMessageOrBuilder();
        } else {
          return certificate_ == null ?
              opamp.proto.Opamp.TLSCertificate.getDefaultInstance() : certificate_;
        }
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TLSCertificate, opamp.proto.Opamp.TLSCertificate.Builder, opamp.proto.Opamp.TLSCertificateOrBuilder> 
          getCertificateFieldBuilder() {
        if (certificateBuilder_ == null) {
          certificateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.TLSCertificate, opamp.proto.Opamp.TLSCertificate.Builder, opamp.proto.Opamp.TLSCertificateOrBuilder>(
                  getCertificate(),
                  getParentForChildren(),
                  isClean());
          certificate_ = null;
        }
        return certificateBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.TelemetryConnectionSettings)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.TelemetryConnectionSettings)
    private static final opamp.proto.Opamp.TelemetryConnectionSettings DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.TelemetryConnectionSettings();
    }

    public static opamp.proto.Opamp.TelemetryConnectionSettings getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TelemetryConnectionSettings>
        PARSER = new com.google.protobuf.AbstractParser<TelemetryConnectionSettings>() {
      @java.lang.Override
      public TelemetryConnectionSettings parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TelemetryConnectionSettings(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TelemetryConnectionSettings> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TelemetryConnectionSettings> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.TelemetryConnectionSettings getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface OtherConnectionSettingsOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.OtherConnectionSettings)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A URL, host:port or some other destination specifier.
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The destinationEndpoint.
     */
    java.lang.String getDestinationEndpoint();
    /**
     * <pre>
     * A URL, host:port or some other destination specifier.
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The bytes for destinationEndpoint.
     */
    com.google.protobuf.ByteString
        getDestinationEndpointBytes();

    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return Whether the headers field is set.
     */
    boolean hasHeaders();
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return The headers.
     */
    opamp.proto.Opamp.Headers getHeaders();
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    opamp.proto.Opamp.HeadersOrBuilder getHeadersOrBuilder();

    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return Whether the certificate field is set.
     */
    boolean hasCertificate();
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return The certificate.
     */
    opamp.proto.Opamp.TLSCertificate getCertificate();
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    opamp.proto.Opamp.TLSCertificateOrBuilder getCertificateOrBuilder();

    /**
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    int getOtherSettingsCount();
    /**
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    boolean containsOtherSettings(
        java.lang.String key);
    /**
     * Use {@link #getOtherSettingsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, java.lang.String>
    getOtherSettings();
    /**
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    java.util.Map<java.lang.String, java.lang.String>
    getOtherSettingsMap();
    /**
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */

    java.lang.String getOtherSettingsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue);
    /**
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */

    java.lang.String getOtherSettingsOrThrow(
        java.lang.String key);
  }
  /**
   * <pre>
   * The OtherConnectionSettings message is a collection of fields which comprise an
   * offer from the Server to the Agent to use the specified settings for a network
   * connection. It is not required that all fields in this message are specified.
   * The Server may specify only some of the fields, in which case it means that
   * the Server offers the Agent to change only those fields, while keeping the
   * rest of the fields unchanged.
   * For example the Server may send a ConnectionSettings message with only the
   * certificate field set, while all other fields are unset. This means that
   * the Server wants the Agent to use a new certificate and continue sending to
   * the destination it is currently sending using the current header and other
   * settings.
   * For fields which reference other messages the field is considered unset
   * when the reference is unset.
   * For primitive field (string) we rely on the "flags" to describe that the
   * field is not set (this is done to overcome the limitation of old protoc
   * compilers don't generate methods that allow to check for the presence of
   * the field.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.OtherConnectionSettings}
   */
  public static final class OtherConnectionSettings extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.OtherConnectionSettings)
      OtherConnectionSettingsOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use OtherConnectionSettings.newBuilder() to construct.
    private OtherConnectionSettings(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private OtherConnectionSettings() {
      destinationEndpoint_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new OtherConnectionSettings();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private OtherConnectionSettings(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              destinationEndpoint_ = s;
              break;
            }
            case 18: {
              opamp.proto.Opamp.Headers.Builder subBuilder = null;
              if (headers_ != null) {
                subBuilder = headers_.toBuilder();
              }
              headers_ = input.readMessage(opamp.proto.Opamp.Headers.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(headers_);
                headers_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              opamp.proto.Opamp.TLSCertificate.Builder subBuilder = null;
              if (certificate_ != null) {
                subBuilder = certificate_.toBuilder();
              }
              certificate_ = input.readMessage(opamp.proto.Opamp.TLSCertificate.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(certificate_);
                certificate_ = subBuilder.buildPartial();
              }

              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                otherSettings_ = com.google.protobuf.MapField.newMapField(
                    OtherSettingsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
              otherSettings__ = input.readMessage(
                  OtherSettingsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              otherSettings_.getMutableMap().put(
                  otherSettings__.getKey(), otherSettings__.getValue());
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_OtherConnectionSettings_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 4:
          return internalGetOtherSettings();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_OtherConnectionSettings_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.OtherConnectionSettings.class, opamp.proto.Opamp.OtherConnectionSettings.Builder.class);
    }

    public static final int DESTINATION_ENDPOINT_FIELD_NUMBER = 1;
    private volatile java.lang.Object destinationEndpoint_;
    /**
     * <pre>
     * A URL, host:port or some other destination specifier.
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The destinationEndpoint.
     */
    @java.lang.Override
    public java.lang.String getDestinationEndpoint() {
      java.lang.Object ref = destinationEndpoint_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        destinationEndpoint_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A URL, host:port or some other destination specifier.
     * </pre>
     *
     * <code>string destination_endpoint = 1;</code>
     * @return The bytes for destinationEndpoint.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDestinationEndpointBytes() {
      java.lang.Object ref = destinationEndpoint_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        destinationEndpoint_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int HEADERS_FIELD_NUMBER = 2;
    private opamp.proto.Opamp.Headers headers_;
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return Whether the headers field is set.
     */
    @java.lang.Override
    public boolean hasHeaders() {
      return headers_ != null;
    }
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     * @return The headers.
     */
    @java.lang.Override
    public opamp.proto.Opamp.Headers getHeaders() {
      return headers_ == null ? opamp.proto.Opamp.Headers.getDefaultInstance() : headers_;
    }
    /**
     * <pre>
     * Optional headers to use when connecting. Typically used to set access tokens or
     * other authorization headers. For HTTP-based protocols the Agent should
     * set these in the request headers.
     * For example:
     * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
     * </pre>
     *
     * <code>.opamp.proto.Headers headers = 2;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.HeadersOrBuilder getHeadersOrBuilder() {
      return getHeaders();
    }

    public static final int CERTIFICATE_FIELD_NUMBER = 3;
    private opamp.proto.Opamp.TLSCertificate certificate_;
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return Whether the certificate field is set.
     */
    @java.lang.Override
    public boolean hasCertificate() {
      return certificate_ != null;
    }
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     * @return The certificate.
     */
    @java.lang.Override
    public opamp.proto.Opamp.TLSCertificate getCertificate() {
      return certificate_ == null ? opamp.proto.Opamp.TLSCertificate.getDefaultInstance() : certificate_;
    }
    /**
     * <pre>
     * The Agent should use the offered certificate to connect to the destination
     * from now on. If the Agent is able to validate and connect using the offered
     * certificate the Agent SHOULD forget any previous client certificates
     * for this connection.
     * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
     * This field can be used to perform a client certificate revocation/rotation.
     * </pre>
     *
     * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.TLSCertificateOrBuilder getCertificateOrBuilder() {
      return getCertificate();
    }

    public static final int OTHER_SETTINGS_FIELD_NUMBER = 4;
    private static final class OtherSettingsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, java.lang.String> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, java.lang.String>newDefaultInstance(
                  opamp.proto.Opamp.internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        java.lang.String, java.lang.String> otherSettings_;
    private com.google.protobuf.MapField<java.lang.String, java.lang.String>
    internalGetOtherSettings() {
      if (otherSettings_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            OtherSettingsDefaultEntryHolder.defaultEntry);
      }
      return otherSettings_;
    }

    public int getOtherSettingsCount() {
      return internalGetOtherSettings().getMap().size();
    }
    /**
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */

    @java.lang.Override
    public boolean containsOtherSettings(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetOtherSettings().getMap().containsKey(key);
    }
    /**
     * Use {@link #getOtherSettingsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, java.lang.String> getOtherSettings() {
      return getOtherSettingsMap();
    }
    /**
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, java.lang.String> getOtherSettingsMap() {
      return internalGetOtherSettings().getMap();
    }
    /**
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    @java.lang.Override

    public java.lang.String getOtherSettingsOrDefault(
        java.lang.String key,
        java.lang.String defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetOtherSettings().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Other connection settings. These are Agent-specific and are up to the Agent
     * interpret.
     * </pre>
     *
     * <code>map&lt;string, string&gt; other_settings = 4;</code>
     */
    @java.lang.Override

    public java.lang.String getOtherSettingsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, java.lang.String> map =
          internalGetOtherSettings().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, destinationEndpoint_);
      }
      if (headers_ != null) {
        output.writeMessage(2, getHeaders());
      }
      if (certificate_ != null) {
        output.writeMessage(3, getCertificate());
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetOtherSettings(),
          OtherSettingsDefaultEntryHolder.defaultEntry,
          4);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(destinationEndpoint_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, destinationEndpoint_);
      }
      if (headers_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getHeaders());
      }
      if (certificate_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getCertificate());
      }
      for (java.util.Map.Entry<java.lang.String, java.lang.String> entry
           : internalGetOtherSettings().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, java.lang.String>
        otherSettings__ = OtherSettingsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(4, otherSettings__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.OtherConnectionSettings)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.OtherConnectionSettings other = (opamp.proto.Opamp.OtherConnectionSettings) obj;

      if (!getDestinationEndpoint()
          .equals(other.getDestinationEndpoint())) return false;
      if (hasHeaders() != other.hasHeaders()) return false;
      if (hasHeaders()) {
        if (!getHeaders()
            .equals(other.getHeaders())) return false;
      }
      if (hasCertificate() != other.hasCertificate()) return false;
      if (hasCertificate()) {
        if (!getCertificate()
            .equals(other.getCertificate())) return false;
      }
      if (!internalGetOtherSettings().equals(
          other.internalGetOtherSettings())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + DESTINATION_ENDPOINT_FIELD_NUMBER;
      hash = (53 * hash) + getDestinationEndpoint().hashCode();
      if (hasHeaders()) {
        hash = (37 * hash) + HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getHeaders().hashCode();
      }
      if (hasCertificate()) {
        hash = (37 * hash) + CERTIFICATE_FIELD_NUMBER;
        hash = (53 * hash) + getCertificate().hashCode();
      }
      if (!internalGetOtherSettings().getMap().isEmpty()) {
        hash = (37 * hash) + OTHER_SETTINGS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetOtherSettings().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.OtherConnectionSettings parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.OtherConnectionSettings prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The OtherConnectionSettings message is a collection of fields which comprise an
     * offer from the Server to the Agent to use the specified settings for a network
     * connection. It is not required that all fields in this message are specified.
     * The Server may specify only some of the fields, in which case it means that
     * the Server offers the Agent to change only those fields, while keeping the
     * rest of the fields unchanged.
     * For example the Server may send a ConnectionSettings message with only the
     * certificate field set, while all other fields are unset. This means that
     * the Server wants the Agent to use a new certificate and continue sending to
     * the destination it is currently sending using the current header and other
     * settings.
     * For fields which reference other messages the field is considered unset
     * when the reference is unset.
     * For primitive field (string) we rely on the "flags" to describe that the
     * field is not set (this is done to overcome the limitation of old protoc
     * compilers don't generate methods that allow to check for the presence of
     * the field.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.OtherConnectionSettings}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.OtherConnectionSettings)
        opamp.proto.Opamp.OtherConnectionSettingsOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_OtherConnectionSettings_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetOtherSettings();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 4:
            return internalGetMutableOtherSettings();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_OtherConnectionSettings_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.OtherConnectionSettings.class, opamp.proto.Opamp.OtherConnectionSettings.Builder.class);
      }

      // Construct using opamp.proto.Opamp.OtherConnectionSettings.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        destinationEndpoint_ = "";

        if (headersBuilder_ == null) {
          headers_ = null;
        } else {
          headers_ = null;
          headersBuilder_ = null;
        }
        if (certificateBuilder_ == null) {
          certificate_ = null;
        } else {
          certificate_ = null;
          certificateBuilder_ = null;
        }
        internalGetMutableOtherSettings().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_OtherConnectionSettings_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.OtherConnectionSettings getDefaultInstanceForType() {
        return opamp.proto.Opamp.OtherConnectionSettings.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.OtherConnectionSettings build() {
        opamp.proto.Opamp.OtherConnectionSettings result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.OtherConnectionSettings buildPartial() {
        opamp.proto.Opamp.OtherConnectionSettings result = new opamp.proto.Opamp.OtherConnectionSettings(this);
        int from_bitField0_ = bitField0_;
        result.destinationEndpoint_ = destinationEndpoint_;
        if (headersBuilder_ == null) {
          result.headers_ = headers_;
        } else {
          result.headers_ = headersBuilder_.build();
        }
        if (certificateBuilder_ == null) {
          result.certificate_ = certificate_;
        } else {
          result.certificate_ = certificateBuilder_.build();
        }
        result.otherSettings_ = internalGetOtherSettings();
        result.otherSettings_.makeImmutable();
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.OtherConnectionSettings) {
          return mergeFrom((opamp.proto.Opamp.OtherConnectionSettings)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.OtherConnectionSettings other) {
        if (other == opamp.proto.Opamp.OtherConnectionSettings.getDefaultInstance()) return this;
        if (!other.getDestinationEndpoint().isEmpty()) {
          destinationEndpoint_ = other.destinationEndpoint_;
          onChanged();
        }
        if (other.hasHeaders()) {
          mergeHeaders(other.getHeaders());
        }
        if (other.hasCertificate()) {
          mergeCertificate(other.getCertificate());
        }
        internalGetMutableOtherSettings().mergeFrom(
            other.internalGetOtherSettings());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.OtherConnectionSettings parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.OtherConnectionSettings) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object destinationEndpoint_ = "";
      /**
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @return The destinationEndpoint.
       */
      public java.lang.String getDestinationEndpoint() {
        java.lang.Object ref = destinationEndpoint_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          destinationEndpoint_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @return The bytes for destinationEndpoint.
       */
      public com.google.protobuf.ByteString
          getDestinationEndpointBytes() {
        java.lang.Object ref = destinationEndpoint_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          destinationEndpoint_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @param value The destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpoint(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        destinationEndpoint_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDestinationEndpoint() {
        
        destinationEndpoint_ = getDefaultInstance().getDestinationEndpoint();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A URL, host:port or some other destination specifier.
       * </pre>
       *
       * <code>string destination_endpoint = 1;</code>
       * @param value The bytes for destinationEndpoint to set.
       * @return This builder for chaining.
       */
      public Builder setDestinationEndpointBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        destinationEndpoint_ = value;
        onChanged();
        return this;
      }

      private opamp.proto.Opamp.Headers headers_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.Headers, opamp.proto.Opamp.Headers.Builder, opamp.proto.Opamp.HeadersOrBuilder> headersBuilder_;
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       * @return Whether the headers field is set.
       */
      public boolean hasHeaders() {
        return headersBuilder_ != null || headers_ != null;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       * @return The headers.
       */
      public opamp.proto.Opamp.Headers getHeaders() {
        if (headersBuilder_ == null) {
          return headers_ == null ? opamp.proto.Opamp.Headers.getDefaultInstance() : headers_;
        } else {
          return headersBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(opamp.proto.Opamp.Headers value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          headers_ = value;
          onChanged();
        } else {
          headersBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder setHeaders(
          opamp.proto.Opamp.Headers.Builder builderForValue) {
        if (headersBuilder_ == null) {
          headers_ = builderForValue.build();
          onChanged();
        } else {
          headersBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder mergeHeaders(opamp.proto.Opamp.Headers value) {
        if (headersBuilder_ == null) {
          if (headers_ != null) {
            headers_ =
              opamp.proto.Opamp.Headers.newBuilder(headers_).mergeFrom(value).buildPartial();
          } else {
            headers_ = value;
          }
          onChanged();
        } else {
          headersBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public Builder clearHeaders() {
        if (headersBuilder_ == null) {
          headers_ = null;
          onChanged();
        } else {
          headers_ = null;
          headersBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public opamp.proto.Opamp.Headers.Builder getHeadersBuilder() {
        
        onChanged();
        return getHeadersFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      public opamp.proto.Opamp.HeadersOrBuilder getHeadersOrBuilder() {
        if (headersBuilder_ != null) {
          return headersBuilder_.getMessageOrBuilder();
        } else {
          return headers_ == null ?
              opamp.proto.Opamp.Headers.getDefaultInstance() : headers_;
        }
      }
      /**
       * <pre>
       * Optional headers to use when connecting. Typically used to set access tokens or
       * other authorization headers. For HTTP-based protocols the Agent should
       * set these in the request headers.
       * For example:
       * key="Authorization", Value="Basic YWxhZGRpbjpvcGVuc2VzYW1l".
       * </pre>
       *
       * <code>.opamp.proto.Headers headers = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.Headers, opamp.proto.Opamp.Headers.Builder, opamp.proto.Opamp.HeadersOrBuilder> 
          getHeadersFieldBuilder() {
        if (headersBuilder_ == null) {
          headersBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.Headers, opamp.proto.Opamp.Headers.Builder, opamp.proto.Opamp.HeadersOrBuilder>(
                  getHeaders(),
                  getParentForChildren(),
                  isClean());
          headers_ = null;
        }
        return headersBuilder_;
      }

      private opamp.proto.Opamp.TLSCertificate certificate_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TLSCertificate, opamp.proto.Opamp.TLSCertificate.Builder, opamp.proto.Opamp.TLSCertificateOrBuilder> certificateBuilder_;
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       * @return Whether the certificate field is set.
       */
      public boolean hasCertificate() {
        return certificateBuilder_ != null || certificate_ != null;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       * @return The certificate.
       */
      public opamp.proto.Opamp.TLSCertificate getCertificate() {
        if (certificateBuilder_ == null) {
          return certificate_ == null ? opamp.proto.Opamp.TLSCertificate.getDefaultInstance() : certificate_;
        } else {
          return certificateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(opamp.proto.Opamp.TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          certificate_ = value;
          onChanged();
        } else {
          certificateBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder setCertificate(
          opamp.proto.Opamp.TLSCertificate.Builder builderForValue) {
        if (certificateBuilder_ == null) {
          certificate_ = builderForValue.build();
          onChanged();
        } else {
          certificateBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder mergeCertificate(opamp.proto.Opamp.TLSCertificate value) {
        if (certificateBuilder_ == null) {
          if (certificate_ != null) {
            certificate_ =
              opamp.proto.Opamp.TLSCertificate.newBuilder(certificate_).mergeFrom(value).buildPartial();
          } else {
            certificate_ = value;
          }
          onChanged();
        } else {
          certificateBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public Builder clearCertificate() {
        if (certificateBuilder_ == null) {
          certificate_ = null;
          onChanged();
        } else {
          certificate_ = null;
          certificateBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public opamp.proto.Opamp.TLSCertificate.Builder getCertificateBuilder() {
        
        onChanged();
        return getCertificateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      public opamp.proto.Opamp.TLSCertificateOrBuilder getCertificateOrBuilder() {
        if (certificateBuilder_ != null) {
          return certificateBuilder_.getMessageOrBuilder();
        } else {
          return certificate_ == null ?
              opamp.proto.Opamp.TLSCertificate.getDefaultInstance() : certificate_;
        }
      }
      /**
       * <pre>
       * The Agent should use the offered certificate to connect to the destination
       * from now on. If the Agent is able to validate and connect using the offered
       * certificate the Agent SHOULD forget any previous client certificates
       * for this connection.
       * This field is optional: if omitted the client SHOULD NOT use a client-side certificate.
       * This field can be used to perform a client certificate revocation/rotation.
       * </pre>
       *
       * <code>.opamp.proto.TLSCertificate certificate = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TLSCertificate, opamp.proto.Opamp.TLSCertificate.Builder, opamp.proto.Opamp.TLSCertificateOrBuilder> 
          getCertificateFieldBuilder() {
        if (certificateBuilder_ == null) {
          certificateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.TLSCertificate, opamp.proto.Opamp.TLSCertificate.Builder, opamp.proto.Opamp.TLSCertificateOrBuilder>(
                  getCertificate(),
                  getParentForChildren(),
                  isClean());
          certificate_ = null;
        }
        return certificateBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, java.lang.String> otherSettings_;
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetOtherSettings() {
        if (otherSettings_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              OtherSettingsDefaultEntryHolder.defaultEntry);
        }
        return otherSettings_;
      }
      private com.google.protobuf.MapField<java.lang.String, java.lang.String>
      internalGetMutableOtherSettings() {
        onChanged();;
        if (otherSettings_ == null) {
          otherSettings_ = com.google.protobuf.MapField.newMapField(
              OtherSettingsDefaultEntryHolder.defaultEntry);
        }
        if (!otherSettings_.isMutable()) {
          otherSettings_ = otherSettings_.copy();
        }
        return otherSettings_;
      }

      public int getOtherSettingsCount() {
        return internalGetOtherSettings().getMap().size();
      }
      /**
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */

      @java.lang.Override
      public boolean containsOtherSettings(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetOtherSettings().getMap().containsKey(key);
      }
      /**
       * Use {@link #getOtherSettingsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String> getOtherSettings() {
        return getOtherSettingsMap();
      }
      /**
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, java.lang.String> getOtherSettingsMap() {
        return internalGetOtherSettings().getMap();
      }
      /**
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      @java.lang.Override

      public java.lang.String getOtherSettingsOrDefault(
          java.lang.String key,
          java.lang.String defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetOtherSettings().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      @java.lang.Override

      public java.lang.String getOtherSettingsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, java.lang.String> map =
            internalGetOtherSettings().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearOtherSettings() {
        internalGetMutableOtherSettings().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */

      public Builder removeOtherSettings(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableOtherSettings().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, java.lang.String>
      getMutableOtherSettings() {
        return internalGetMutableOtherSettings().getMutableMap();
      }
      /**
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */
      public Builder putOtherSettings(
          java.lang.String key,
          java.lang.String value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) {
  throw new NullPointerException("map value");
}

        internalGetMutableOtherSettings().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Other connection settings. These are Agent-specific and are up to the Agent
       * interpret.
       * </pre>
       *
       * <code>map&lt;string, string&gt; other_settings = 4;</code>
       */

      public Builder putAllOtherSettings(
          java.util.Map<java.lang.String, java.lang.String> values) {
        internalGetMutableOtherSettings().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.OtherConnectionSettings)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.OtherConnectionSettings)
    private static final opamp.proto.Opamp.OtherConnectionSettings DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.OtherConnectionSettings();
    }

    public static opamp.proto.Opamp.OtherConnectionSettings getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<OtherConnectionSettings>
        PARSER = new com.google.protobuf.AbstractParser<OtherConnectionSettings>() {
      @java.lang.Override
      public OtherConnectionSettings parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new OtherConnectionSettings(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<OtherConnectionSettings> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<OtherConnectionSettings> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.OtherConnectionSettings getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface HeadersOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.Headers)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    java.util.List<opamp.proto.Opamp.Header> 
        getHeadersList();
    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    opamp.proto.Opamp.Header getHeaders(int index);
    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    int getHeadersCount();
    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    java.util.List<? extends opamp.proto.Opamp.HeaderOrBuilder> 
        getHeadersOrBuilderList();
    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    opamp.proto.Opamp.HeaderOrBuilder getHeadersOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code opamp.proto.Headers}
   */
  public static final class Headers extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.Headers)
      HeadersOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Headers.newBuilder() to construct.
    private Headers(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Headers() {
      headers_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Headers();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Headers(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                headers_ = new java.util.ArrayList<opamp.proto.Opamp.Header>();
                mutable_bitField0_ |= 0x00000001;
              }
              headers_.add(
                  input.readMessage(opamp.proto.Opamp.Header.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          headers_ = java.util.Collections.unmodifiableList(headers_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_Headers_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_Headers_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.Headers.class, opamp.proto.Opamp.Headers.Builder.class);
    }

    public static final int HEADERS_FIELD_NUMBER = 1;
    private java.util.List<opamp.proto.Opamp.Header> headers_;
    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    @java.lang.Override
    public java.util.List<opamp.proto.Opamp.Header> getHeadersList() {
      return headers_;
    }
    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends opamp.proto.Opamp.HeaderOrBuilder> 
        getHeadersOrBuilderList() {
      return headers_;
    }
    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    @java.lang.Override
    public int getHeadersCount() {
      return headers_.size();
    }
    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.Header getHeaders(int index) {
      return headers_.get(index);
    }
    /**
     * <code>repeated .opamp.proto.Header headers = 1;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.HeaderOrBuilder getHeadersOrBuilder(
        int index) {
      return headers_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < headers_.size(); i++) {
        output.writeMessage(1, headers_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < headers_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, headers_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.Headers)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.Headers other = (opamp.proto.Opamp.Headers) obj;

      if (!getHeadersList()
          .equals(other.getHeadersList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getHeadersCount() > 0) {
        hash = (37 * hash) + HEADERS_FIELD_NUMBER;
        hash = (53 * hash) + getHeadersList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.Headers parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.Headers parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.Headers parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.Headers parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.Headers parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.Headers parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.Headers parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.Headers parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.Headers parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.Headers parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.Headers parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.Headers parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.Headers prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.Headers}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.Headers)
        opamp.proto.Opamp.HeadersOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_Headers_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_Headers_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.Headers.class, opamp.proto.Opamp.Headers.Builder.class);
      }

      // Construct using opamp.proto.Opamp.Headers.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getHeadersFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (headersBuilder_ == null) {
          headers_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          headersBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_Headers_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.Headers getDefaultInstanceForType() {
        return opamp.proto.Opamp.Headers.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.Headers build() {
        opamp.proto.Opamp.Headers result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.Headers buildPartial() {
        opamp.proto.Opamp.Headers result = new opamp.proto.Opamp.Headers(this);
        int from_bitField0_ = bitField0_;
        if (headersBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            headers_ = java.util.Collections.unmodifiableList(headers_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.headers_ = headers_;
        } else {
          result.headers_ = headersBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.Headers) {
          return mergeFrom((opamp.proto.Opamp.Headers)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.Headers other) {
        if (other == opamp.proto.Opamp.Headers.getDefaultInstance()) return this;
        if (headersBuilder_ == null) {
          if (!other.headers_.isEmpty()) {
            if (headers_.isEmpty()) {
              headers_ = other.headers_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureHeadersIsMutable();
              headers_.addAll(other.headers_);
            }
            onChanged();
          }
        } else {
          if (!other.headers_.isEmpty()) {
            if (headersBuilder_.isEmpty()) {
              headersBuilder_.dispose();
              headersBuilder_ = null;
              headers_ = other.headers_;
              bitField0_ = (bitField0_ & ~0x00000001);
              headersBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getHeadersFieldBuilder() : null;
            } else {
              headersBuilder_.addAllMessages(other.headers_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.Headers parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.Headers) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<opamp.proto.Opamp.Header> headers_ =
        java.util.Collections.emptyList();
      private void ensureHeadersIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          headers_ = new java.util.ArrayList<opamp.proto.Opamp.Header>(headers_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          opamp.proto.Opamp.Header, opamp.proto.Opamp.Header.Builder, opamp.proto.Opamp.HeaderOrBuilder> headersBuilder_;

      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public java.util.List<opamp.proto.Opamp.Header> getHeadersList() {
        if (headersBuilder_ == null) {
          return java.util.Collections.unmodifiableList(headers_);
        } else {
          return headersBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public int getHeadersCount() {
        if (headersBuilder_ == null) {
          return headers_.size();
        } else {
          return headersBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public opamp.proto.Opamp.Header getHeaders(int index) {
        if (headersBuilder_ == null) {
          return headers_.get(index);
        } else {
          return headersBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public Builder setHeaders(
          int index, opamp.proto.Opamp.Header value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHeadersIsMutable();
          headers_.set(index, value);
          onChanged();
        } else {
          headersBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public Builder setHeaders(
          int index, opamp.proto.Opamp.Header.Builder builderForValue) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          headers_.set(index, builderForValue.build());
          onChanged();
        } else {
          headersBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public Builder addHeaders(opamp.proto.Opamp.Header value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHeadersIsMutable();
          headers_.add(value);
          onChanged();
        } else {
          headersBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public Builder addHeaders(
          int index, opamp.proto.Opamp.Header value) {
        if (headersBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureHeadersIsMutable();
          headers_.add(index, value);
          onChanged();
        } else {
          headersBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public Builder addHeaders(
          opamp.proto.Opamp.Header.Builder builderForValue) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          headers_.add(builderForValue.build());
          onChanged();
        } else {
          headersBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public Builder addHeaders(
          int index, opamp.proto.Opamp.Header.Builder builderForValue) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          headers_.add(index, builderForValue.build());
          onChanged();
        } else {
          headersBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public Builder addAllHeaders(
          java.lang.Iterable<? extends opamp.proto.Opamp.Header> values) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, headers_);
          onChanged();
        } else {
          headersBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public Builder clearHeaders() {
        if (headersBuilder_ == null) {
          headers_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          headersBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public Builder removeHeaders(int index) {
        if (headersBuilder_ == null) {
          ensureHeadersIsMutable();
          headers_.remove(index);
          onChanged();
        } else {
          headersBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public opamp.proto.Opamp.Header.Builder getHeadersBuilder(
          int index) {
        return getHeadersFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public opamp.proto.Opamp.HeaderOrBuilder getHeadersOrBuilder(
          int index) {
        if (headersBuilder_ == null) {
          return headers_.get(index);  } else {
          return headersBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public java.util.List<? extends opamp.proto.Opamp.HeaderOrBuilder> 
           getHeadersOrBuilderList() {
        if (headersBuilder_ != null) {
          return headersBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(headers_);
        }
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public opamp.proto.Opamp.Header.Builder addHeadersBuilder() {
        return getHeadersFieldBuilder().addBuilder(
            opamp.proto.Opamp.Header.getDefaultInstance());
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public opamp.proto.Opamp.Header.Builder addHeadersBuilder(
          int index) {
        return getHeadersFieldBuilder().addBuilder(
            index, opamp.proto.Opamp.Header.getDefaultInstance());
      }
      /**
       * <code>repeated .opamp.proto.Header headers = 1;</code>
       */
      public java.util.List<opamp.proto.Opamp.Header.Builder> 
           getHeadersBuilderList() {
        return getHeadersFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          opamp.proto.Opamp.Header, opamp.proto.Opamp.Header.Builder, opamp.proto.Opamp.HeaderOrBuilder> 
          getHeadersFieldBuilder() {
        if (headersBuilder_ == null) {
          headersBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              opamp.proto.Opamp.Header, opamp.proto.Opamp.Header.Builder, opamp.proto.Opamp.HeaderOrBuilder>(
                  headers_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          headers_ = null;
        }
        return headersBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.Headers)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.Headers)
    private static final opamp.proto.Opamp.Headers DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.Headers();
    }

    public static opamp.proto.Opamp.Headers getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Headers>
        PARSER = new com.google.protobuf.AbstractParser<Headers>() {
      @java.lang.Override
      public Headers parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Headers(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Headers> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Headers> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.Headers getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface HeaderOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.Header)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>string key = 1;</code>
     * @return The key.
     */
    java.lang.String getKey();
    /**
     * <code>string key = 1;</code>
     * @return The bytes for key.
     */
    com.google.protobuf.ByteString
        getKeyBytes();

    /**
     * <code>string value = 2;</code>
     * @return The value.
     */
    java.lang.String getValue();
    /**
     * <code>string value = 2;</code>
     * @return The bytes for value.
     */
    com.google.protobuf.ByteString
        getValueBytes();
  }
  /**
   * Protobuf type {@code opamp.proto.Header}
   */
  public static final class Header extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.Header)
      HeaderOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Header.newBuilder() to construct.
    private Header(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Header() {
      key_ = "";
      value_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new Header();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Header(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              key_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              value_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_Header_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_Header_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.Header.class, opamp.proto.Opamp.Header.Builder.class);
    }

    public static final int KEY_FIELD_NUMBER = 1;
    private volatile java.lang.Object key_;
    /**
     * <code>string key = 1;</code>
     * @return The key.
     */
    @java.lang.Override
    public java.lang.String getKey() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        key_ = s;
        return s;
      }
    }
    /**
     * <code>string key = 1;</code>
     * @return The bytes for key.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getKeyBytes() {
      java.lang.Object ref = key_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        key_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int VALUE_FIELD_NUMBER = 2;
    private volatile java.lang.Object value_;
    /**
     * <code>string value = 2;</code>
     * @return The value.
     */
    @java.lang.Override
    public java.lang.String getValue() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        value_ = s;
        return s;
      }
    }
    /**
     * <code>string value = 2;</code>
     * @return The bytes for value.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getValueBytes() {
      java.lang.Object ref = value_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        value_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(key_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, key_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(value_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, value_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(key_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, key_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(value_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, value_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.Header)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.Header other = (opamp.proto.Opamp.Header) obj;

      if (!getKey()
          .equals(other.getKey())) return false;
      if (!getValue()
          .equals(other.getValue())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + KEY_FIELD_NUMBER;
      hash = (53 * hash) + getKey().hashCode();
      hash = (37 * hash) + VALUE_FIELD_NUMBER;
      hash = (53 * hash) + getValue().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.Header parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.Header parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.Header parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.Header parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.Header parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.Header parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.Header parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.Header parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.Header parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.Header parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.Header parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.Header parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.Header prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.Header}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.Header)
        opamp.proto.Opamp.HeaderOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_Header_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_Header_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.Header.class, opamp.proto.Opamp.Header.Builder.class);
      }

      // Construct using opamp.proto.Opamp.Header.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        key_ = "";

        value_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_Header_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.Header getDefaultInstanceForType() {
        return opamp.proto.Opamp.Header.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.Header build() {
        opamp.proto.Opamp.Header result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.Header buildPartial() {
        opamp.proto.Opamp.Header result = new opamp.proto.Opamp.Header(this);
        result.key_ = key_;
        result.value_ = value_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.Header) {
          return mergeFrom((opamp.proto.Opamp.Header)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.Header other) {
        if (other == opamp.proto.Opamp.Header.getDefaultInstance()) return this;
        if (!other.getKey().isEmpty()) {
          key_ = other.key_;
          onChanged();
        }
        if (!other.getValue().isEmpty()) {
          value_ = other.value_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.Header parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.Header) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object key_ = "";
      /**
       * <code>string key = 1;</code>
       * @return The key.
       */
      public java.lang.String getKey() {
        java.lang.Object ref = key_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          key_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string key = 1;</code>
       * @return The bytes for key.
       */
      public com.google.protobuf.ByteString
          getKeyBytes() {
        java.lang.Object ref = key_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          key_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string key = 1;</code>
       * @param value The key to set.
       * @return This builder for chaining.
       */
      public Builder setKey(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        key_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearKey() {
        
        key_ = getDefaultInstance().getKey();
        onChanged();
        return this;
      }
      /**
       * <code>string key = 1;</code>
       * @param value The bytes for key to set.
       * @return This builder for chaining.
       */
      public Builder setKeyBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        key_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object value_ = "";
      /**
       * <code>string value = 2;</code>
       * @return The value.
       */
      public java.lang.String getValue() {
        java.lang.Object ref = value_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          value_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <code>string value = 2;</code>
       * @return The bytes for value.
       */
      public com.google.protobuf.ByteString
          getValueBytes() {
        java.lang.Object ref = value_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          value_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string value = 2;</code>
       * @param value The value to set.
       * @return This builder for chaining.
       */
      public Builder setValue(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        value_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string value = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearValue() {
        
        value_ = getDefaultInstance().getValue();
        onChanged();
        return this;
      }
      /**
       * <code>string value = 2;</code>
       * @param value The bytes for value to set.
       * @return This builder for chaining.
       */
      public Builder setValueBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        value_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.Header)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.Header)
    private static final opamp.proto.Opamp.Header DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.Header();
    }

    public static opamp.proto.Opamp.Header getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Header>
        PARSER = new com.google.protobuf.AbstractParser<Header>() {
      @java.lang.Override
      public Header parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Header(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Header> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<Header> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.Header getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TLSCertificateOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.TLSCertificate)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * PEM-encoded public key of the certificate. Required.
     * </pre>
     *
     * <code>bytes public_key = 1;</code>
     * @return The publicKey.
     */
    com.google.protobuf.ByteString getPublicKey();

    /**
     * <pre>
     * PEM-encoded private key of the certificate. Required.
     * </pre>
     *
     * <code>bytes private_key = 2;</code>
     * @return The privateKey.
     */
    com.google.protobuf.ByteString getPrivateKey();

    /**
     * <pre>
     * PEM-encoded public key of the CA that signed this certificate.
     * Optional. MUST be specified if the certificate is CA-signed.
     * Can be stored by TLS-terminating intermediary proxies in order to verify
     * the connecting client's certificate in the future.
     * It is not recommended that the Agent accepts this CA as an authority for
     * any purposes.
     * </pre>
     *
     * <code>bytes ca_public_key = 3;</code>
     * @return The caPublicKey.
     */
    com.google.protobuf.ByteString getCaPublicKey();
  }
  /**
   * <pre>
   * The (public_key,private_key) certificate pair should be issued and
   * signed by a Certificate Authority that the destination Server recognizes.
   * It is highly recommended that the private key of the CA certificate is NOT
   * stored on the destination Server otherwise compromising the Server will allow
   * a malicious actor to issue valid Server certificates which will be automatically
   * trusted by all agents and will allow the actor to trivially MITM Agent-to-Server
   * traffic of all servers that use this CA certificate for their Server-side
   * certificates.
   * Alternatively the certificate may be self-signed, assuming the Server can
   * verify the certificate.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.TLSCertificate}
   */
  public static final class TLSCertificate extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.TLSCertificate)
      TLSCertificateOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use TLSCertificate.newBuilder() to construct.
    private TLSCertificate(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private TLSCertificate() {
      publicKey_ = com.google.protobuf.ByteString.EMPTY;
      privateKey_ = com.google.protobuf.ByteString.EMPTY;
      caPublicKey_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new TLSCertificate();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private TLSCertificate(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {

              publicKey_ = input.readBytes();
              break;
            }
            case 18: {

              privateKey_ = input.readBytes();
              break;
            }
            case 26: {

              caPublicKey_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_TLSCertificate_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_TLSCertificate_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.TLSCertificate.class, opamp.proto.Opamp.TLSCertificate.Builder.class);
    }

    public static final int PUBLIC_KEY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString publicKey_;
    /**
     * <pre>
     * PEM-encoded public key of the certificate. Required.
     * </pre>
     *
     * <code>bytes public_key = 1;</code>
     * @return The publicKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPublicKey() {
      return publicKey_;
    }

    public static final int PRIVATE_KEY_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString privateKey_;
    /**
     * <pre>
     * PEM-encoded private key of the certificate. Required.
     * </pre>
     *
     * <code>bytes private_key = 2;</code>
     * @return The privateKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getPrivateKey() {
      return privateKey_;
    }

    public static final int CA_PUBLIC_KEY_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString caPublicKey_;
    /**
     * <pre>
     * PEM-encoded public key of the CA that signed this certificate.
     * Optional. MUST be specified if the certificate is CA-signed.
     * Can be stored by TLS-terminating intermediary proxies in order to verify
     * the connecting client's certificate in the future.
     * It is not recommended that the Agent accepts this CA as an authority for
     * any purposes.
     * </pre>
     *
     * <code>bytes ca_public_key = 3;</code>
     * @return The caPublicKey.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getCaPublicKey() {
      return caPublicKey_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!publicKey_.isEmpty()) {
        output.writeBytes(1, publicKey_);
      }
      if (!privateKey_.isEmpty()) {
        output.writeBytes(2, privateKey_);
      }
      if (!caPublicKey_.isEmpty()) {
        output.writeBytes(3, caPublicKey_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!publicKey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, publicKey_);
      }
      if (!privateKey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, privateKey_);
      }
      if (!caPublicKey_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, caPublicKey_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.TLSCertificate)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.TLSCertificate other = (opamp.proto.Opamp.TLSCertificate) obj;

      if (!getPublicKey()
          .equals(other.getPublicKey())) return false;
      if (!getPrivateKey()
          .equals(other.getPrivateKey())) return false;
      if (!getCaPublicKey()
          .equals(other.getCaPublicKey())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + PUBLIC_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getPublicKey().hashCode();
      hash = (37 * hash) + PRIVATE_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getPrivateKey().hashCode();
      hash = (37 * hash) + CA_PUBLIC_KEY_FIELD_NUMBER;
      hash = (53 * hash) + getCaPublicKey().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.TLSCertificate parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.TLSCertificate parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.TLSCertificate parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.TLSCertificate parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.TLSCertificate parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.TLSCertificate parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.TLSCertificate parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.TLSCertificate parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.TLSCertificate parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.TLSCertificate parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.TLSCertificate parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.TLSCertificate parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.TLSCertificate prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The (public_key,private_key) certificate pair should be issued and
     * signed by a Certificate Authority that the destination Server recognizes.
     * It is highly recommended that the private key of the CA certificate is NOT
     * stored on the destination Server otherwise compromising the Server will allow
     * a malicious actor to issue valid Server certificates which will be automatically
     * trusted by all agents and will allow the actor to trivially MITM Agent-to-Server
     * traffic of all servers that use this CA certificate for their Server-side
     * certificates.
     * Alternatively the certificate may be self-signed, assuming the Server can
     * verify the certificate.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.TLSCertificate}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.TLSCertificate)
        opamp.proto.Opamp.TLSCertificateOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_TLSCertificate_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_TLSCertificate_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.TLSCertificate.class, opamp.proto.Opamp.TLSCertificate.Builder.class);
      }

      // Construct using opamp.proto.Opamp.TLSCertificate.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        publicKey_ = com.google.protobuf.ByteString.EMPTY;

        privateKey_ = com.google.protobuf.ByteString.EMPTY;

        caPublicKey_ = com.google.protobuf.ByteString.EMPTY;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_TLSCertificate_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.TLSCertificate getDefaultInstanceForType() {
        return opamp.proto.Opamp.TLSCertificate.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.TLSCertificate build() {
        opamp.proto.Opamp.TLSCertificate result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.TLSCertificate buildPartial() {
        opamp.proto.Opamp.TLSCertificate result = new opamp.proto.Opamp.TLSCertificate(this);
        result.publicKey_ = publicKey_;
        result.privateKey_ = privateKey_;
        result.caPublicKey_ = caPublicKey_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.TLSCertificate) {
          return mergeFrom((opamp.proto.Opamp.TLSCertificate)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.TLSCertificate other) {
        if (other == opamp.proto.Opamp.TLSCertificate.getDefaultInstance()) return this;
        if (other.getPublicKey() != com.google.protobuf.ByteString.EMPTY) {
          setPublicKey(other.getPublicKey());
        }
        if (other.getPrivateKey() != com.google.protobuf.ByteString.EMPTY) {
          setPrivateKey(other.getPrivateKey());
        }
        if (other.getCaPublicKey() != com.google.protobuf.ByteString.EMPTY) {
          setCaPublicKey(other.getCaPublicKey());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.TLSCertificate parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.TLSCertificate) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.ByteString publicKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * PEM-encoded public key of the certificate. Required.
       * </pre>
       *
       * <code>bytes public_key = 1;</code>
       * @return The publicKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPublicKey() {
        return publicKey_;
      }
      /**
       * <pre>
       * PEM-encoded public key of the certificate. Required.
       * </pre>
       *
       * <code>bytes public_key = 1;</code>
       * @param value The publicKey to set.
       * @return This builder for chaining.
       */
      public Builder setPublicKey(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        publicKey_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PEM-encoded public key of the certificate. Required.
       * </pre>
       *
       * <code>bytes public_key = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearPublicKey() {
        
        publicKey_ = getDefaultInstance().getPublicKey();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString privateKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * PEM-encoded private key of the certificate. Required.
       * </pre>
       *
       * <code>bytes private_key = 2;</code>
       * @return The privateKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getPrivateKey() {
        return privateKey_;
      }
      /**
       * <pre>
       * PEM-encoded private key of the certificate. Required.
       * </pre>
       *
       * <code>bytes private_key = 2;</code>
       * @param value The privateKey to set.
       * @return This builder for chaining.
       */
      public Builder setPrivateKey(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        privateKey_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PEM-encoded private key of the certificate. Required.
       * </pre>
       *
       * <code>bytes private_key = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearPrivateKey() {
        
        privateKey_ = getDefaultInstance().getPrivateKey();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString caPublicKey_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * PEM-encoded public key of the CA that signed this certificate.
       * Optional. MUST be specified if the certificate is CA-signed.
       * Can be stored by TLS-terminating intermediary proxies in order to verify
       * the connecting client's certificate in the future.
       * It is not recommended that the Agent accepts this CA as an authority for
       * any purposes.
       * </pre>
       *
       * <code>bytes ca_public_key = 3;</code>
       * @return The caPublicKey.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getCaPublicKey() {
        return caPublicKey_;
      }
      /**
       * <pre>
       * PEM-encoded public key of the CA that signed this certificate.
       * Optional. MUST be specified if the certificate is CA-signed.
       * Can be stored by TLS-terminating intermediary proxies in order to verify
       * the connecting client's certificate in the future.
       * It is not recommended that the Agent accepts this CA as an authority for
       * any purposes.
       * </pre>
       *
       * <code>bytes ca_public_key = 3;</code>
       * @param value The caPublicKey to set.
       * @return This builder for chaining.
       */
      public Builder setCaPublicKey(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        caPublicKey_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * PEM-encoded public key of the CA that signed this certificate.
       * Optional. MUST be specified if the certificate is CA-signed.
       * Can be stored by TLS-terminating intermediary proxies in order to verify
       * the connecting client's certificate in the future.
       * It is not recommended that the Agent accepts this CA as an authority for
       * any purposes.
       * </pre>
       *
       * <code>bytes ca_public_key = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearCaPublicKey() {
        
        caPublicKey_ = getDefaultInstance().getCaPublicKey();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.TLSCertificate)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.TLSCertificate)
    private static final opamp.proto.Opamp.TLSCertificate DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.TLSCertificate();
    }

    public static opamp.proto.Opamp.TLSCertificate getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<TLSCertificate>
        PARSER = new com.google.protobuf.AbstractParser<TLSCertificate>() {
      @java.lang.Override
      public TLSCertificate parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new TLSCertificate(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<TLSCertificate> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<TLSCertificate> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.TLSCertificate getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ConnectionSettingsOffersOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ConnectionSettingsOffers)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Hash of all settings, including settings that may be omitted from this message
     * because they are unchanged.
     * </pre>
     *
     * <code>bytes hash = 1;</code>
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();

    /**
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     * @return Whether the opamp field is set.
     */
    boolean hasOpamp();
    /**
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     * @return The opamp.
     */
    opamp.proto.Opamp.OpAMPConnectionSettings getOpamp();
    /**
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     */
    opamp.proto.Opamp.OpAMPConnectionSettingsOrBuilder getOpampOrBuilder();

    /**
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     * @return Whether the ownMetrics field is set.
     */
    boolean hasOwnMetrics();
    /**
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     * @return The ownMetrics.
     */
    opamp.proto.Opamp.TelemetryConnectionSettings getOwnMetrics();
    /**
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     */
    opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder getOwnMetricsOrBuilder();

    /**
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     * @return Whether the ownTraces field is set.
     */
    boolean hasOwnTraces();
    /**
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     * @return The ownTraces.
     */
    opamp.proto.Opamp.TelemetryConnectionSettings getOwnTraces();
    /**
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     */
    opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder getOwnTracesOrBuilder();

    /**
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     * @return Whether the ownLogs field is set.
     */
    boolean hasOwnLogs();
    /**
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     * @return The ownLogs.
     */
    opamp.proto.Opamp.TelemetryConnectionSettings getOwnLogs();
    /**
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     */
    opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder getOwnLogsOrBuilder();

    /**
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    int getOtherConnectionsCount();
    /**
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    boolean containsOtherConnections(
        java.lang.String key);
    /**
     * Use {@link #getOtherConnectionsMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings>
    getOtherConnections();
    /**
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings>
    getOtherConnectionsMap();
    /**
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */

    opamp.proto.Opamp.OtherConnectionSettings getOtherConnectionsOrDefault(
        java.lang.String key,
        opamp.proto.Opamp.OtherConnectionSettings defaultValue);
    /**
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */

    opamp.proto.Opamp.OtherConnectionSettings getOtherConnectionsOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code opamp.proto.ConnectionSettingsOffers}
   */
  public static final class ConnectionSettingsOffers extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ConnectionSettingsOffers)
      ConnectionSettingsOffersOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ConnectionSettingsOffers.newBuilder() to construct.
    private ConnectionSettingsOffers(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ConnectionSettingsOffers() {
      hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ConnectionSettingsOffers();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ConnectionSettingsOffers(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {

              hash_ = input.readBytes();
              break;
            }
            case 18: {
              opamp.proto.Opamp.OpAMPConnectionSettings.Builder subBuilder = null;
              if (opamp_ != null) {
                subBuilder = opamp_.toBuilder();
              }
              opamp_ = input.readMessage(opamp.proto.Opamp.OpAMPConnectionSettings.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(opamp_);
                opamp_ = subBuilder.buildPartial();
              }

              break;
            }
            case 26: {
              opamp.proto.Opamp.TelemetryConnectionSettings.Builder subBuilder = null;
              if (ownMetrics_ != null) {
                subBuilder = ownMetrics_.toBuilder();
              }
              ownMetrics_ = input.readMessage(opamp.proto.Opamp.TelemetryConnectionSettings.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(ownMetrics_);
                ownMetrics_ = subBuilder.buildPartial();
              }

              break;
            }
            case 34: {
              opamp.proto.Opamp.TelemetryConnectionSettings.Builder subBuilder = null;
              if (ownTraces_ != null) {
                subBuilder = ownTraces_.toBuilder();
              }
              ownTraces_ = input.readMessage(opamp.proto.Opamp.TelemetryConnectionSettings.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(ownTraces_);
                ownTraces_ = subBuilder.buildPartial();
              }

              break;
            }
            case 42: {
              opamp.proto.Opamp.TelemetryConnectionSettings.Builder subBuilder = null;
              if (ownLogs_ != null) {
                subBuilder = ownLogs_.toBuilder();
              }
              ownLogs_ = input.readMessage(opamp.proto.Opamp.TelemetryConnectionSettings.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(ownLogs_);
                ownLogs_ = subBuilder.buildPartial();
              }

              break;
            }
            case 50: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                otherConnections_ = com.google.protobuf.MapField.newMapField(
                    OtherConnectionsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings>
              otherConnections__ = input.readMessage(
                  OtherConnectionsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              otherConnections_.getMutableMap().put(
                  otherConnections__.getKey(), otherConnections__.getValue());
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 6:
          return internalGetOtherConnections();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.ConnectionSettingsOffers.class, opamp.proto.Opamp.ConnectionSettingsOffers.Builder.class);
    }

    public static final int HASH_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString hash_;
    /**
     * <pre>
     * Hash of all settings, including settings that may be omitted from this message
     * because they are unchanged.
     * </pre>
     *
     * <code>bytes hash = 1;</code>
     * @return The hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }

    public static final int OPAMP_FIELD_NUMBER = 2;
    private opamp.proto.Opamp.OpAMPConnectionSettings opamp_;
    /**
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     * @return Whether the opamp field is set.
     */
    @java.lang.Override
    public boolean hasOpamp() {
      return opamp_ != null;
    }
    /**
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     * @return The opamp.
     */
    @java.lang.Override
    public opamp.proto.Opamp.OpAMPConnectionSettings getOpamp() {
      return opamp_ == null ? opamp.proto.Opamp.OpAMPConnectionSettings.getDefaultInstance() : opamp_;
    }
    /**
     * <pre>
     * Settings to connect to the OpAMP Server.
     * If this field is not set then the Agent should assume that the settings are
     * unchanged and should continue using existing settings.
     * The Agent MUST verify the offered connection settings by actually connecting
     * before accepting the setting to ensure it does not loose access to the OpAMP
     * Server due to invalid settings.
     * </pre>
     *
     * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.OpAMPConnectionSettingsOrBuilder getOpampOrBuilder() {
      return getOpamp();
    }

    public static final int OWN_METRICS_FIELD_NUMBER = 3;
    private opamp.proto.Opamp.TelemetryConnectionSettings ownMetrics_;
    /**
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     * @return Whether the ownMetrics field is set.
     */
    @java.lang.Override
    public boolean hasOwnMetrics() {
      return ownMetrics_ != null;
    }
    /**
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     * @return The ownMetrics.
     */
    @java.lang.Override
    public opamp.proto.Opamp.TelemetryConnectionSettings getOwnMetrics() {
      return ownMetrics_ == null ? opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance() : ownMetrics_;
    }
    /**
     * <pre>
     * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
     * If this field is not set then the Agent should assume that the settings
     * are unchanged.
     * Once accepted the Agent should periodically send to the specified destination
     * its own metrics, i.e. metrics of the Agent process and any custom metrics that
     * describe the Agent state.
     * All attributes specified in the identifying_attributes field in AgentDescription
     * message SHOULD be also specified in the Resource of the reported OTLP metrics.
     * Attributes specified in the non_identifying_attributes field in
     * AgentDescription message may be also specified in the Resource of the reported
     * OTLP metrics, in which case they SHOULD have exactly the same values.
     * Process metrics MUST follow the conventions for processes:
     * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder getOwnMetricsOrBuilder() {
      return getOwnMetrics();
    }

    public static final int OWN_TRACES_FIELD_NUMBER = 4;
    private opamp.proto.Opamp.TelemetryConnectionSettings ownTraces_;
    /**
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     * @return Whether the ownTraces field is set.
     */
    @java.lang.Override
    public boolean hasOwnTraces() {
      return ownTraces_ != null;
    }
    /**
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     * @return The ownTraces.
     */
    @java.lang.Override
    public opamp.proto.Opamp.TelemetryConnectionSettings getOwnTraces() {
      return ownTraces_ == null ? opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance() : ownTraces_;
    }
    /**
     * <pre>
     * Similar to own_metrics, but for traces.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder getOwnTracesOrBuilder() {
      return getOwnTraces();
    }

    public static final int OWN_LOGS_FIELD_NUMBER = 5;
    private opamp.proto.Opamp.TelemetryConnectionSettings ownLogs_;
    /**
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     * @return Whether the ownLogs field is set.
     */
    @java.lang.Override
    public boolean hasOwnLogs() {
      return ownLogs_ != null;
    }
    /**
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     * @return The ownLogs.
     */
    @java.lang.Override
    public opamp.proto.Opamp.TelemetryConnectionSettings getOwnLogs() {
      return ownLogs_ == null ? opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance() : ownLogs_;
    }
    /**
     * <pre>
     * Similar to own_metrics, but for logs.
     * </pre>
     *
     * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder getOwnLogsOrBuilder() {
      return getOwnLogs();
    }

    public static final int OTHER_CONNECTIONS_FIELD_NUMBER = 6;
    private static final class OtherConnectionsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings>newDefaultInstance(
                  opamp.proto.Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  opamp.proto.Opamp.OtherConnectionSettings.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> otherConnections_;
    private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings>
    internalGetOtherConnections() {
      if (otherConnections_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            OtherConnectionsDefaultEntryHolder.defaultEntry);
      }
      return otherConnections_;
    }

    public int getOtherConnectionsCount() {
      return internalGetOtherConnections().getMap().size();
    }
    /**
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */

    @java.lang.Override
    public boolean containsOtherConnections(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetOtherConnections().getMap().containsKey(key);
    }
    /**
     * Use {@link #getOtherConnectionsMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> getOtherConnections() {
      return getOtherConnectionsMap();
    }
    /**
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> getOtherConnectionsMap() {
      return internalGetOtherConnections().getMap();
    }
    /**
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    @java.lang.Override

    public opamp.proto.Opamp.OtherConnectionSettings getOtherConnectionsOrDefault(
        java.lang.String key,
        opamp.proto.Opamp.OtherConnectionSettings defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> map =
          internalGetOtherConnections().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Another set of connection settings, with a string name associated with each.
     * How the Agent uses these is Agent-specific. Typically the name represents
     * the name of the destination to connect to (as it is known to the Agent).
     * If this field is not set then the Agent should assume that the other_connections
     * settings are unchanged.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
     */
    @java.lang.Override

    public opamp.proto.Opamp.OtherConnectionSettings getOtherConnectionsOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> map =
          internalGetOtherConnections().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!hash_.isEmpty()) {
        output.writeBytes(1, hash_);
      }
      if (opamp_ != null) {
        output.writeMessage(2, getOpamp());
      }
      if (ownMetrics_ != null) {
        output.writeMessage(3, getOwnMetrics());
      }
      if (ownTraces_ != null) {
        output.writeMessage(4, getOwnTraces());
      }
      if (ownLogs_ != null) {
        output.writeMessage(5, getOwnLogs());
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetOtherConnections(),
          OtherConnectionsDefaultEntryHolder.defaultEntry,
          6);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!hash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, hash_);
      }
      if (opamp_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getOpamp());
      }
      if (ownMetrics_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getOwnMetrics());
      }
      if (ownTraces_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, getOwnTraces());
      }
      if (ownLogs_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(5, getOwnLogs());
      }
      for (java.util.Map.Entry<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> entry
           : internalGetOtherConnections().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings>
        otherConnections__ = OtherConnectionsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(6, otherConnections__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.ConnectionSettingsOffers)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.ConnectionSettingsOffers other = (opamp.proto.Opamp.ConnectionSettingsOffers) obj;

      if (!getHash()
          .equals(other.getHash())) return false;
      if (hasOpamp() != other.hasOpamp()) return false;
      if (hasOpamp()) {
        if (!getOpamp()
            .equals(other.getOpamp())) return false;
      }
      if (hasOwnMetrics() != other.hasOwnMetrics()) return false;
      if (hasOwnMetrics()) {
        if (!getOwnMetrics()
            .equals(other.getOwnMetrics())) return false;
      }
      if (hasOwnTraces() != other.hasOwnTraces()) return false;
      if (hasOwnTraces()) {
        if (!getOwnTraces()
            .equals(other.getOwnTraces())) return false;
      }
      if (hasOwnLogs() != other.hasOwnLogs()) return false;
      if (hasOwnLogs()) {
        if (!getOwnLogs()
            .equals(other.getOwnLogs())) return false;
      }
      if (!internalGetOtherConnections().equals(
          other.internalGetOtherConnections())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + HASH_FIELD_NUMBER;
      hash = (53 * hash) + getHash().hashCode();
      if (hasOpamp()) {
        hash = (37 * hash) + OPAMP_FIELD_NUMBER;
        hash = (53 * hash) + getOpamp().hashCode();
      }
      if (hasOwnMetrics()) {
        hash = (37 * hash) + OWN_METRICS_FIELD_NUMBER;
        hash = (53 * hash) + getOwnMetrics().hashCode();
      }
      if (hasOwnTraces()) {
        hash = (37 * hash) + OWN_TRACES_FIELD_NUMBER;
        hash = (53 * hash) + getOwnTraces().hashCode();
      }
      if (hasOwnLogs()) {
        hash = (37 * hash) + OWN_LOGS_FIELD_NUMBER;
        hash = (53 * hash) + getOwnLogs().hashCode();
      }
      if (!internalGetOtherConnections().getMap().isEmpty()) {
        hash = (37 * hash) + OTHER_CONNECTIONS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetOtherConnections().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ConnectionSettingsOffers parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.ConnectionSettingsOffers prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.ConnectionSettingsOffers}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ConnectionSettingsOffers)
        opamp.proto.Opamp.ConnectionSettingsOffersOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 6:
            return internalGetOtherConnections();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 6:
            return internalGetMutableOtherConnections();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.ConnectionSettingsOffers.class, opamp.proto.Opamp.ConnectionSettingsOffers.Builder.class);
      }

      // Construct using opamp.proto.Opamp.ConnectionSettingsOffers.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        hash_ = com.google.protobuf.ByteString.EMPTY;

        if (opampBuilder_ == null) {
          opamp_ = null;
        } else {
          opamp_ = null;
          opampBuilder_ = null;
        }
        if (ownMetricsBuilder_ == null) {
          ownMetrics_ = null;
        } else {
          ownMetrics_ = null;
          ownMetricsBuilder_ = null;
        }
        if (ownTracesBuilder_ == null) {
          ownTraces_ = null;
        } else {
          ownTraces_ = null;
          ownTracesBuilder_ = null;
        }
        if (ownLogsBuilder_ == null) {
          ownLogs_ = null;
        } else {
          ownLogs_ = null;
          ownLogsBuilder_ = null;
        }
        internalGetMutableOtherConnections().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ConnectionSettingsOffers_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.ConnectionSettingsOffers getDefaultInstanceForType() {
        return opamp.proto.Opamp.ConnectionSettingsOffers.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.ConnectionSettingsOffers build() {
        opamp.proto.Opamp.ConnectionSettingsOffers result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.ConnectionSettingsOffers buildPartial() {
        opamp.proto.Opamp.ConnectionSettingsOffers result = new opamp.proto.Opamp.ConnectionSettingsOffers(this);
        int from_bitField0_ = bitField0_;
        result.hash_ = hash_;
        if (opampBuilder_ == null) {
          result.opamp_ = opamp_;
        } else {
          result.opamp_ = opampBuilder_.build();
        }
        if (ownMetricsBuilder_ == null) {
          result.ownMetrics_ = ownMetrics_;
        } else {
          result.ownMetrics_ = ownMetricsBuilder_.build();
        }
        if (ownTracesBuilder_ == null) {
          result.ownTraces_ = ownTraces_;
        } else {
          result.ownTraces_ = ownTracesBuilder_.build();
        }
        if (ownLogsBuilder_ == null) {
          result.ownLogs_ = ownLogs_;
        } else {
          result.ownLogs_ = ownLogsBuilder_.build();
        }
        result.otherConnections_ = internalGetOtherConnections();
        result.otherConnections_.makeImmutable();
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.ConnectionSettingsOffers) {
          return mergeFrom((opamp.proto.Opamp.ConnectionSettingsOffers)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.ConnectionSettingsOffers other) {
        if (other == opamp.proto.Opamp.ConnectionSettingsOffers.getDefaultInstance()) return this;
        if (other.getHash() != com.google.protobuf.ByteString.EMPTY) {
          setHash(other.getHash());
        }
        if (other.hasOpamp()) {
          mergeOpamp(other.getOpamp());
        }
        if (other.hasOwnMetrics()) {
          mergeOwnMetrics(other.getOwnMetrics());
        }
        if (other.hasOwnTraces()) {
          mergeOwnTraces(other.getOwnTraces());
        }
        if (other.hasOwnLogs()) {
          mergeOwnLogs(other.getOwnLogs());
        }
        internalGetMutableOtherConnections().mergeFrom(
            other.internalGetOtherConnections());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.ConnectionSettingsOffers parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.ConnectionSettingsOffers) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Hash of all settings, including settings that may be omitted from this message
       * because they are unchanged.
       * </pre>
       *
       * <code>bytes hash = 1;</code>
       * @return The hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHash() {
        return hash_;
      }
      /**
       * <pre>
       * Hash of all settings, including settings that may be omitted from this message
       * because they are unchanged.
       * </pre>
       *
       * <code>bytes hash = 1;</code>
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        hash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Hash of all settings, including settings that may be omitted from this message
       * because they are unchanged.
       * </pre>
       *
       * <code>bytes hash = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        
        hash_ = getDefaultInstance().getHash();
        onChanged();
        return this;
      }

      private opamp.proto.Opamp.OpAMPConnectionSettings opamp_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.OpAMPConnectionSettings, opamp.proto.Opamp.OpAMPConnectionSettings.Builder, opamp.proto.Opamp.OpAMPConnectionSettingsOrBuilder> opampBuilder_;
      /**
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       * @return Whether the opamp field is set.
       */
      public boolean hasOpamp() {
        return opampBuilder_ != null || opamp_ != null;
      }
      /**
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       * @return The opamp.
       */
      public opamp.proto.Opamp.OpAMPConnectionSettings getOpamp() {
        if (opampBuilder_ == null) {
          return opamp_ == null ? opamp.proto.Opamp.OpAMPConnectionSettings.getDefaultInstance() : opamp_;
        } else {
          return opampBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public Builder setOpamp(opamp.proto.Opamp.OpAMPConnectionSettings value) {
        if (opampBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          opamp_ = value;
          onChanged();
        } else {
          opampBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public Builder setOpamp(
          opamp.proto.Opamp.OpAMPConnectionSettings.Builder builderForValue) {
        if (opampBuilder_ == null) {
          opamp_ = builderForValue.build();
          onChanged();
        } else {
          opampBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public Builder mergeOpamp(opamp.proto.Opamp.OpAMPConnectionSettings value) {
        if (opampBuilder_ == null) {
          if (opamp_ != null) {
            opamp_ =
              opamp.proto.Opamp.OpAMPConnectionSettings.newBuilder(opamp_).mergeFrom(value).buildPartial();
          } else {
            opamp_ = value;
          }
          onChanged();
        } else {
          opampBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public Builder clearOpamp() {
        if (opampBuilder_ == null) {
          opamp_ = null;
          onChanged();
        } else {
          opamp_ = null;
          opampBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public opamp.proto.Opamp.OpAMPConnectionSettings.Builder getOpampBuilder() {
        
        onChanged();
        return getOpampFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      public opamp.proto.Opamp.OpAMPConnectionSettingsOrBuilder getOpampOrBuilder() {
        if (opampBuilder_ != null) {
          return opampBuilder_.getMessageOrBuilder();
        } else {
          return opamp_ == null ?
              opamp.proto.Opamp.OpAMPConnectionSettings.getDefaultInstance() : opamp_;
        }
      }
      /**
       * <pre>
       * Settings to connect to the OpAMP Server.
       * If this field is not set then the Agent should assume that the settings are
       * unchanged and should continue using existing settings.
       * The Agent MUST verify the offered connection settings by actually connecting
       * before accepting the setting to ensure it does not loose access to the OpAMP
       * Server due to invalid settings.
       * </pre>
       *
       * <code>.opamp.proto.OpAMPConnectionSettings opamp = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.OpAMPConnectionSettings, opamp.proto.Opamp.OpAMPConnectionSettings.Builder, opamp.proto.Opamp.OpAMPConnectionSettingsOrBuilder> 
          getOpampFieldBuilder() {
        if (opampBuilder_ == null) {
          opampBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.OpAMPConnectionSettings, opamp.proto.Opamp.OpAMPConnectionSettings.Builder, opamp.proto.Opamp.OpAMPConnectionSettingsOrBuilder>(
                  getOpamp(),
                  getParentForChildren(),
                  isClean());
          opamp_ = null;
        }
        return opampBuilder_;
      }

      private opamp.proto.Opamp.TelemetryConnectionSettings ownMetrics_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TelemetryConnectionSettings, opamp.proto.Opamp.TelemetryConnectionSettings.Builder, opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder> ownMetricsBuilder_;
      /**
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       * @return Whether the ownMetrics field is set.
       */
      public boolean hasOwnMetrics() {
        return ownMetricsBuilder_ != null || ownMetrics_ != null;
      }
      /**
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       * @return The ownMetrics.
       */
      public opamp.proto.Opamp.TelemetryConnectionSettings getOwnMetrics() {
        if (ownMetricsBuilder_ == null) {
          return ownMetrics_ == null ? opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance() : ownMetrics_;
        } else {
          return ownMetricsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public Builder setOwnMetrics(opamp.proto.Opamp.TelemetryConnectionSettings value) {
        if (ownMetricsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ownMetrics_ = value;
          onChanged();
        } else {
          ownMetricsBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public Builder setOwnMetrics(
          opamp.proto.Opamp.TelemetryConnectionSettings.Builder builderForValue) {
        if (ownMetricsBuilder_ == null) {
          ownMetrics_ = builderForValue.build();
          onChanged();
        } else {
          ownMetricsBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public Builder mergeOwnMetrics(opamp.proto.Opamp.TelemetryConnectionSettings value) {
        if (ownMetricsBuilder_ == null) {
          if (ownMetrics_ != null) {
            ownMetrics_ =
              opamp.proto.Opamp.TelemetryConnectionSettings.newBuilder(ownMetrics_).mergeFrom(value).buildPartial();
          } else {
            ownMetrics_ = value;
          }
          onChanged();
        } else {
          ownMetricsBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public Builder clearOwnMetrics() {
        if (ownMetricsBuilder_ == null) {
          ownMetrics_ = null;
          onChanged();
        } else {
          ownMetrics_ = null;
          ownMetricsBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public opamp.proto.Opamp.TelemetryConnectionSettings.Builder getOwnMetricsBuilder() {
        
        onChanged();
        return getOwnMetricsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      public opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder getOwnMetricsOrBuilder() {
        if (ownMetricsBuilder_ != null) {
          return ownMetricsBuilder_.getMessageOrBuilder();
        } else {
          return ownMetrics_ == null ?
              opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance() : ownMetrics_;
        }
      }
      /**
       * <pre>
       * Settings to connect to an OTLP metrics backend to send Agent's own metrics to.
       * If this field is not set then the Agent should assume that the settings
       * are unchanged.
       * Once accepted the Agent should periodically send to the specified destination
       * its own metrics, i.e. metrics of the Agent process and any custom metrics that
       * describe the Agent state.
       * All attributes specified in the identifying_attributes field in AgentDescription
       * message SHOULD be also specified in the Resource of the reported OTLP metrics.
       * Attributes specified in the non_identifying_attributes field in
       * AgentDescription message may be also specified in the Resource of the reported
       * OTLP metrics, in which case they SHOULD have exactly the same values.
       * Process metrics MUST follow the conventions for processes:
       * https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/semantic_conventions/process-metrics.md
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_metrics = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TelemetryConnectionSettings, opamp.proto.Opamp.TelemetryConnectionSettings.Builder, opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder> 
          getOwnMetricsFieldBuilder() {
        if (ownMetricsBuilder_ == null) {
          ownMetricsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.TelemetryConnectionSettings, opamp.proto.Opamp.TelemetryConnectionSettings.Builder, opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder>(
                  getOwnMetrics(),
                  getParentForChildren(),
                  isClean());
          ownMetrics_ = null;
        }
        return ownMetricsBuilder_;
      }

      private opamp.proto.Opamp.TelemetryConnectionSettings ownTraces_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TelemetryConnectionSettings, opamp.proto.Opamp.TelemetryConnectionSettings.Builder, opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder> ownTracesBuilder_;
      /**
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       * @return Whether the ownTraces field is set.
       */
      public boolean hasOwnTraces() {
        return ownTracesBuilder_ != null || ownTraces_ != null;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       * @return The ownTraces.
       */
      public opamp.proto.Opamp.TelemetryConnectionSettings getOwnTraces() {
        if (ownTracesBuilder_ == null) {
          return ownTraces_ == null ? opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance() : ownTraces_;
        } else {
          return ownTracesBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public Builder setOwnTraces(opamp.proto.Opamp.TelemetryConnectionSettings value) {
        if (ownTracesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ownTraces_ = value;
          onChanged();
        } else {
          ownTracesBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public Builder setOwnTraces(
          opamp.proto.Opamp.TelemetryConnectionSettings.Builder builderForValue) {
        if (ownTracesBuilder_ == null) {
          ownTraces_ = builderForValue.build();
          onChanged();
        } else {
          ownTracesBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public Builder mergeOwnTraces(opamp.proto.Opamp.TelemetryConnectionSettings value) {
        if (ownTracesBuilder_ == null) {
          if (ownTraces_ != null) {
            ownTraces_ =
              opamp.proto.Opamp.TelemetryConnectionSettings.newBuilder(ownTraces_).mergeFrom(value).buildPartial();
          } else {
            ownTraces_ = value;
          }
          onChanged();
        } else {
          ownTracesBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public Builder clearOwnTraces() {
        if (ownTracesBuilder_ == null) {
          ownTraces_ = null;
          onChanged();
        } else {
          ownTraces_ = null;
          ownTracesBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public opamp.proto.Opamp.TelemetryConnectionSettings.Builder getOwnTracesBuilder() {
        
        onChanged();
        return getOwnTracesFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      public opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder getOwnTracesOrBuilder() {
        if (ownTracesBuilder_ != null) {
          return ownTracesBuilder_.getMessageOrBuilder();
        } else {
          return ownTraces_ == null ?
              opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance() : ownTraces_;
        }
      }
      /**
       * <pre>
       * Similar to own_metrics, but for traces.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_traces = 4;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TelemetryConnectionSettings, opamp.proto.Opamp.TelemetryConnectionSettings.Builder, opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder> 
          getOwnTracesFieldBuilder() {
        if (ownTracesBuilder_ == null) {
          ownTracesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.TelemetryConnectionSettings, opamp.proto.Opamp.TelemetryConnectionSettings.Builder, opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder>(
                  getOwnTraces(),
                  getParentForChildren(),
                  isClean());
          ownTraces_ = null;
        }
        return ownTracesBuilder_;
      }

      private opamp.proto.Opamp.TelemetryConnectionSettings ownLogs_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TelemetryConnectionSettings, opamp.proto.Opamp.TelemetryConnectionSettings.Builder, opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder> ownLogsBuilder_;
      /**
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       * @return Whether the ownLogs field is set.
       */
      public boolean hasOwnLogs() {
        return ownLogsBuilder_ != null || ownLogs_ != null;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       * @return The ownLogs.
       */
      public opamp.proto.Opamp.TelemetryConnectionSettings getOwnLogs() {
        if (ownLogsBuilder_ == null) {
          return ownLogs_ == null ? opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance() : ownLogs_;
        } else {
          return ownLogsBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public Builder setOwnLogs(opamp.proto.Opamp.TelemetryConnectionSettings value) {
        if (ownLogsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ownLogs_ = value;
          onChanged();
        } else {
          ownLogsBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public Builder setOwnLogs(
          opamp.proto.Opamp.TelemetryConnectionSettings.Builder builderForValue) {
        if (ownLogsBuilder_ == null) {
          ownLogs_ = builderForValue.build();
          onChanged();
        } else {
          ownLogsBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public Builder mergeOwnLogs(opamp.proto.Opamp.TelemetryConnectionSettings value) {
        if (ownLogsBuilder_ == null) {
          if (ownLogs_ != null) {
            ownLogs_ =
              opamp.proto.Opamp.TelemetryConnectionSettings.newBuilder(ownLogs_).mergeFrom(value).buildPartial();
          } else {
            ownLogs_ = value;
          }
          onChanged();
        } else {
          ownLogsBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public Builder clearOwnLogs() {
        if (ownLogsBuilder_ == null) {
          ownLogs_ = null;
          onChanged();
        } else {
          ownLogs_ = null;
          ownLogsBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public opamp.proto.Opamp.TelemetryConnectionSettings.Builder getOwnLogsBuilder() {
        
        onChanged();
        return getOwnLogsFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      public opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder getOwnLogsOrBuilder() {
        if (ownLogsBuilder_ != null) {
          return ownLogsBuilder_.getMessageOrBuilder();
        } else {
          return ownLogs_ == null ?
              opamp.proto.Opamp.TelemetryConnectionSettings.getDefaultInstance() : ownLogs_;
        }
      }
      /**
       * <pre>
       * Similar to own_metrics, but for logs.
       * </pre>
       *
       * <code>.opamp.proto.TelemetryConnectionSettings own_logs = 5;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.TelemetryConnectionSettings, opamp.proto.Opamp.TelemetryConnectionSettings.Builder, opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder> 
          getOwnLogsFieldBuilder() {
        if (ownLogsBuilder_ == null) {
          ownLogsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.TelemetryConnectionSettings, opamp.proto.Opamp.TelemetryConnectionSettings.Builder, opamp.proto.Opamp.TelemetryConnectionSettingsOrBuilder>(
                  getOwnLogs(),
                  getParentForChildren(),
                  isClean());
          ownLogs_ = null;
        }
        return ownLogsBuilder_;
      }

      private com.google.protobuf.MapField<
          java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> otherConnections_;
      private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings>
      internalGetOtherConnections() {
        if (otherConnections_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              OtherConnectionsDefaultEntryHolder.defaultEntry);
        }
        return otherConnections_;
      }
      private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings>
      internalGetMutableOtherConnections() {
        onChanged();;
        if (otherConnections_ == null) {
          otherConnections_ = com.google.protobuf.MapField.newMapField(
              OtherConnectionsDefaultEntryHolder.defaultEntry);
        }
        if (!otherConnections_.isMutable()) {
          otherConnections_ = otherConnections_.copy();
        }
        return otherConnections_;
      }

      public int getOtherConnectionsCount() {
        return internalGetOtherConnections().getMap().size();
      }
      /**
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */

      @java.lang.Override
      public boolean containsOtherConnections(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetOtherConnections().getMap().containsKey(key);
      }
      /**
       * Use {@link #getOtherConnectionsMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> getOtherConnections() {
        return getOtherConnectionsMap();
      }
      /**
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> getOtherConnectionsMap() {
        return internalGetOtherConnections().getMap();
      }
      /**
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      @java.lang.Override

      public opamp.proto.Opamp.OtherConnectionSettings getOtherConnectionsOrDefault(
          java.lang.String key,
          opamp.proto.Opamp.OtherConnectionSettings defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> map =
            internalGetOtherConnections().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      @java.lang.Override

      public opamp.proto.Opamp.OtherConnectionSettings getOtherConnectionsOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> map =
            internalGetOtherConnections().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearOtherConnections() {
        internalGetMutableOtherConnections().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */

      public Builder removeOtherConnections(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableOtherConnections().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings>
      getMutableOtherConnections() {
        return internalGetMutableOtherConnections().getMutableMap();
      }
      /**
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */
      public Builder putOtherConnections(
          java.lang.String key,
          opamp.proto.Opamp.OtherConnectionSettings value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) {
  throw new NullPointerException("map value");
}

        internalGetMutableOtherConnections().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Another set of connection settings, with a string name associated with each.
       * How the Agent uses these is Agent-specific. Typically the name represents
       * the name of the destination to connect to (as it is known to the Agent).
       * If this field is not set then the Agent should assume that the other_connections
       * settings are unchanged.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.OtherConnectionSettings&gt; other_connections = 6;</code>
       */

      public Builder putAllOtherConnections(
          java.util.Map<java.lang.String, opamp.proto.Opamp.OtherConnectionSettings> values) {
        internalGetMutableOtherConnections().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.ConnectionSettingsOffers)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ConnectionSettingsOffers)
    private static final opamp.proto.Opamp.ConnectionSettingsOffers DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.ConnectionSettingsOffers();
    }

    public static opamp.proto.Opamp.ConnectionSettingsOffers getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ConnectionSettingsOffers>
        PARSER = new com.google.protobuf.AbstractParser<ConnectionSettingsOffers>() {
      @java.lang.Override
      public ConnectionSettingsOffers parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ConnectionSettingsOffers(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ConnectionSettingsOffers> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ConnectionSettingsOffers> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.ConnectionSettingsOffers getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PackagesAvailableOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.PackagesAvailable)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    int getPackagesCount();
    /**
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    boolean containsPackages(
        java.lang.String key);
    /**
     * Use {@link #getPackagesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable>
    getPackages();
    /**
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable>
    getPackagesMap();
    /**
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */

    opamp.proto.Opamp.PackageAvailable getPackagesOrDefault(
        java.lang.String key,
        opamp.proto.Opamp.PackageAvailable defaultValue);
    /**
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */

    opamp.proto.Opamp.PackageAvailable getPackagesOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
     * value in subsequent PackageStatuses messages. This in turn allows the management
     * Server to identify that a different set of packages is available for the Agent
     * and specify the available packages in the next ServerToAgent message.
     * This field MUST be always set if the management Server supports packages
     * of agents.
     * The hash is calculated as an aggregate of all packages names and content.
     * </pre>
     *
     * <code>bytes all_packages_hash = 2;</code>
     * @return The allPackagesHash.
     */
    com.google.protobuf.ByteString getAllPackagesHash();
  }
  /**
   * <pre>
   * List of packages that the Server offers to the Agent.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.PackagesAvailable}
   */
  public static final class PackagesAvailable extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.PackagesAvailable)
      PackagesAvailableOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PackagesAvailable.newBuilder() to construct.
    private PackagesAvailable(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PackagesAvailable() {
      allPackagesHash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PackagesAvailable();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PackagesAvailable(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                packages_ = com.google.protobuf.MapField.newMapField(
                    PackagesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.String, opamp.proto.Opamp.PackageAvailable>
              packages__ = input.readMessage(
                  PackagesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              packages_.getMutableMap().put(
                  packages__.getKey(), packages__.getValue());
              break;
            }
            case 18: {

              allPackagesHash_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_PackagesAvailable_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetPackages();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_PackagesAvailable_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.PackagesAvailable.class, opamp.proto.Opamp.PackagesAvailable.Builder.class);
    }

    public static final int PACKAGES_FIELD_NUMBER = 1;
    private static final class PackagesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, opamp.proto.Opamp.PackageAvailable> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, opamp.proto.Opamp.PackageAvailable>newDefaultInstance(
                  opamp.proto.Opamp.internal_static_opamp_proto_PackagesAvailable_PackagesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  opamp.proto.Opamp.PackageAvailable.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.String, opamp.proto.Opamp.PackageAvailable> packages_;
    private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.PackageAvailable>
    internalGetPackages() {
      if (packages_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PackagesDefaultEntryHolder.defaultEntry);
      }
      return packages_;
    }

    public int getPackagesCount() {
      return internalGetPackages().getMap().size();
    }
    /**
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */

    @java.lang.Override
    public boolean containsPackages(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetPackages().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPackagesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable> getPackages() {
      return getPackagesMap();
    }
    /**
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable> getPackagesMap() {
      return internalGetPackages().getMap();
    }
    /**
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    @java.lang.Override

    public opamp.proto.Opamp.PackageAvailable getPackagesOrDefault(
        java.lang.String key,
        opamp.proto.Opamp.PackageAvailable defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable> map =
          internalGetPackages().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Map of packages. Keys are package names, values are the packages available for download.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
     */
    @java.lang.Override

    public opamp.proto.Opamp.PackageAvailable getPackagesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable> map =
          internalGetPackages().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int ALL_PACKAGES_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString allPackagesHash_;
    /**
     * <pre>
     * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
     * value in subsequent PackageStatuses messages. This in turn allows the management
     * Server to identify that a different set of packages is available for the Agent
     * and specify the available packages in the next ServerToAgent message.
     * This field MUST be always set if the management Server supports packages
     * of agents.
     * The hash is calculated as an aggregate of all packages names and content.
     * </pre>
     *
     * <code>bytes all_packages_hash = 2;</code>
     * @return The allPackagesHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getAllPackagesHash() {
      return allPackagesHash_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPackages(),
          PackagesDefaultEntryHolder.defaultEntry,
          1);
      if (!allPackagesHash_.isEmpty()) {
        output.writeBytes(2, allPackagesHash_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, opamp.proto.Opamp.PackageAvailable> entry
           : internalGetPackages().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, opamp.proto.Opamp.PackageAvailable>
        packages__ = PackagesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, packages__);
      }
      if (!allPackagesHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, allPackagesHash_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.PackagesAvailable)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.PackagesAvailable other = (opamp.proto.Opamp.PackagesAvailable) obj;

      if (!internalGetPackages().equals(
          other.internalGetPackages())) return false;
      if (!getAllPackagesHash()
          .equals(other.getAllPackagesHash())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetPackages().getMap().isEmpty()) {
        hash = (37 * hash) + PACKAGES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPackages().hashCode();
      }
      hash = (37 * hash) + ALL_PACKAGES_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getAllPackagesHash().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.PackagesAvailable parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackagesAvailable parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.PackagesAvailable prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * List of packages that the Server offers to the Agent.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.PackagesAvailable}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.PackagesAvailable)
        opamp.proto.Opamp.PackagesAvailableOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackagesAvailable_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetPackages();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutablePackages();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackagesAvailable_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.PackagesAvailable.class, opamp.proto.Opamp.PackagesAvailable.Builder.class);
      }

      // Construct using opamp.proto.Opamp.PackagesAvailable.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        internalGetMutablePackages().clear();
        allPackagesHash_ = com.google.protobuf.ByteString.EMPTY;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackagesAvailable_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackagesAvailable getDefaultInstanceForType() {
        return opamp.proto.Opamp.PackagesAvailable.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackagesAvailable build() {
        opamp.proto.Opamp.PackagesAvailable result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackagesAvailable buildPartial() {
        opamp.proto.Opamp.PackagesAvailable result = new opamp.proto.Opamp.PackagesAvailable(this);
        int from_bitField0_ = bitField0_;
        result.packages_ = internalGetPackages();
        result.packages_.makeImmutable();
        result.allPackagesHash_ = allPackagesHash_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.PackagesAvailable) {
          return mergeFrom((opamp.proto.Opamp.PackagesAvailable)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.PackagesAvailable other) {
        if (other == opamp.proto.Opamp.PackagesAvailable.getDefaultInstance()) return this;
        internalGetMutablePackages().mergeFrom(
            other.internalGetPackages());
        if (other.getAllPackagesHash() != com.google.protobuf.ByteString.EMPTY) {
          setAllPackagesHash(other.getAllPackagesHash());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.PackagesAvailable parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.PackagesAvailable) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.String, opamp.proto.Opamp.PackageAvailable> packages_;
      private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.PackageAvailable>
      internalGetPackages() {
        if (packages_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PackagesDefaultEntryHolder.defaultEntry);
        }
        return packages_;
      }
      private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.PackageAvailable>
      internalGetMutablePackages() {
        onChanged();;
        if (packages_ == null) {
          packages_ = com.google.protobuf.MapField.newMapField(
              PackagesDefaultEntryHolder.defaultEntry);
        }
        if (!packages_.isMutable()) {
          packages_ = packages_.copy();
        }
        return packages_;
      }

      public int getPackagesCount() {
        return internalGetPackages().getMap().size();
      }
      /**
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */

      @java.lang.Override
      public boolean containsPackages(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetPackages().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPackagesMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable> getPackages() {
        return getPackagesMap();
      }
      /**
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable> getPackagesMap() {
        return internalGetPackages().getMap();
      }
      /**
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      @java.lang.Override

      public opamp.proto.Opamp.PackageAvailable getPackagesOrDefault(
          java.lang.String key,
          opamp.proto.Opamp.PackageAvailable defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable> map =
            internalGetPackages().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      @java.lang.Override

      public opamp.proto.Opamp.PackageAvailable getPackagesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable> map =
            internalGetPackages().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPackages() {
        internalGetMutablePackages().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */

      public Builder removePackages(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutablePackages().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable>
      getMutablePackages() {
        return internalGetMutablePackages().getMutableMap();
      }
      /**
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */
      public Builder putPackages(
          java.lang.String key,
          opamp.proto.Opamp.PackageAvailable value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) {
  throw new NullPointerException("map value");
}

        internalGetMutablePackages().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Map of packages. Keys are package names, values are the packages available for download.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageAvailable&gt; packages = 1;</code>
       */

      public Builder putAllPackages(
          java.util.Map<java.lang.String, opamp.proto.Opamp.PackageAvailable> values) {
        internalGetMutablePackages().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.ByteString allPackagesHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
       * value in subsequent PackageStatuses messages. This in turn allows the management
       * Server to identify that a different set of packages is available for the Agent
       * and specify the available packages in the next ServerToAgent message.
       * This field MUST be always set if the management Server supports packages
       * of agents.
       * The hash is calculated as an aggregate of all packages names and content.
       * </pre>
       *
       * <code>bytes all_packages_hash = 2;</code>
       * @return The allPackagesHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getAllPackagesHash() {
        return allPackagesHash_;
      }
      /**
       * <pre>
       * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
       * value in subsequent PackageStatuses messages. This in turn allows the management
       * Server to identify that a different set of packages is available for the Agent
       * and specify the available packages in the next ServerToAgent message.
       * This field MUST be always set if the management Server supports packages
       * of agents.
       * The hash is calculated as an aggregate of all packages names and content.
       * </pre>
       *
       * <code>bytes all_packages_hash = 2;</code>
       * @param value The allPackagesHash to set.
       * @return This builder for chaining.
       */
      public Builder setAllPackagesHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        allPackagesHash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Aggregate hash of all remotely installed packages. The Agent SHOULD include this
       * value in subsequent PackageStatuses messages. This in turn allows the management
       * Server to identify that a different set of packages is available for the Agent
       * and specify the available packages in the next ServerToAgent message.
       * This field MUST be always set if the management Server supports packages
       * of agents.
       * The hash is calculated as an aggregate of all packages names and content.
       * </pre>
       *
       * <code>bytes all_packages_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAllPackagesHash() {
        
        allPackagesHash_ = getDefaultInstance().getAllPackagesHash();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.PackagesAvailable)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.PackagesAvailable)
    private static final opamp.proto.Opamp.PackagesAvailable DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.PackagesAvailable();
    }

    public static opamp.proto.Opamp.PackagesAvailable getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackagesAvailable>
        PARSER = new com.google.protobuf.AbstractParser<PackagesAvailable>() {
      @java.lang.Override
      public PackagesAvailable parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PackagesAvailable(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PackagesAvailable> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PackagesAvailable> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.PackagesAvailable getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PackageAvailableOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.PackageAvailable)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.opamp.proto.PackageType type = 1;</code>
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();
    /**
     * <code>.opamp.proto.PackageType type = 1;</code>
     * @return The type.
     */
    opamp.proto.Opamp.PackageType getType();

    /**
     * <pre>
     * The package version that is available on the Server side. The Agent may for
     * example use this information to avoid downloading a package that was previously
     * already downloaded and failed to install.
     * </pre>
     *
     * <code>string version = 2;</code>
     * @return The version.
     */
    java.lang.String getVersion();
    /**
     * <pre>
     * The package version that is available on the Server side. The Agent may for
     * example use this information to avoid downloading a package that was previously
     * already downloaded and failed to install.
     * </pre>
     *
     * <code>string version = 2;</code>
     * @return The bytes for version.
     */
    com.google.protobuf.ByteString
        getVersionBytes();

    /**
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     * @return Whether the file field is set.
     */
    boolean hasFile();
    /**
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     * @return The file.
     */
    opamp.proto.Opamp.DownloadableFile getFile();
    /**
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     */
    opamp.proto.Opamp.DownloadableFileOrBuilder getFileOrBuilder();

    /**
     * <pre>
     * The hash of the package. SHOULD be calculated based on all other fields of the
     * PackageAvailable message and content of the file of the package. The hash is
     * used by the Agent to determine if the package it has is different from the
     * package the Server is offering.
     * </pre>
     *
     * <code>bytes hash = 4;</code>
     * @return The hash.
     */
    com.google.protobuf.ByteString getHash();
  }
  /**
   * <pre>
   * Each Agent is composed of one or more packages. A package has a name and
   * content stored in a file. The content of the files, functionality
   * provided by the packages, how they are stored and used by the Agent side is Agent
   * type-specific and is outside the concerns of the OpAMP protocol.
   * If the Agent does not have an installed package with the specified name then
   * it SHOULD download it from the specified URL and install it.
   * If the Agent already has an installed package with the specified name
   * but with a different hash then the Agent SHOULD download and
   * install the package again, since it is a different version of the same package.
   * If the Agent has an installed package with the specified name and the same
   * hash then the Agent does not need to do anything, it already
   * has the right version of the package.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.PackageAvailable}
   */
  public static final class PackageAvailable extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.PackageAvailable)
      PackageAvailableOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PackageAvailable.newBuilder() to construct.
    private PackageAvailable(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PackageAvailable() {
      type_ = 0;
      version_ = "";
      hash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PackageAvailable();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PackageAvailable(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();

              type_ = rawValue;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              version_ = s;
              break;
            }
            case 26: {
              opamp.proto.Opamp.DownloadableFile.Builder subBuilder = null;
              if (file_ != null) {
                subBuilder = file_.toBuilder();
              }
              file_ = input.readMessage(opamp.proto.Opamp.DownloadableFile.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(file_);
                file_ = subBuilder.buildPartial();
              }

              break;
            }
            case 34: {

              hash_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_PackageAvailable_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_PackageAvailable_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.PackageAvailable.class, opamp.proto.Opamp.PackageAvailable.Builder.class);
    }

    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>.opamp.proto.PackageType type = 1;</code>
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override public int getTypeValue() {
      return type_;
    }
    /**
     * <code>.opamp.proto.PackageType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public opamp.proto.Opamp.PackageType getType() {
      @SuppressWarnings("deprecation")
      opamp.proto.Opamp.PackageType result = opamp.proto.Opamp.PackageType.valueOf(type_);
      return result == null ? opamp.proto.Opamp.PackageType.UNRECOGNIZED : result;
    }

    public static final int VERSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object version_;
    /**
     * <pre>
     * The package version that is available on the Server side. The Agent may for
     * example use this information to avoid downloading a package that was previously
     * already downloaded and failed to install.
     * </pre>
     *
     * <code>string version = 2;</code>
     * @return The version.
     */
    @java.lang.Override
    public java.lang.String getVersion() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        version_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The package version that is available on the Server side. The Agent may for
     * example use this information to avoid downloading a package that was previously
     * already downloaded and failed to install.
     * </pre>
     *
     * <code>string version = 2;</code>
     * @return The bytes for version.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getVersionBytes() {
      java.lang.Object ref = version_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        version_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FILE_FIELD_NUMBER = 3;
    private opamp.proto.Opamp.DownloadableFile file_;
    /**
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     * @return Whether the file field is set.
     */
    @java.lang.Override
    public boolean hasFile() {
      return file_ != null;
    }
    /**
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     * @return The file.
     */
    @java.lang.Override
    public opamp.proto.Opamp.DownloadableFile getFile() {
      return file_ == null ? opamp.proto.Opamp.DownloadableFile.getDefaultInstance() : file_;
    }
    /**
     * <pre>
     * The downloadable file of the package.
     * </pre>
     *
     * <code>.opamp.proto.DownloadableFile file = 3;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.DownloadableFileOrBuilder getFileOrBuilder() {
      return getFile();
    }

    public static final int HASH_FIELD_NUMBER = 4;
    private com.google.protobuf.ByteString hash_;
    /**
     * <pre>
     * The hash of the package. SHOULD be calculated based on all other fields of the
     * PackageAvailable message and content of the file of the package. The hash is
     * used by the Agent to determine if the package it has is different from the
     * package the Server is offering.
     * </pre>
     *
     * <code>bytes hash = 4;</code>
     * @return The hash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getHash() {
      return hash_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (type_ != opamp.proto.Opamp.PackageType.PackageType_TopLevel.getNumber()) {
        output.writeEnum(1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(version_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, version_);
      }
      if (file_ != null) {
        output.writeMessage(3, getFile());
      }
      if (!hash_.isEmpty()) {
        output.writeBytes(4, hash_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (type_ != opamp.proto.Opamp.PackageType.PackageType_TopLevel.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(version_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, version_);
      }
      if (file_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getFile());
      }
      if (!hash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(4, hash_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.PackageAvailable)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.PackageAvailable other = (opamp.proto.Opamp.PackageAvailable) obj;

      if (type_ != other.type_) return false;
      if (!getVersion()
          .equals(other.getVersion())) return false;
      if (hasFile() != other.hasFile()) return false;
      if (hasFile()) {
        if (!getFile()
            .equals(other.getFile())) return false;
      }
      if (!getHash()
          .equals(other.getHash())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (37 * hash) + VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getVersion().hashCode();
      if (hasFile()) {
        hash = (37 * hash) + FILE_FIELD_NUMBER;
        hash = (53 * hash) + getFile().hashCode();
      }
      hash = (37 * hash) + HASH_FIELD_NUMBER;
      hash = (53 * hash) + getHash().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.PackageAvailable parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackageAvailable parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageAvailable parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackageAvailable parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageAvailable parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackageAvailable parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageAvailable parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackageAvailable parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageAvailable parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackageAvailable parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageAvailable parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackageAvailable parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.PackageAvailable prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Each Agent is composed of one or more packages. A package has a name and
     * content stored in a file. The content of the files, functionality
     * provided by the packages, how they are stored and used by the Agent side is Agent
     * type-specific and is outside the concerns of the OpAMP protocol.
     * If the Agent does not have an installed package with the specified name then
     * it SHOULD download it from the specified URL and install it.
     * If the Agent already has an installed package with the specified name
     * but with a different hash then the Agent SHOULD download and
     * install the package again, since it is a different version of the same package.
     * If the Agent has an installed package with the specified name and the same
     * hash then the Agent does not need to do anything, it already
     * has the right version of the package.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.PackageAvailable}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.PackageAvailable)
        opamp.proto.Opamp.PackageAvailableOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackageAvailable_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackageAvailable_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.PackageAvailable.class, opamp.proto.Opamp.PackageAvailable.Builder.class);
      }

      // Construct using opamp.proto.Opamp.PackageAvailable.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = 0;

        version_ = "";

        if (fileBuilder_ == null) {
          file_ = null;
        } else {
          file_ = null;
          fileBuilder_ = null;
        }
        hash_ = com.google.protobuf.ByteString.EMPTY;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackageAvailable_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackageAvailable getDefaultInstanceForType() {
        return opamp.proto.Opamp.PackageAvailable.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackageAvailable build() {
        opamp.proto.Opamp.PackageAvailable result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackageAvailable buildPartial() {
        opamp.proto.Opamp.PackageAvailable result = new opamp.proto.Opamp.PackageAvailable(this);
        result.type_ = type_;
        result.version_ = version_;
        if (fileBuilder_ == null) {
          result.file_ = file_;
        } else {
          result.file_ = fileBuilder_.build();
        }
        result.hash_ = hash_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.PackageAvailable) {
          return mergeFrom((opamp.proto.Opamp.PackageAvailable)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.PackageAvailable other) {
        if (other == opamp.proto.Opamp.PackageAvailable.getDefaultInstance()) return this;
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        if (!other.getVersion().isEmpty()) {
          version_ = other.version_;
          onChanged();
        }
        if (other.hasFile()) {
          mergeFile(other.getFile());
        }
        if (other.getHash() != com.google.protobuf.ByteString.EMPTY) {
          setHash(other.getHash());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.PackageAvailable parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.PackageAvailable) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int type_ = 0;
      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       * @return The enum numeric value on the wire for type.
       */
      @java.lang.Override public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public opamp.proto.Opamp.PackageType getType() {
        @SuppressWarnings("deprecation")
        opamp.proto.Opamp.PackageType result = opamp.proto.Opamp.PackageType.valueOf(type_);
        return result == null ? opamp.proto.Opamp.PackageType.UNRECOGNIZED : result;
      }
      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(opamp.proto.Opamp.PackageType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.PackageType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        
        type_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object version_ = "";
      /**
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       * @return The version.
       */
      public java.lang.String getVersion() {
        java.lang.Object ref = version_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          version_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       * @return The bytes for version.
       */
      public com.google.protobuf.ByteString
          getVersionBytes() {
        java.lang.Object ref = version_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          version_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       * @param value The version to set.
       * @return This builder for chaining.
       */
      public Builder setVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        version_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearVersion() {
        
        version_ = getDefaultInstance().getVersion();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The package version that is available on the Server side. The Agent may for
       * example use this information to avoid downloading a package that was previously
       * already downloaded and failed to install.
       * </pre>
       *
       * <code>string version = 2;</code>
       * @param value The bytes for version to set.
       * @return This builder for chaining.
       */
      public Builder setVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        version_ = value;
        onChanged();
        return this;
      }

      private opamp.proto.Opamp.DownloadableFile file_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.DownloadableFile, opamp.proto.Opamp.DownloadableFile.Builder, opamp.proto.Opamp.DownloadableFileOrBuilder> fileBuilder_;
      /**
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       * @return Whether the file field is set.
       */
      public boolean hasFile() {
        return fileBuilder_ != null || file_ != null;
      }
      /**
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       * @return The file.
       */
      public opamp.proto.Opamp.DownloadableFile getFile() {
        if (fileBuilder_ == null) {
          return file_ == null ? opamp.proto.Opamp.DownloadableFile.getDefaultInstance() : file_;
        } else {
          return fileBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public Builder setFile(opamp.proto.Opamp.DownloadableFile value) {
        if (fileBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          file_ = value;
          onChanged();
        } else {
          fileBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public Builder setFile(
          opamp.proto.Opamp.DownloadableFile.Builder builderForValue) {
        if (fileBuilder_ == null) {
          file_ = builderForValue.build();
          onChanged();
        } else {
          fileBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public Builder mergeFile(opamp.proto.Opamp.DownloadableFile value) {
        if (fileBuilder_ == null) {
          if (file_ != null) {
            file_ =
              opamp.proto.Opamp.DownloadableFile.newBuilder(file_).mergeFrom(value).buildPartial();
          } else {
            file_ = value;
          }
          onChanged();
        } else {
          fileBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public Builder clearFile() {
        if (fileBuilder_ == null) {
          file_ = null;
          onChanged();
        } else {
          file_ = null;
          fileBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public opamp.proto.Opamp.DownloadableFile.Builder getFileBuilder() {
        
        onChanged();
        return getFileFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      public opamp.proto.Opamp.DownloadableFileOrBuilder getFileOrBuilder() {
        if (fileBuilder_ != null) {
          return fileBuilder_.getMessageOrBuilder();
        } else {
          return file_ == null ?
              opamp.proto.Opamp.DownloadableFile.getDefaultInstance() : file_;
        }
      }
      /**
       * <pre>
       * The downloadable file of the package.
       * </pre>
       *
       * <code>.opamp.proto.DownloadableFile file = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.DownloadableFile, opamp.proto.Opamp.DownloadableFile.Builder, opamp.proto.Opamp.DownloadableFileOrBuilder> 
          getFileFieldBuilder() {
        if (fileBuilder_ == null) {
          fileBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.DownloadableFile, opamp.proto.Opamp.DownloadableFile.Builder, opamp.proto.Opamp.DownloadableFileOrBuilder>(
                  getFile(),
                  getParentForChildren(),
                  isClean());
          file_ = null;
        }
        return fileBuilder_;
      }

      private com.google.protobuf.ByteString hash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The hash of the package. SHOULD be calculated based on all other fields of the
       * PackageAvailable message and content of the file of the package. The hash is
       * used by the Agent to determine if the package it has is different from the
       * package the Server is offering.
       * </pre>
       *
       * <code>bytes hash = 4;</code>
       * @return The hash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getHash() {
        return hash_;
      }
      /**
       * <pre>
       * The hash of the package. SHOULD be calculated based on all other fields of the
       * PackageAvailable message and content of the file of the package. The hash is
       * used by the Agent to determine if the package it has is different from the
       * package the Server is offering.
       * </pre>
       *
       * <code>bytes hash = 4;</code>
       * @param value The hash to set.
       * @return This builder for chaining.
       */
      public Builder setHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        hash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash of the package. SHOULD be calculated based on all other fields of the
       * PackageAvailable message and content of the file of the package. The hash is
       * used by the Agent to determine if the package it has is different from the
       * package the Server is offering.
       * </pre>
       *
       * <code>bytes hash = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearHash() {
        
        hash_ = getDefaultInstance().getHash();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.PackageAvailable)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.PackageAvailable)
    private static final opamp.proto.Opamp.PackageAvailable DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.PackageAvailable();
    }

    public static opamp.proto.Opamp.PackageAvailable getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackageAvailable>
        PARSER = new com.google.protobuf.AbstractParser<PackageAvailable>() {
      @java.lang.Override
      public PackageAvailable parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PackageAvailable(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PackageAvailable> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PackageAvailable> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.PackageAvailable getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DownloadableFileOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.DownloadableFile)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The URL from which the file can be downloaded using HTTP GET request.
     * The Server at the specified URL SHOULD support range requests
     * to allow for resuming downloads.
     * </pre>
     *
     * <code>string download_url = 1;</code>
     * @return The downloadUrl.
     */
    java.lang.String getDownloadUrl();
    /**
     * <pre>
     * The URL from which the file can be downloaded using HTTP GET request.
     * The Server at the specified URL SHOULD support range requests
     * to allow for resuming downloads.
     * </pre>
     *
     * <code>string download_url = 1;</code>
     * @return The bytes for downloadUrl.
     */
    com.google.protobuf.ByteString
        getDownloadUrlBytes();

    /**
     * <pre>
     * The hash of the file content. Can be used by the Agent to verify that the file
     * was downloaded correctly.
     * </pre>
     *
     * <code>bytes content_hash = 2;</code>
     * @return The contentHash.
     */
    com.google.protobuf.ByteString getContentHash();

    /**
     * <pre>
     * Optional signature of the file content. Can be used by the Agent to verify the
     * authenticity of the downloaded file, for example can be the
     * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
     * The exact signing and verification method is Agent specific. See
     * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
     * for recommendations.
     * </pre>
     *
     * <code>bytes signature = 3;</code>
     * @return The signature.
     */
    com.google.protobuf.ByteString getSignature();
  }
  /**
   * Protobuf type {@code opamp.proto.DownloadableFile}
   */
  public static final class DownloadableFile extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.DownloadableFile)
      DownloadableFileOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DownloadableFile.newBuilder() to construct.
    private DownloadableFile(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DownloadableFile() {
      downloadUrl_ = "";
      contentHash_ = com.google.protobuf.ByteString.EMPTY;
      signature_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new DownloadableFile();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DownloadableFile(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              downloadUrl_ = s;
              break;
            }
            case 18: {

              contentHash_ = input.readBytes();
              break;
            }
            case 26: {

              signature_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_DownloadableFile_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_DownloadableFile_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.DownloadableFile.class, opamp.proto.Opamp.DownloadableFile.Builder.class);
    }

    public static final int DOWNLOAD_URL_FIELD_NUMBER = 1;
    private volatile java.lang.Object downloadUrl_;
    /**
     * <pre>
     * The URL from which the file can be downloaded using HTTP GET request.
     * The Server at the specified URL SHOULD support range requests
     * to allow for resuming downloads.
     * </pre>
     *
     * <code>string download_url = 1;</code>
     * @return The downloadUrl.
     */
    @java.lang.Override
    public java.lang.String getDownloadUrl() {
      java.lang.Object ref = downloadUrl_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        downloadUrl_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The URL from which the file can be downloaded using HTTP GET request.
     * The Server at the specified URL SHOULD support range requests
     * to allow for resuming downloads.
     * </pre>
     *
     * <code>string download_url = 1;</code>
     * @return The bytes for downloadUrl.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getDownloadUrlBytes() {
      java.lang.Object ref = downloadUrl_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        downloadUrl_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int CONTENT_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString contentHash_;
    /**
     * <pre>
     * The hash of the file content. Can be used by the Agent to verify that the file
     * was downloaded correctly.
     * </pre>
     *
     * <code>bytes content_hash = 2;</code>
     * @return The contentHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getContentHash() {
      return contentHash_;
    }

    public static final int SIGNATURE_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString signature_;
    /**
     * <pre>
     * Optional signature of the file content. Can be used by the Agent to verify the
     * authenticity of the downloaded file, for example can be the
     * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
     * The exact signing and verification method is Agent specific. See
     * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
     * for recommendations.
     * </pre>
     *
     * <code>bytes signature = 3;</code>
     * @return The signature.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getSignature() {
      return signature_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(downloadUrl_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, downloadUrl_);
      }
      if (!contentHash_.isEmpty()) {
        output.writeBytes(2, contentHash_);
      }
      if (!signature_.isEmpty()) {
        output.writeBytes(3, signature_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(downloadUrl_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, downloadUrl_);
      }
      if (!contentHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, contentHash_);
      }
      if (!signature_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, signature_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.DownloadableFile)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.DownloadableFile other = (opamp.proto.Opamp.DownloadableFile) obj;

      if (!getDownloadUrl()
          .equals(other.getDownloadUrl())) return false;
      if (!getContentHash()
          .equals(other.getContentHash())) return false;
      if (!getSignature()
          .equals(other.getSignature())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + DOWNLOAD_URL_FIELD_NUMBER;
      hash = (53 * hash) + getDownloadUrl().hashCode();
      hash = (37 * hash) + CONTENT_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getContentHash().hashCode();
      hash = (37 * hash) + SIGNATURE_FIELD_NUMBER;
      hash = (53 * hash) + getSignature().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.DownloadableFile parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.DownloadableFile parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.DownloadableFile parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.DownloadableFile parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.DownloadableFile parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.DownloadableFile parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.DownloadableFile parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.DownloadableFile parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.DownloadableFile parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.DownloadableFile parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.DownloadableFile parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.DownloadableFile parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.DownloadableFile prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.DownloadableFile}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.DownloadableFile)
        opamp.proto.Opamp.DownloadableFileOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_DownloadableFile_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_DownloadableFile_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.DownloadableFile.class, opamp.proto.Opamp.DownloadableFile.Builder.class);
      }

      // Construct using opamp.proto.Opamp.DownloadableFile.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        downloadUrl_ = "";

        contentHash_ = com.google.protobuf.ByteString.EMPTY;

        signature_ = com.google.protobuf.ByteString.EMPTY;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_DownloadableFile_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.DownloadableFile getDefaultInstanceForType() {
        return opamp.proto.Opamp.DownloadableFile.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.DownloadableFile build() {
        opamp.proto.Opamp.DownloadableFile result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.DownloadableFile buildPartial() {
        opamp.proto.Opamp.DownloadableFile result = new opamp.proto.Opamp.DownloadableFile(this);
        result.downloadUrl_ = downloadUrl_;
        result.contentHash_ = contentHash_;
        result.signature_ = signature_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.DownloadableFile) {
          return mergeFrom((opamp.proto.Opamp.DownloadableFile)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.DownloadableFile other) {
        if (other == opamp.proto.Opamp.DownloadableFile.getDefaultInstance()) return this;
        if (!other.getDownloadUrl().isEmpty()) {
          downloadUrl_ = other.downloadUrl_;
          onChanged();
        }
        if (other.getContentHash() != com.google.protobuf.ByteString.EMPTY) {
          setContentHash(other.getContentHash());
        }
        if (other.getSignature() != com.google.protobuf.ByteString.EMPTY) {
          setSignature(other.getSignature());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.DownloadableFile parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.DownloadableFile) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object downloadUrl_ = "";
      /**
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       * @return The downloadUrl.
       */
      public java.lang.String getDownloadUrl() {
        java.lang.Object ref = downloadUrl_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          downloadUrl_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       * @return The bytes for downloadUrl.
       */
      public com.google.protobuf.ByteString
          getDownloadUrlBytes() {
        java.lang.Object ref = downloadUrl_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          downloadUrl_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       * @param value The downloadUrl to set.
       * @return This builder for chaining.
       */
      public Builder setDownloadUrl(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        downloadUrl_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearDownloadUrl() {
        
        downloadUrl_ = getDefaultInstance().getDownloadUrl();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The URL from which the file can be downloaded using HTTP GET request.
       * The Server at the specified URL SHOULD support range requests
       * to allow for resuming downloads.
       * </pre>
       *
       * <code>string download_url = 1;</code>
       * @param value The bytes for downloadUrl to set.
       * @return This builder for chaining.
       */
      public Builder setDownloadUrlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        downloadUrl_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString contentHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The hash of the file content. Can be used by the Agent to verify that the file
       * was downloaded correctly.
       * </pre>
       *
       * <code>bytes content_hash = 2;</code>
       * @return The contentHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getContentHash() {
        return contentHash_;
      }
      /**
       * <pre>
       * The hash of the file content. Can be used by the Agent to verify that the file
       * was downloaded correctly.
       * </pre>
       *
       * <code>bytes content_hash = 2;</code>
       * @param value The contentHash to set.
       * @return This builder for chaining.
       */
      public Builder setContentHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        contentHash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash of the file content. Can be used by the Agent to verify that the file
       * was downloaded correctly.
       * </pre>
       *
       * <code>bytes content_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearContentHash() {
        
        contentHash_ = getDefaultInstance().getContentHash();
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString signature_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Optional signature of the file content. Can be used by the Agent to verify the
       * authenticity of the downloaded file, for example can be the
       * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
       * The exact signing and verification method is Agent specific. See
       * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
       * for recommendations.
       * </pre>
       *
       * <code>bytes signature = 3;</code>
       * @return The signature.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getSignature() {
        return signature_;
      }
      /**
       * <pre>
       * Optional signature of the file content. Can be used by the Agent to verify the
       * authenticity of the downloaded file, for example can be the
       * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
       * The exact signing and verification method is Agent specific. See
       * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
       * for recommendations.
       * </pre>
       *
       * <code>bytes signature = 3;</code>
       * @param value The signature to set.
       * @return This builder for chaining.
       */
      public Builder setSignature(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        signature_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional signature of the file content. Can be used by the Agent to verify the
       * authenticity of the downloaded file, for example can be the
       * [detached GPG signature](https://www.gnupg.org/gph/en/manual/x135.html#AEN160).
       * The exact signing and verification method is Agent specific. See
       * https://github.com/open-telemetry/opamp-spec/blob/main/specification.md#code-signing
       * for recommendations.
       * </pre>
       *
       * <code>bytes signature = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearSignature() {
        
        signature_ = getDefaultInstance().getSignature();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.DownloadableFile)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.DownloadableFile)
    private static final opamp.proto.Opamp.DownloadableFile DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.DownloadableFile();
    }

    public static opamp.proto.Opamp.DownloadableFile getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DownloadableFile>
        PARSER = new com.google.protobuf.AbstractParser<DownloadableFile>() {
      @java.lang.Override
      public DownloadableFile parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new DownloadableFile(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DownloadableFile> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DownloadableFile> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.DownloadableFile getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ServerErrorResponseOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ServerErrorResponse)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();
    /**
     * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
     * @return The type.
     */
    opamp.proto.Opamp.ServerErrorResponseType getType();

    /**
     * <pre>
     * Error message in the string form, typically human readable.
     * </pre>
     *
     * <code>string error_message = 2;</code>
     * @return The errorMessage.
     */
    java.lang.String getErrorMessage();
    /**
     * <pre>
     * Error message in the string form, typically human readable.
     * </pre>
     *
     * <code>string error_message = 2;</code>
     * @return The bytes for errorMessage.
     */
    com.google.protobuf.ByteString
        getErrorMessageBytes();

    /**
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     * @return Whether the retryInfo field is set.
     */
    boolean hasRetryInfo();
    /**
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     * @return The retryInfo.
     */
    opamp.proto.Opamp.RetryInfo getRetryInfo();
    /**
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     */
    opamp.proto.Opamp.RetryInfoOrBuilder getRetryInfoOrBuilder();

    public opamp.proto.Opamp.ServerErrorResponse.DetailsCase getDetailsCase();
  }
  /**
   * Protobuf type {@code opamp.proto.ServerErrorResponse}
   */
  public static final class ServerErrorResponse extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ServerErrorResponse)
      ServerErrorResponseOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ServerErrorResponse.newBuilder() to construct.
    private ServerErrorResponse(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ServerErrorResponse() {
      type_ = 0;
      errorMessage_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ServerErrorResponse();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ServerErrorResponse(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();

              type_ = rawValue;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              errorMessage_ = s;
              break;
            }
            case 26: {
              opamp.proto.Opamp.RetryInfo.Builder subBuilder = null;
              if (detailsCase_ == 3) {
                subBuilder = ((opamp.proto.Opamp.RetryInfo) details_).toBuilder();
              }
              details_ =
                  input.readMessage(opamp.proto.Opamp.RetryInfo.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom((opamp.proto.Opamp.RetryInfo) details_);
                details_ = subBuilder.buildPartial();
              }
              detailsCase_ = 3;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_ServerErrorResponse_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_ServerErrorResponse_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.ServerErrorResponse.class, opamp.proto.Opamp.ServerErrorResponse.Builder.class);
    }

    private int detailsCase_ = 0;
    private java.lang.Object details_;
    public enum DetailsCase
        implements com.google.protobuf.Internal.EnumLite,
            com.google.protobuf.AbstractMessage.InternalOneOfEnum {
      RETRY_INFO(3),
      DETAILS_NOT_SET(0);
      private final int value;
      private DetailsCase(int value) {
        this.value = value;
      }
      /**
       * @param value The number of the enum to look for.
       * @return The enum associated with the given number.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static DetailsCase valueOf(int value) {
        return forNumber(value);
      }

      public static DetailsCase forNumber(int value) {
        switch (value) {
          case 3: return RETRY_INFO;
          case 0: return DETAILS_NOT_SET;
          default: return null;
        }
      }
      public int getNumber() {
        return this.value;
      }
    };

    public DetailsCase
    getDetailsCase() {
      return DetailsCase.forNumber(
          detailsCase_);
    }

    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override public int getTypeValue() {
      return type_;
    }
    /**
     * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public opamp.proto.Opamp.ServerErrorResponseType getType() {
      @SuppressWarnings("deprecation")
      opamp.proto.Opamp.ServerErrorResponseType result = opamp.proto.Opamp.ServerErrorResponseType.valueOf(type_);
      return result == null ? opamp.proto.Opamp.ServerErrorResponseType.UNRECOGNIZED : result;
    }

    public static final int ERROR_MESSAGE_FIELD_NUMBER = 2;
    private volatile java.lang.Object errorMessage_;
    /**
     * <pre>
     * Error message in the string form, typically human readable.
     * </pre>
     *
     * <code>string error_message = 2;</code>
     * @return The errorMessage.
     */
    @java.lang.Override
    public java.lang.String getErrorMessage() {
      java.lang.Object ref = errorMessage_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        errorMessage_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Error message in the string form, typically human readable.
     * </pre>
     *
     * <code>string error_message = 2;</code>
     * @return The bytes for errorMessage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getErrorMessageBytes() {
      java.lang.Object ref = errorMessage_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        errorMessage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int RETRY_INFO_FIELD_NUMBER = 3;
    /**
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     * @return Whether the retryInfo field is set.
     */
    @java.lang.Override
    public boolean hasRetryInfo() {
      return detailsCase_ == 3;
    }
    /**
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     * @return The retryInfo.
     */
    @java.lang.Override
    public opamp.proto.Opamp.RetryInfo getRetryInfo() {
      if (detailsCase_ == 3) {
         return (opamp.proto.Opamp.RetryInfo) details_;
      }
      return opamp.proto.Opamp.RetryInfo.getDefaultInstance();
    }
    /**
     * <pre>
     * Additional information about retrying if type==UNAVAILABLE.
     * </pre>
     *
     * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.RetryInfoOrBuilder getRetryInfoOrBuilder() {
      if (detailsCase_ == 3) {
         return (opamp.proto.Opamp.RetryInfo) details_;
      }
      return opamp.proto.Opamp.RetryInfo.getDefaultInstance();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (type_ != opamp.proto.Opamp.ServerErrorResponseType.ServerErrorResponseType_Unknown.getNumber()) {
        output.writeEnum(1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, errorMessage_);
      }
      if (detailsCase_ == 3) {
        output.writeMessage(3, (opamp.proto.Opamp.RetryInfo) details_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (type_ != opamp.proto.Opamp.ServerErrorResponseType.ServerErrorResponseType_Unknown.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, errorMessage_);
      }
      if (detailsCase_ == 3) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, (opamp.proto.Opamp.RetryInfo) details_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.ServerErrorResponse)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.ServerErrorResponse other = (opamp.proto.Opamp.ServerErrorResponse) obj;

      if (type_ != other.type_) return false;
      if (!getErrorMessage()
          .equals(other.getErrorMessage())) return false;
      if (!getDetailsCase().equals(other.getDetailsCase())) return false;
      switch (detailsCase_) {
        case 3:
          if (!getRetryInfo()
              .equals(other.getRetryInfo())) return false;
          break;
        case 0:
        default:
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (37 * hash) + ERROR_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getErrorMessage().hashCode();
      switch (detailsCase_) {
        case 3:
          hash = (37 * hash) + RETRY_INFO_FIELD_NUMBER;
          hash = (53 * hash) + getRetryInfo().hashCode();
          break;
        case 0:
        default:
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ServerErrorResponse parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.ServerErrorResponse prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.ServerErrorResponse}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ServerErrorResponse)
        opamp.proto.Opamp.ServerErrorResponseOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ServerErrorResponse_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ServerErrorResponse_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.ServerErrorResponse.class, opamp.proto.Opamp.ServerErrorResponse.Builder.class);
      }

      // Construct using opamp.proto.Opamp.ServerErrorResponse.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = 0;

        errorMessage_ = "";

        detailsCase_ = 0;
        details_ = null;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ServerErrorResponse_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.ServerErrorResponse getDefaultInstanceForType() {
        return opamp.proto.Opamp.ServerErrorResponse.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.ServerErrorResponse build() {
        opamp.proto.Opamp.ServerErrorResponse result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.ServerErrorResponse buildPartial() {
        opamp.proto.Opamp.ServerErrorResponse result = new opamp.proto.Opamp.ServerErrorResponse(this);
        result.type_ = type_;
        result.errorMessage_ = errorMessage_;
        if (detailsCase_ == 3) {
          if (retryInfoBuilder_ == null) {
            result.details_ = details_;
          } else {
            result.details_ = retryInfoBuilder_.build();
          }
        }
        result.detailsCase_ = detailsCase_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.ServerErrorResponse) {
          return mergeFrom((opamp.proto.Opamp.ServerErrorResponse)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.ServerErrorResponse other) {
        if (other == opamp.proto.Opamp.ServerErrorResponse.getDefaultInstance()) return this;
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        if (!other.getErrorMessage().isEmpty()) {
          errorMessage_ = other.errorMessage_;
          onChanged();
        }
        switch (other.getDetailsCase()) {
          case RETRY_INFO: {
            mergeRetryInfo(other.getRetryInfo());
            break;
          }
          case DETAILS_NOT_SET: {
            break;
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.ServerErrorResponse parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.ServerErrorResponse) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int detailsCase_ = 0;
      private java.lang.Object details_;
      public DetailsCase
          getDetailsCase() {
        return DetailsCase.forNumber(
            detailsCase_);
      }

      public Builder clearDetails() {
        detailsCase_ = 0;
        details_ = null;
        onChanged();
        return this;
      }


      private int type_ = 0;
      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       * @return The enum numeric value on the wire for type.
       */
      @java.lang.Override public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public opamp.proto.Opamp.ServerErrorResponseType getType() {
        @SuppressWarnings("deprecation")
        opamp.proto.Opamp.ServerErrorResponseType result = opamp.proto.Opamp.ServerErrorResponseType.valueOf(type_);
        return result == null ? opamp.proto.Opamp.ServerErrorResponseType.UNRECOGNIZED : result;
      }
      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(opamp.proto.Opamp.ServerErrorResponseType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.ServerErrorResponseType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        
        type_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object errorMessage_ = "";
      /**
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       * @return The errorMessage.
       */
      public java.lang.String getErrorMessage() {
        java.lang.Object ref = errorMessage_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          errorMessage_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       * @return The bytes for errorMessage.
       */
      public com.google.protobuf.ByteString
          getErrorMessageBytes() {
        java.lang.Object ref = errorMessage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          errorMessage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       * @param value The errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        errorMessage_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearErrorMessage() {
        
        errorMessage_ = getDefaultInstance().getErrorMessage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Error message in the string form, typically human readable.
       * </pre>
       *
       * <code>string error_message = 2;</code>
       * @param value The bytes for errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        errorMessage_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.RetryInfo, opamp.proto.Opamp.RetryInfo.Builder, opamp.proto.Opamp.RetryInfoOrBuilder> retryInfoBuilder_;
      /**
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       * @return Whether the retryInfo field is set.
       */
      @java.lang.Override
      public boolean hasRetryInfo() {
        return detailsCase_ == 3;
      }
      /**
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       * @return The retryInfo.
       */
      @java.lang.Override
      public opamp.proto.Opamp.RetryInfo getRetryInfo() {
        if (retryInfoBuilder_ == null) {
          if (detailsCase_ == 3) {
            return (opamp.proto.Opamp.RetryInfo) details_;
          }
          return opamp.proto.Opamp.RetryInfo.getDefaultInstance();
        } else {
          if (detailsCase_ == 3) {
            return retryInfoBuilder_.getMessage();
          }
          return opamp.proto.Opamp.RetryInfo.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public Builder setRetryInfo(opamp.proto.Opamp.RetryInfo value) {
        if (retryInfoBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          details_ = value;
          onChanged();
        } else {
          retryInfoBuilder_.setMessage(value);
        }
        detailsCase_ = 3;
        return this;
      }
      /**
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public Builder setRetryInfo(
          opamp.proto.Opamp.RetryInfo.Builder builderForValue) {
        if (retryInfoBuilder_ == null) {
          details_ = builderForValue.build();
          onChanged();
        } else {
          retryInfoBuilder_.setMessage(builderForValue.build());
        }
        detailsCase_ = 3;
        return this;
      }
      /**
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public Builder mergeRetryInfo(opamp.proto.Opamp.RetryInfo value) {
        if (retryInfoBuilder_ == null) {
          if (detailsCase_ == 3 &&
              details_ != opamp.proto.Opamp.RetryInfo.getDefaultInstance()) {
            details_ = opamp.proto.Opamp.RetryInfo.newBuilder((opamp.proto.Opamp.RetryInfo) details_)
                .mergeFrom(value).buildPartial();
          } else {
            details_ = value;
          }
          onChanged();
        } else {
          if (detailsCase_ == 3) {
            retryInfoBuilder_.mergeFrom(value);
          }
          retryInfoBuilder_.setMessage(value);
        }
        detailsCase_ = 3;
        return this;
      }
      /**
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public Builder clearRetryInfo() {
        if (retryInfoBuilder_ == null) {
          if (detailsCase_ == 3) {
            detailsCase_ = 0;
            details_ = null;
            onChanged();
          }
        } else {
          if (detailsCase_ == 3) {
            detailsCase_ = 0;
            details_ = null;
          }
          retryInfoBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      public opamp.proto.Opamp.RetryInfo.Builder getRetryInfoBuilder() {
        return getRetryInfoFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      @java.lang.Override
      public opamp.proto.Opamp.RetryInfoOrBuilder getRetryInfoOrBuilder() {
        if ((detailsCase_ == 3) && (retryInfoBuilder_ != null)) {
          return retryInfoBuilder_.getMessageOrBuilder();
        } else {
          if (detailsCase_ == 3) {
            return (opamp.proto.Opamp.RetryInfo) details_;
          }
          return opamp.proto.Opamp.RetryInfo.getDefaultInstance();
        }
      }
      /**
       * <pre>
       * Additional information about retrying if type==UNAVAILABLE.
       * </pre>
       *
       * <code>.opamp.proto.RetryInfo retry_info = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.RetryInfo, opamp.proto.Opamp.RetryInfo.Builder, opamp.proto.Opamp.RetryInfoOrBuilder> 
          getRetryInfoFieldBuilder() {
        if (retryInfoBuilder_ == null) {
          if (!(detailsCase_ == 3)) {
            details_ = opamp.proto.Opamp.RetryInfo.getDefaultInstance();
          }
          retryInfoBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.RetryInfo, opamp.proto.Opamp.RetryInfo.Builder, opamp.proto.Opamp.RetryInfoOrBuilder>(
                  (opamp.proto.Opamp.RetryInfo) details_,
                  getParentForChildren(),
                  isClean());
          details_ = null;
        }
        detailsCase_ = 3;
        onChanged();;
        return retryInfoBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.ServerErrorResponse)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ServerErrorResponse)
    private static final opamp.proto.Opamp.ServerErrorResponse DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.ServerErrorResponse();
    }

    public static opamp.proto.Opamp.ServerErrorResponse getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ServerErrorResponse>
        PARSER = new com.google.protobuf.AbstractParser<ServerErrorResponse>() {
      @java.lang.Override
      public ServerErrorResponse parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ServerErrorResponse(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ServerErrorResponse> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ServerErrorResponse> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.ServerErrorResponse getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RetryInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.RetryInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>uint64 retry_after_nanoseconds = 1;</code>
     * @return The retryAfterNanoseconds.
     */
    long getRetryAfterNanoseconds();
  }
  /**
   * Protobuf type {@code opamp.proto.RetryInfo}
   */
  public static final class RetryInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.RetryInfo)
      RetryInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RetryInfo.newBuilder() to construct.
    private RetryInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RetryInfo() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new RetryInfo();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RetryInfo(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              retryAfterNanoseconds_ = input.readUInt64();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_RetryInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_RetryInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.RetryInfo.class, opamp.proto.Opamp.RetryInfo.Builder.class);
    }

    public static final int RETRY_AFTER_NANOSECONDS_FIELD_NUMBER = 1;
    private long retryAfterNanoseconds_;
    /**
     * <code>uint64 retry_after_nanoseconds = 1;</code>
     * @return The retryAfterNanoseconds.
     */
    @java.lang.Override
    public long getRetryAfterNanoseconds() {
      return retryAfterNanoseconds_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (retryAfterNanoseconds_ != 0L) {
        output.writeUInt64(1, retryAfterNanoseconds_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (retryAfterNanoseconds_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(1, retryAfterNanoseconds_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.RetryInfo)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.RetryInfo other = (opamp.proto.Opamp.RetryInfo) obj;

      if (getRetryAfterNanoseconds()
          != other.getRetryAfterNanoseconds()) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + RETRY_AFTER_NANOSECONDS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getRetryAfterNanoseconds());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.RetryInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.RetryInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.RetryInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.RetryInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.RetryInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.RetryInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.RetryInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.RetryInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.RetryInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.RetryInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.RetryInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.RetryInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.RetryInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.RetryInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.RetryInfo)
        opamp.proto.Opamp.RetryInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_RetryInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_RetryInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.RetryInfo.class, opamp.proto.Opamp.RetryInfo.Builder.class);
      }

      // Construct using opamp.proto.Opamp.RetryInfo.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        retryAfterNanoseconds_ = 0L;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_RetryInfo_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.RetryInfo getDefaultInstanceForType() {
        return opamp.proto.Opamp.RetryInfo.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.RetryInfo build() {
        opamp.proto.Opamp.RetryInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.RetryInfo buildPartial() {
        opamp.proto.Opamp.RetryInfo result = new opamp.proto.Opamp.RetryInfo(this);
        result.retryAfterNanoseconds_ = retryAfterNanoseconds_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.RetryInfo) {
          return mergeFrom((opamp.proto.Opamp.RetryInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.RetryInfo other) {
        if (other == opamp.proto.Opamp.RetryInfo.getDefaultInstance()) return this;
        if (other.getRetryAfterNanoseconds() != 0L) {
          setRetryAfterNanoseconds(other.getRetryAfterNanoseconds());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.RetryInfo parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.RetryInfo) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private long retryAfterNanoseconds_ ;
      /**
       * <code>uint64 retry_after_nanoseconds = 1;</code>
       * @return The retryAfterNanoseconds.
       */
      @java.lang.Override
      public long getRetryAfterNanoseconds() {
        return retryAfterNanoseconds_;
      }
      /**
       * <code>uint64 retry_after_nanoseconds = 1;</code>
       * @param value The retryAfterNanoseconds to set.
       * @return This builder for chaining.
       */
      public Builder setRetryAfterNanoseconds(long value) {
        
        retryAfterNanoseconds_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>uint64 retry_after_nanoseconds = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearRetryAfterNanoseconds() {
        
        retryAfterNanoseconds_ = 0L;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.RetryInfo)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.RetryInfo)
    private static final opamp.proto.Opamp.RetryInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.RetryInfo();
    }

    public static opamp.proto.Opamp.RetryInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RetryInfo>
        PARSER = new com.google.protobuf.AbstractParser<RetryInfo>() {
      @java.lang.Override
      public RetryInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RetryInfo(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RetryInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RetryInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.RetryInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ServerToAgentCommandOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.ServerToAgentCommand)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>.opamp.proto.CommandType type = 1;</code>
     * @return The enum numeric value on the wire for type.
     */
    int getTypeValue();
    /**
     * <code>.opamp.proto.CommandType type = 1;</code>
     * @return The type.
     */
    opamp.proto.Opamp.CommandType getType();
  }
  /**
   * <pre>
   * ServerToAgentCommand is sent from the Server to the Agent to request that the Agent
   * perform a command.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.ServerToAgentCommand}
   */
  public static final class ServerToAgentCommand extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.ServerToAgentCommand)
      ServerToAgentCommandOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ServerToAgentCommand.newBuilder() to construct.
    private ServerToAgentCommand(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ServerToAgentCommand() {
      type_ = 0;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ServerToAgentCommand();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ServerToAgentCommand(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {
              int rawValue = input.readEnum();

              type_ = rawValue;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgentCommand_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgentCommand_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.ServerToAgentCommand.class, opamp.proto.Opamp.ServerToAgentCommand.Builder.class);
    }

    public static final int TYPE_FIELD_NUMBER = 1;
    private int type_;
    /**
     * <code>.opamp.proto.CommandType type = 1;</code>
     * @return The enum numeric value on the wire for type.
     */
    @java.lang.Override public int getTypeValue() {
      return type_;
    }
    /**
     * <code>.opamp.proto.CommandType type = 1;</code>
     * @return The type.
     */
    @java.lang.Override public opamp.proto.Opamp.CommandType getType() {
      @SuppressWarnings("deprecation")
      opamp.proto.Opamp.CommandType result = opamp.proto.Opamp.CommandType.valueOf(type_);
      return result == null ? opamp.proto.Opamp.CommandType.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (type_ != opamp.proto.Opamp.CommandType.CommandType_Restart.getNumber()) {
        output.writeEnum(1, type_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (type_ != opamp.proto.Opamp.CommandType.CommandType_Restart.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(1, type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.ServerToAgentCommand)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.ServerToAgentCommand other = (opamp.proto.Opamp.ServerToAgentCommand) obj;

      if (type_ != other.type_) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.ServerToAgentCommand parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.ServerToAgentCommand prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ServerToAgentCommand is sent from the Server to the Agent to request that the Agent
     * perform a command.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.ServerToAgentCommand}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.ServerToAgentCommand)
        opamp.proto.Opamp.ServerToAgentCommandOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgentCommand_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgentCommand_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.ServerToAgentCommand.class, opamp.proto.Opamp.ServerToAgentCommand.Builder.class);
      }

      // Construct using opamp.proto.Opamp.ServerToAgentCommand.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        type_ = 0;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_ServerToAgentCommand_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.ServerToAgentCommand getDefaultInstanceForType() {
        return opamp.proto.Opamp.ServerToAgentCommand.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.ServerToAgentCommand build() {
        opamp.proto.Opamp.ServerToAgentCommand result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.ServerToAgentCommand buildPartial() {
        opamp.proto.Opamp.ServerToAgentCommand result = new opamp.proto.Opamp.ServerToAgentCommand(this);
        result.type_ = type_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.ServerToAgentCommand) {
          return mergeFrom((opamp.proto.Opamp.ServerToAgentCommand)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.ServerToAgentCommand other) {
        if (other == opamp.proto.Opamp.ServerToAgentCommand.getDefaultInstance()) return this;
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.ServerToAgentCommand parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.ServerToAgentCommand) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private int type_ = 0;
      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       * @return The enum numeric value on the wire for type.
       */
      @java.lang.Override public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       * @param value The enum numeric value on the wire for type to set.
       * @return This builder for chaining.
       */
      public Builder setTypeValue(int value) {
        
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       * @return The type.
       */
      @java.lang.Override
      public opamp.proto.Opamp.CommandType getType() {
        @SuppressWarnings("deprecation")
        opamp.proto.Opamp.CommandType result = opamp.proto.Opamp.CommandType.valueOf(type_);
        return result == null ? opamp.proto.Opamp.CommandType.UNRECOGNIZED : result;
      }
      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       * @param value The type to set.
       * @return This builder for chaining.
       */
      public Builder setType(opamp.proto.Opamp.CommandType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.CommandType type = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearType() {
        
        type_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.ServerToAgentCommand)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.ServerToAgentCommand)
    private static final opamp.proto.Opamp.ServerToAgentCommand DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.ServerToAgentCommand();
    }

    public static opamp.proto.Opamp.ServerToAgentCommand getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ServerToAgentCommand>
        PARSER = new com.google.protobuf.AbstractParser<ServerToAgentCommand>() {
      @java.lang.Override
      public ServerToAgentCommand parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ServerToAgentCommand(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ServerToAgentCommand> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ServerToAgentCommand> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.ServerToAgentCommand getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AgentDescriptionOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentDescription)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    java.util.List<opamp.proto.Anyvalue.KeyValue> 
        getIdentifyingAttributesList();
    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    opamp.proto.Anyvalue.KeyValue getIdentifyingAttributes(int index);
    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    int getIdentifyingAttributesCount();
    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    java.util.List<? extends opamp.proto.Anyvalue.KeyValueOrBuilder> 
        getIdentifyingAttributesOrBuilderList();
    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    opamp.proto.Anyvalue.KeyValueOrBuilder getIdentifyingAttributesOrBuilder(
        int index);

    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    java.util.List<opamp.proto.Anyvalue.KeyValue> 
        getNonIdentifyingAttributesList();
    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    opamp.proto.Anyvalue.KeyValue getNonIdentifyingAttributes(int index);
    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    int getNonIdentifyingAttributesCount();
    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    java.util.List<? extends opamp.proto.Anyvalue.KeyValueOrBuilder> 
        getNonIdentifyingAttributesOrBuilderList();
    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    opamp.proto.Anyvalue.KeyValueOrBuilder getNonIdentifyingAttributesOrBuilder(
        int index);
  }
  /**
   * Protobuf type {@code opamp.proto.AgentDescription}
   */
  public static final class AgentDescription extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentDescription)
      AgentDescriptionOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AgentDescription.newBuilder() to construct.
    private AgentDescription(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AgentDescription() {
      identifyingAttributes_ = java.util.Collections.emptyList();
      nonIdentifyingAttributes_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AgentDescription();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AgentDescription(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                identifyingAttributes_ = new java.util.ArrayList<opamp.proto.Anyvalue.KeyValue>();
                mutable_bitField0_ |= 0x00000001;
              }
              identifyingAttributes_.add(
                  input.readMessage(opamp.proto.Anyvalue.KeyValue.parser(), extensionRegistry));
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) != 0)) {
                nonIdentifyingAttributes_ = new java.util.ArrayList<opamp.proto.Anyvalue.KeyValue>();
                mutable_bitField0_ |= 0x00000002;
              }
              nonIdentifyingAttributes_.add(
                  input.readMessage(opamp.proto.Anyvalue.KeyValue.parser(), extensionRegistry));
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) != 0)) {
          identifyingAttributes_ = java.util.Collections.unmodifiableList(identifyingAttributes_);
        }
        if (((mutable_bitField0_ & 0x00000002) != 0)) {
          nonIdentifyingAttributes_ = java.util.Collections.unmodifiableList(nonIdentifyingAttributes_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentDescription_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentDescription_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.AgentDescription.class, opamp.proto.Opamp.AgentDescription.Builder.class);
    }

    public static final int IDENTIFYING_ATTRIBUTES_FIELD_NUMBER = 1;
    private java.util.List<opamp.proto.Anyvalue.KeyValue> identifyingAttributes_;
    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @java.lang.Override
    public java.util.List<opamp.proto.Anyvalue.KeyValue> getIdentifyingAttributesList() {
      return identifyingAttributes_;
    }
    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @java.lang.Override
    public java.util.List<? extends opamp.proto.Anyvalue.KeyValueOrBuilder> 
        getIdentifyingAttributesOrBuilderList() {
      return identifyingAttributes_;
    }
    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @java.lang.Override
    public int getIdentifyingAttributesCount() {
      return identifyingAttributes_.size();
    }
    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @java.lang.Override
    public opamp.proto.Anyvalue.KeyValue getIdentifyingAttributes(int index) {
      return identifyingAttributes_.get(index);
    }
    /**
     * <pre>
     * Attributes that identify the Agent.
     * Keys/values are according to OpenTelemetry semantic conventions, see:
     * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
     * For standalone running Agents (such as OpenTelemetry Collector) the following
     * attributes SHOULD be specified:
     * - service.name should be set to a reverse FQDN that uniquely identifies the
     *   Agent type, e.g. "io.opentelemetry.collector"
     * - service.namespace if it is used in the environment where the Agent runs.
     * - service.version should be set to version number of the Agent build.
     * - service.instance.id should be set. It may be be set equal to the Agent's
     *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
     *   that uniquely identifies the Agent in combination with other attributes.
     * - any other attributes that are necessary for uniquely identifying the Agent's
     *   own telemetry.
     * The Agent SHOULD also include these attributes in the Resource of its own
     * telemetry. The combination of identifying attributes SHOULD be sufficient to
     * uniquely identify the Agent's own telemetry in the destination system to which
     * the Agent sends its own telemetry.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
     */
    @java.lang.Override
    public opamp.proto.Anyvalue.KeyValueOrBuilder getIdentifyingAttributesOrBuilder(
        int index) {
      return identifyingAttributes_.get(index);
    }

    public static final int NON_IDENTIFYING_ATTRIBUTES_FIELD_NUMBER = 2;
    private java.util.List<opamp.proto.Anyvalue.KeyValue> nonIdentifyingAttributes_;
    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @java.lang.Override
    public java.util.List<opamp.proto.Anyvalue.KeyValue> getNonIdentifyingAttributesList() {
      return nonIdentifyingAttributes_;
    }
    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends opamp.proto.Anyvalue.KeyValueOrBuilder> 
        getNonIdentifyingAttributesOrBuilderList() {
      return nonIdentifyingAttributes_;
    }
    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @java.lang.Override
    public int getNonIdentifyingAttributesCount() {
      return nonIdentifyingAttributes_.size();
    }
    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @java.lang.Override
    public opamp.proto.Anyvalue.KeyValue getNonIdentifyingAttributes(int index) {
      return nonIdentifyingAttributes_.get(index);
    }
    /**
     * <pre>
     * Attributes that do not necessarily identify the Agent but help describe
     * where it runs.
     * The following attributes SHOULD be included:
     * - os.type, os.version - to describe where the Agent runs.
     * - host.* to describe the host the Agent runs on.
     * - cloud.* to describe the cloud where the host is located.
     * - any other relevant Resource attributes that describe this Agent and the
     *   environment it runs in.
     * - any user-defined attributes that the end user would like to associate
     *   with this Agent.
     * </pre>
     *
     * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
     */
    @java.lang.Override
    public opamp.proto.Anyvalue.KeyValueOrBuilder getNonIdentifyingAttributesOrBuilder(
        int index) {
      return nonIdentifyingAttributes_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < identifyingAttributes_.size(); i++) {
        output.writeMessage(1, identifyingAttributes_.get(i));
      }
      for (int i = 0; i < nonIdentifyingAttributes_.size(); i++) {
        output.writeMessage(2, nonIdentifyingAttributes_.get(i));
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < identifyingAttributes_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, identifyingAttributes_.get(i));
      }
      for (int i = 0; i < nonIdentifyingAttributes_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, nonIdentifyingAttributes_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.AgentDescription)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.AgentDescription other = (opamp.proto.Opamp.AgentDescription) obj;

      if (!getIdentifyingAttributesList()
          .equals(other.getIdentifyingAttributesList())) return false;
      if (!getNonIdentifyingAttributesList()
          .equals(other.getNonIdentifyingAttributesList())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getIdentifyingAttributesCount() > 0) {
        hash = (37 * hash) + IDENTIFYING_ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + getIdentifyingAttributesList().hashCode();
      }
      if (getNonIdentifyingAttributesCount() > 0) {
        hash = (37 * hash) + NON_IDENTIFYING_ATTRIBUTES_FIELD_NUMBER;
        hash = (53 * hash) + getNonIdentifyingAttributesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.AgentDescription parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentDescription parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDescription parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentDescription parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDescription parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentDescription parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDescription parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentDescription parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDescription parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentDescription parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentDescription parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentDescription parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.AgentDescription prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.AgentDescription}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentDescription)
        opamp.proto.Opamp.AgentDescriptionOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentDescription_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentDescription_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.AgentDescription.class, opamp.proto.Opamp.AgentDescription.Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentDescription.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getIdentifyingAttributesFieldBuilder();
          getNonIdentifyingAttributesFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (identifyingAttributesBuilder_ == null) {
          identifyingAttributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          identifyingAttributesBuilder_.clear();
        }
        if (nonIdentifyingAttributesBuilder_ == null) {
          nonIdentifyingAttributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          nonIdentifyingAttributesBuilder_.clear();
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentDescription_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentDescription getDefaultInstanceForType() {
        return opamp.proto.Opamp.AgentDescription.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentDescription build() {
        opamp.proto.Opamp.AgentDescription result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentDescription buildPartial() {
        opamp.proto.Opamp.AgentDescription result = new opamp.proto.Opamp.AgentDescription(this);
        int from_bitField0_ = bitField0_;
        if (identifyingAttributesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) != 0)) {
            identifyingAttributes_ = java.util.Collections.unmodifiableList(identifyingAttributes_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.identifyingAttributes_ = identifyingAttributes_;
        } else {
          result.identifyingAttributes_ = identifyingAttributesBuilder_.build();
        }
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            nonIdentifyingAttributes_ = java.util.Collections.unmodifiableList(nonIdentifyingAttributes_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.nonIdentifyingAttributes_ = nonIdentifyingAttributes_;
        } else {
          result.nonIdentifyingAttributes_ = nonIdentifyingAttributesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.AgentDescription) {
          return mergeFrom((opamp.proto.Opamp.AgentDescription)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.AgentDescription other) {
        if (other == opamp.proto.Opamp.AgentDescription.getDefaultInstance()) return this;
        if (identifyingAttributesBuilder_ == null) {
          if (!other.identifyingAttributes_.isEmpty()) {
            if (identifyingAttributes_.isEmpty()) {
              identifyingAttributes_ = other.identifyingAttributes_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureIdentifyingAttributesIsMutable();
              identifyingAttributes_.addAll(other.identifyingAttributes_);
            }
            onChanged();
          }
        } else {
          if (!other.identifyingAttributes_.isEmpty()) {
            if (identifyingAttributesBuilder_.isEmpty()) {
              identifyingAttributesBuilder_.dispose();
              identifyingAttributesBuilder_ = null;
              identifyingAttributes_ = other.identifyingAttributes_;
              bitField0_ = (bitField0_ & ~0x00000001);
              identifyingAttributesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getIdentifyingAttributesFieldBuilder() : null;
            } else {
              identifyingAttributesBuilder_.addAllMessages(other.identifyingAttributes_);
            }
          }
        }
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (!other.nonIdentifyingAttributes_.isEmpty()) {
            if (nonIdentifyingAttributes_.isEmpty()) {
              nonIdentifyingAttributes_ = other.nonIdentifyingAttributes_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureNonIdentifyingAttributesIsMutable();
              nonIdentifyingAttributes_.addAll(other.nonIdentifyingAttributes_);
            }
            onChanged();
          }
        } else {
          if (!other.nonIdentifyingAttributes_.isEmpty()) {
            if (nonIdentifyingAttributesBuilder_.isEmpty()) {
              nonIdentifyingAttributesBuilder_.dispose();
              nonIdentifyingAttributesBuilder_ = null;
              nonIdentifyingAttributes_ = other.nonIdentifyingAttributes_;
              bitField0_ = (bitField0_ & ~0x00000002);
              nonIdentifyingAttributesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getNonIdentifyingAttributesFieldBuilder() : null;
            } else {
              nonIdentifyingAttributesBuilder_.addAllMessages(other.nonIdentifyingAttributes_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.AgentDescription parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.AgentDescription) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<opamp.proto.Anyvalue.KeyValue> identifyingAttributes_ =
        java.util.Collections.emptyList();
      private void ensureIdentifyingAttributesIsMutable() {
        if (!((bitField0_ & 0x00000001) != 0)) {
          identifyingAttributes_ = new java.util.ArrayList<opamp.proto.Anyvalue.KeyValue>(identifyingAttributes_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          opamp.proto.Anyvalue.KeyValue, opamp.proto.Anyvalue.KeyValue.Builder, opamp.proto.Anyvalue.KeyValueOrBuilder> identifyingAttributesBuilder_;

      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public java.util.List<opamp.proto.Anyvalue.KeyValue> getIdentifyingAttributesList() {
        if (identifyingAttributesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(identifyingAttributes_);
        } else {
          return identifyingAttributesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public int getIdentifyingAttributesCount() {
        if (identifyingAttributesBuilder_ == null) {
          return identifyingAttributes_.size();
        } else {
          return identifyingAttributesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public opamp.proto.Anyvalue.KeyValue getIdentifyingAttributes(int index) {
        if (identifyingAttributesBuilder_ == null) {
          return identifyingAttributes_.get(index);
        } else {
          return identifyingAttributesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder setIdentifyingAttributes(
          int index, opamp.proto.Anyvalue.KeyValue value) {
        if (identifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.set(index, value);
          onChanged();
        } else {
          identifyingAttributesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder setIdentifyingAttributes(
          int index, opamp.proto.Anyvalue.KeyValue.Builder builderForValue) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.set(index, builderForValue.build());
          onChanged();
        } else {
          identifyingAttributesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addIdentifyingAttributes(opamp.proto.Anyvalue.KeyValue value) {
        if (identifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.add(value);
          onChanged();
        } else {
          identifyingAttributesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addIdentifyingAttributes(
          int index, opamp.proto.Anyvalue.KeyValue value) {
        if (identifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.add(index, value);
          onChanged();
        } else {
          identifyingAttributesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addIdentifyingAttributes(
          opamp.proto.Anyvalue.KeyValue.Builder builderForValue) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.add(builderForValue.build());
          onChanged();
        } else {
          identifyingAttributesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addIdentifyingAttributes(
          int index, opamp.proto.Anyvalue.KeyValue.Builder builderForValue) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.add(index, builderForValue.build());
          onChanged();
        } else {
          identifyingAttributesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder addAllIdentifyingAttributes(
          java.lang.Iterable<? extends opamp.proto.Anyvalue.KeyValue> values) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, identifyingAttributes_);
          onChanged();
        } else {
          identifyingAttributesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder clearIdentifyingAttributes() {
        if (identifyingAttributesBuilder_ == null) {
          identifyingAttributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          identifyingAttributesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public Builder removeIdentifyingAttributes(int index) {
        if (identifyingAttributesBuilder_ == null) {
          ensureIdentifyingAttributesIsMutable();
          identifyingAttributes_.remove(index);
          onChanged();
        } else {
          identifyingAttributesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public opamp.proto.Anyvalue.KeyValue.Builder getIdentifyingAttributesBuilder(
          int index) {
        return getIdentifyingAttributesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public opamp.proto.Anyvalue.KeyValueOrBuilder getIdentifyingAttributesOrBuilder(
          int index) {
        if (identifyingAttributesBuilder_ == null) {
          return identifyingAttributes_.get(index);  } else {
          return identifyingAttributesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public java.util.List<? extends opamp.proto.Anyvalue.KeyValueOrBuilder> 
           getIdentifyingAttributesOrBuilderList() {
        if (identifyingAttributesBuilder_ != null) {
          return identifyingAttributesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(identifyingAttributes_);
        }
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public opamp.proto.Anyvalue.KeyValue.Builder addIdentifyingAttributesBuilder() {
        return getIdentifyingAttributesFieldBuilder().addBuilder(
            opamp.proto.Anyvalue.KeyValue.getDefaultInstance());
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public opamp.proto.Anyvalue.KeyValue.Builder addIdentifyingAttributesBuilder(
          int index) {
        return getIdentifyingAttributesFieldBuilder().addBuilder(
            index, opamp.proto.Anyvalue.KeyValue.getDefaultInstance());
      }
      /**
       * <pre>
       * Attributes that identify the Agent.
       * Keys/values are according to OpenTelemetry semantic conventions, see:
       * https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/resource/semantic_conventions
       * For standalone running Agents (such as OpenTelemetry Collector) the following
       * attributes SHOULD be specified:
       * - service.name should be set to a reverse FQDN that uniquely identifies the
       *   Agent type, e.g. "io.opentelemetry.collector"
       * - service.namespace if it is used in the environment where the Agent runs.
       * - service.version should be set to version number of the Agent build.
       * - service.instance.id should be set. It may be be set equal to the Agent's
       *   instance uid (equal to ServerToAgent.instance_uid field) or any other value
       *   that uniquely identifies the Agent in combination with other attributes.
       * - any other attributes that are necessary for uniquely identifying the Agent's
       *   own telemetry.
       * The Agent SHOULD also include these attributes in the Resource of its own
       * telemetry. The combination of identifying attributes SHOULD be sufficient to
       * uniquely identify the Agent's own telemetry in the destination system to which
       * the Agent sends its own telemetry.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue identifying_attributes = 1;</code>
       */
      public java.util.List<opamp.proto.Anyvalue.KeyValue.Builder> 
           getIdentifyingAttributesBuilderList() {
        return getIdentifyingAttributesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          opamp.proto.Anyvalue.KeyValue, opamp.proto.Anyvalue.KeyValue.Builder, opamp.proto.Anyvalue.KeyValueOrBuilder> 
          getIdentifyingAttributesFieldBuilder() {
        if (identifyingAttributesBuilder_ == null) {
          identifyingAttributesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              opamp.proto.Anyvalue.KeyValue, opamp.proto.Anyvalue.KeyValue.Builder, opamp.proto.Anyvalue.KeyValueOrBuilder>(
                  identifyingAttributes_,
                  ((bitField0_ & 0x00000001) != 0),
                  getParentForChildren(),
                  isClean());
          identifyingAttributes_ = null;
        }
        return identifyingAttributesBuilder_;
      }

      private java.util.List<opamp.proto.Anyvalue.KeyValue> nonIdentifyingAttributes_ =
        java.util.Collections.emptyList();
      private void ensureNonIdentifyingAttributesIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          nonIdentifyingAttributes_ = new java.util.ArrayList<opamp.proto.Anyvalue.KeyValue>(nonIdentifyingAttributes_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          opamp.proto.Anyvalue.KeyValue, opamp.proto.Anyvalue.KeyValue.Builder, opamp.proto.Anyvalue.KeyValueOrBuilder> nonIdentifyingAttributesBuilder_;

      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public java.util.List<opamp.proto.Anyvalue.KeyValue> getNonIdentifyingAttributesList() {
        if (nonIdentifyingAttributesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(nonIdentifyingAttributes_);
        } else {
          return nonIdentifyingAttributesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public int getNonIdentifyingAttributesCount() {
        if (nonIdentifyingAttributesBuilder_ == null) {
          return nonIdentifyingAttributes_.size();
        } else {
          return nonIdentifyingAttributesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public opamp.proto.Anyvalue.KeyValue getNonIdentifyingAttributes(int index) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          return nonIdentifyingAttributes_.get(index);
        } else {
          return nonIdentifyingAttributesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder setNonIdentifyingAttributes(
          int index, opamp.proto.Anyvalue.KeyValue value) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.set(index, value);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder setNonIdentifyingAttributes(
          int index, opamp.proto.Anyvalue.KeyValue.Builder builderForValue) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.set(index, builderForValue.build());
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addNonIdentifyingAttributes(opamp.proto.Anyvalue.KeyValue value) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.add(value);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addNonIdentifyingAttributes(
          int index, opamp.proto.Anyvalue.KeyValue value) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.add(index, value);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addNonIdentifyingAttributes(
          opamp.proto.Anyvalue.KeyValue.Builder builderForValue) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.add(builderForValue.build());
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addNonIdentifyingAttributes(
          int index, opamp.proto.Anyvalue.KeyValue.Builder builderForValue) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.add(index, builderForValue.build());
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder addAllNonIdentifyingAttributes(
          java.lang.Iterable<? extends opamp.proto.Anyvalue.KeyValue> values) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, nonIdentifyingAttributes_);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder clearNonIdentifyingAttributes() {
        if (nonIdentifyingAttributesBuilder_ == null) {
          nonIdentifyingAttributes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public Builder removeNonIdentifyingAttributes(int index) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          ensureNonIdentifyingAttributesIsMutable();
          nonIdentifyingAttributes_.remove(index);
          onChanged();
        } else {
          nonIdentifyingAttributesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public opamp.proto.Anyvalue.KeyValue.Builder getNonIdentifyingAttributesBuilder(
          int index) {
        return getNonIdentifyingAttributesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public opamp.proto.Anyvalue.KeyValueOrBuilder getNonIdentifyingAttributesOrBuilder(
          int index) {
        if (nonIdentifyingAttributesBuilder_ == null) {
          return nonIdentifyingAttributes_.get(index);  } else {
          return nonIdentifyingAttributesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public java.util.List<? extends opamp.proto.Anyvalue.KeyValueOrBuilder> 
           getNonIdentifyingAttributesOrBuilderList() {
        if (nonIdentifyingAttributesBuilder_ != null) {
          return nonIdentifyingAttributesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(nonIdentifyingAttributes_);
        }
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public opamp.proto.Anyvalue.KeyValue.Builder addNonIdentifyingAttributesBuilder() {
        return getNonIdentifyingAttributesFieldBuilder().addBuilder(
            opamp.proto.Anyvalue.KeyValue.getDefaultInstance());
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public opamp.proto.Anyvalue.KeyValue.Builder addNonIdentifyingAttributesBuilder(
          int index) {
        return getNonIdentifyingAttributesFieldBuilder().addBuilder(
            index, opamp.proto.Anyvalue.KeyValue.getDefaultInstance());
      }
      /**
       * <pre>
       * Attributes that do not necessarily identify the Agent but help describe
       * where it runs.
       * The following attributes SHOULD be included:
       * - os.type, os.version - to describe where the Agent runs.
       * - host.* to describe the host the Agent runs on.
       * - cloud.* to describe the cloud where the host is located.
       * - any other relevant Resource attributes that describe this Agent and the
       *   environment it runs in.
       * - any user-defined attributes that the end user would like to associate
       *   with this Agent.
       * </pre>
       *
       * <code>repeated .opamp.proto.KeyValue non_identifying_attributes = 2;</code>
       */
      public java.util.List<opamp.proto.Anyvalue.KeyValue.Builder> 
           getNonIdentifyingAttributesBuilderList() {
        return getNonIdentifyingAttributesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          opamp.proto.Anyvalue.KeyValue, opamp.proto.Anyvalue.KeyValue.Builder, opamp.proto.Anyvalue.KeyValueOrBuilder> 
          getNonIdentifyingAttributesFieldBuilder() {
        if (nonIdentifyingAttributesBuilder_ == null) {
          nonIdentifyingAttributesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              opamp.proto.Anyvalue.KeyValue, opamp.proto.Anyvalue.KeyValue.Builder, opamp.proto.Anyvalue.KeyValueOrBuilder>(
                  nonIdentifyingAttributes_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          nonIdentifyingAttributes_ = null;
        }
        return nonIdentifyingAttributesBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentDescription)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentDescription)
    private static final opamp.proto.Opamp.AgentDescription DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.AgentDescription();
    }

    public static opamp.proto.Opamp.AgentDescription getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentDescription>
        PARSER = new com.google.protobuf.AbstractParser<AgentDescription>() {
      @java.lang.Override
      public AgentDescription parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AgentDescription(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AgentDescription> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AgentDescription> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.AgentDescription getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AgentHealthOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentHealth)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Set to true if the Agent is up and running.
     * </pre>
     *
     * <code>bool up = 1;</code>
     * @return The up.
     */
    boolean getUp();

    /**
     * <pre>
     * Timestamp since the Agent is up, i.e. when the agent was started.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
     * If "up" is false this field is unused.
     * </pre>
     *
     * <code>fixed64 start_time_unix_nano = 2;</code>
     * @return The startTimeUnixNano.
     */
    long getStartTimeUnixNano();

    /**
     * <pre>
     * Human-readable error message if the Agent is in erroneous state. Typically set
     * when up==false.
     * </pre>
     *
     * <code>string last_error = 3;</code>
     * @return The lastError.
     */
    java.lang.String getLastError();
    /**
     * <pre>
     * Human-readable error message if the Agent is in erroneous state. Typically set
     * when up==false.
     * </pre>
     *
     * <code>string last_error = 3;</code>
     * @return The bytes for lastError.
     */
    com.google.protobuf.ByteString
        getLastErrorBytes();
  }
  /**
   * <pre>
   * The health of the Agent.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.AgentHealth}
   */
  public static final class AgentHealth extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentHealth)
      AgentHealthOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AgentHealth.newBuilder() to construct.
    private AgentHealth(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AgentHealth() {
      lastError_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AgentHealth();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AgentHealth(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 8: {

              up_ = input.readBool();
              break;
            }
            case 17: {

              startTimeUnixNano_ = input.readFixed64();
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              lastError_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentHealth_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentHealth_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.AgentHealth.class, opamp.proto.Opamp.AgentHealth.Builder.class);
    }

    public static final int UP_FIELD_NUMBER = 1;
    private boolean up_;
    /**
     * <pre>
     * Set to true if the Agent is up and running.
     * </pre>
     *
     * <code>bool up = 1;</code>
     * @return The up.
     */
    @java.lang.Override
    public boolean getUp() {
      return up_;
    }

    public static final int START_TIME_UNIX_NANO_FIELD_NUMBER = 2;
    private long startTimeUnixNano_;
    /**
     * <pre>
     * Timestamp since the Agent is up, i.e. when the agent was started.
     * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
     * If "up" is false this field is unused.
     * </pre>
     *
     * <code>fixed64 start_time_unix_nano = 2;</code>
     * @return The startTimeUnixNano.
     */
    @java.lang.Override
    public long getStartTimeUnixNano() {
      return startTimeUnixNano_;
    }

    public static final int LAST_ERROR_FIELD_NUMBER = 3;
    private volatile java.lang.Object lastError_;
    /**
     * <pre>
     * Human-readable error message if the Agent is in erroneous state. Typically set
     * when up==false.
     * </pre>
     *
     * <code>string last_error = 3;</code>
     * @return The lastError.
     */
    @java.lang.Override
    public java.lang.String getLastError() {
      java.lang.Object ref = lastError_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        lastError_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Human-readable error message if the Agent is in erroneous state. Typically set
     * when up==false.
     * </pre>
     *
     * <code>string last_error = 3;</code>
     * @return The bytes for lastError.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLastErrorBytes() {
      java.lang.Object ref = lastError_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        lastError_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (up_ != false) {
        output.writeBool(1, up_);
      }
      if (startTimeUnixNano_ != 0L) {
        output.writeFixed64(2, startTimeUnixNano_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(lastError_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, lastError_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (up_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, up_);
      }
      if (startTimeUnixNano_ != 0L) {
        size += com.google.protobuf.CodedOutputStream
          .computeFixed64Size(2, startTimeUnixNano_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(lastError_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, lastError_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.AgentHealth)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.AgentHealth other = (opamp.proto.Opamp.AgentHealth) obj;

      if (getUp()
          != other.getUp()) return false;
      if (getStartTimeUnixNano()
          != other.getStartTimeUnixNano()) return false;
      if (!getLastError()
          .equals(other.getLastError())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + UP_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getUp());
      hash = (37 * hash) + START_TIME_UNIX_NANO_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getStartTimeUnixNano());
      hash = (37 * hash) + LAST_ERROR_FIELD_NUMBER;
      hash = (53 * hash) + getLastError().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.AgentHealth parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentHealth parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentHealth parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentHealth parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentHealth parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentHealth parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentHealth parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentHealth parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentHealth parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentHealth parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentHealth parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentHealth parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.AgentHealth prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The health of the Agent.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.AgentHealth}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentHealth)
        opamp.proto.Opamp.AgentHealthOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentHealth_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentHealth_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.AgentHealth.class, opamp.proto.Opamp.AgentHealth.Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentHealth.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        up_ = false;

        startTimeUnixNano_ = 0L;

        lastError_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentHealth_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentHealth getDefaultInstanceForType() {
        return opamp.proto.Opamp.AgentHealth.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentHealth build() {
        opamp.proto.Opamp.AgentHealth result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentHealth buildPartial() {
        opamp.proto.Opamp.AgentHealth result = new opamp.proto.Opamp.AgentHealth(this);
        result.up_ = up_;
        result.startTimeUnixNano_ = startTimeUnixNano_;
        result.lastError_ = lastError_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.AgentHealth) {
          return mergeFrom((opamp.proto.Opamp.AgentHealth)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.AgentHealth other) {
        if (other == opamp.proto.Opamp.AgentHealth.getDefaultInstance()) return this;
        if (other.getUp() != false) {
          setUp(other.getUp());
        }
        if (other.getStartTimeUnixNano() != 0L) {
          setStartTimeUnixNano(other.getStartTimeUnixNano());
        }
        if (!other.getLastError().isEmpty()) {
          lastError_ = other.lastError_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.AgentHealth parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.AgentHealth) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private boolean up_ ;
      /**
       * <pre>
       * Set to true if the Agent is up and running.
       * </pre>
       *
       * <code>bool up = 1;</code>
       * @return The up.
       */
      @java.lang.Override
      public boolean getUp() {
        return up_;
      }
      /**
       * <pre>
       * Set to true if the Agent is up and running.
       * </pre>
       *
       * <code>bool up = 1;</code>
       * @param value The up to set.
       * @return This builder for chaining.
       */
      public Builder setUp(boolean value) {
        
        up_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Set to true if the Agent is up and running.
       * </pre>
       *
       * <code>bool up = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearUp() {
        
        up_ = false;
        onChanged();
        return this;
      }

      private long startTimeUnixNano_ ;
      /**
       * <pre>
       * Timestamp since the Agent is up, i.e. when the agent was started.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       * If "up" is false this field is unused.
       * </pre>
       *
       * <code>fixed64 start_time_unix_nano = 2;</code>
       * @return The startTimeUnixNano.
       */
      @java.lang.Override
      public long getStartTimeUnixNano() {
        return startTimeUnixNano_;
      }
      /**
       * <pre>
       * Timestamp since the Agent is up, i.e. when the agent was started.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       * If "up" is false this field is unused.
       * </pre>
       *
       * <code>fixed64 start_time_unix_nano = 2;</code>
       * @param value The startTimeUnixNano to set.
       * @return This builder for chaining.
       */
      public Builder setStartTimeUnixNano(long value) {
        
        startTimeUnixNano_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Timestamp since the Agent is up, i.e. when the agent was started.
       * Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
       * If "up" is false this field is unused.
       * </pre>
       *
       * <code>fixed64 start_time_unix_nano = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStartTimeUnixNano() {
        
        startTimeUnixNano_ = 0L;
        onChanged();
        return this;
      }

      private java.lang.Object lastError_ = "";
      /**
       * <pre>
       * Human-readable error message if the Agent is in erroneous state. Typically set
       * when up==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       * @return The lastError.
       */
      public java.lang.String getLastError() {
        java.lang.Object ref = lastError_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          lastError_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Human-readable error message if the Agent is in erroneous state. Typically set
       * when up==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       * @return The bytes for lastError.
       */
      public com.google.protobuf.ByteString
          getLastErrorBytes() {
        java.lang.Object ref = lastError_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          lastError_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Human-readable error message if the Agent is in erroneous state. Typically set
       * when up==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       * @param value The lastError to set.
       * @return This builder for chaining.
       */
      public Builder setLastError(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        lastError_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Human-readable error message if the Agent is in erroneous state. Typically set
       * when up==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastError() {
        
        lastError_ = getDefaultInstance().getLastError();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Human-readable error message if the Agent is in erroneous state. Typically set
       * when up==false.
       * </pre>
       *
       * <code>string last_error = 3;</code>
       * @param value The bytes for lastError to set.
       * @return This builder for chaining.
       */
      public Builder setLastErrorBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        lastError_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentHealth)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentHealth)
    private static final opamp.proto.Opamp.AgentHealth DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.AgentHealth();
    }

    public static opamp.proto.Opamp.AgentHealth getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentHealth>
        PARSER = new com.google.protobuf.AbstractParser<AgentHealth>() {
      @java.lang.Override
      public AgentHealth parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AgentHealth(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AgentHealth> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AgentHealth> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.AgentHealth getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface EffectiveConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.EffectiveConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     * @return Whether the configMap field is set.
     */
    boolean hasConfigMap();
    /**
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     * @return The configMap.
     */
    opamp.proto.Opamp.AgentConfigMap getConfigMap();
    /**
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     */
    opamp.proto.Opamp.AgentConfigMapOrBuilder getConfigMapOrBuilder();
  }
  /**
   * Protobuf type {@code opamp.proto.EffectiveConfig}
   */
  public static final class EffectiveConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.EffectiveConfig)
      EffectiveConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use EffectiveConfig.newBuilder() to construct.
    private EffectiveConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private EffectiveConfig() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new EffectiveConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private EffectiveConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              opamp.proto.Opamp.AgentConfigMap.Builder subBuilder = null;
              if (configMap_ != null) {
                subBuilder = configMap_.toBuilder();
              }
              configMap_ = input.readMessage(opamp.proto.Opamp.AgentConfigMap.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(configMap_);
                configMap_ = subBuilder.buildPartial();
              }

              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_EffectiveConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_EffectiveConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.EffectiveConfig.class, opamp.proto.Opamp.EffectiveConfig.Builder.class);
    }

    public static final int CONFIG_MAP_FIELD_NUMBER = 1;
    private opamp.proto.Opamp.AgentConfigMap configMap_;
    /**
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     * @return Whether the configMap field is set.
     */
    @java.lang.Override
    public boolean hasConfigMap() {
      return configMap_ != null;
    }
    /**
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     * @return The configMap.
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentConfigMap getConfigMap() {
      return configMap_ == null ? opamp.proto.Opamp.AgentConfigMap.getDefaultInstance() : configMap_;
    }
    /**
     * <pre>
     * The effective config of the Agent.
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentConfigMapOrBuilder getConfigMapOrBuilder() {
      return getConfigMap();
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (configMap_ != null) {
        output.writeMessage(1, getConfigMap());
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (configMap_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getConfigMap());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.EffectiveConfig)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.EffectiveConfig other = (opamp.proto.Opamp.EffectiveConfig) obj;

      if (hasConfigMap() != other.hasConfigMap()) return false;
      if (hasConfigMap()) {
        if (!getConfigMap()
            .equals(other.getConfigMap())) return false;
      }
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasConfigMap()) {
        hash = (37 * hash) + CONFIG_MAP_FIELD_NUMBER;
        hash = (53 * hash) + getConfigMap().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.EffectiveConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.EffectiveConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.EffectiveConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.EffectiveConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.EffectiveConfig)
        opamp.proto.Opamp.EffectiveConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_EffectiveConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_EffectiveConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.EffectiveConfig.class, opamp.proto.Opamp.EffectiveConfig.Builder.class);
      }

      // Construct using opamp.proto.Opamp.EffectiveConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (configMapBuilder_ == null) {
          configMap_ = null;
        } else {
          configMap_ = null;
          configMapBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_EffectiveConfig_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.EffectiveConfig getDefaultInstanceForType() {
        return opamp.proto.Opamp.EffectiveConfig.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.EffectiveConfig build() {
        opamp.proto.Opamp.EffectiveConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.EffectiveConfig buildPartial() {
        opamp.proto.Opamp.EffectiveConfig result = new opamp.proto.Opamp.EffectiveConfig(this);
        if (configMapBuilder_ == null) {
          result.configMap_ = configMap_;
        } else {
          result.configMap_ = configMapBuilder_.build();
        }
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.EffectiveConfig) {
          return mergeFrom((opamp.proto.Opamp.EffectiveConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.EffectiveConfig other) {
        if (other == opamp.proto.Opamp.EffectiveConfig.getDefaultInstance()) return this;
        if (other.hasConfigMap()) {
          mergeConfigMap(other.getConfigMap());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.EffectiveConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.EffectiveConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private opamp.proto.Opamp.AgentConfigMap configMap_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentConfigMap, opamp.proto.Opamp.AgentConfigMap.Builder, opamp.proto.Opamp.AgentConfigMapOrBuilder> configMapBuilder_;
      /**
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       * @return Whether the configMap field is set.
       */
      public boolean hasConfigMap() {
        return configMapBuilder_ != null || configMap_ != null;
      }
      /**
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       * @return The configMap.
       */
      public opamp.proto.Opamp.AgentConfigMap getConfigMap() {
        if (configMapBuilder_ == null) {
          return configMap_ == null ? opamp.proto.Opamp.AgentConfigMap.getDefaultInstance() : configMap_;
        } else {
          return configMapBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public Builder setConfigMap(opamp.proto.Opamp.AgentConfigMap value) {
        if (configMapBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          configMap_ = value;
          onChanged();
        } else {
          configMapBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public Builder setConfigMap(
          opamp.proto.Opamp.AgentConfigMap.Builder builderForValue) {
        if (configMapBuilder_ == null) {
          configMap_ = builderForValue.build();
          onChanged();
        } else {
          configMapBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public Builder mergeConfigMap(opamp.proto.Opamp.AgentConfigMap value) {
        if (configMapBuilder_ == null) {
          if (configMap_ != null) {
            configMap_ =
              opamp.proto.Opamp.AgentConfigMap.newBuilder(configMap_).mergeFrom(value).buildPartial();
          } else {
            configMap_ = value;
          }
          onChanged();
        } else {
          configMapBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public Builder clearConfigMap() {
        if (configMapBuilder_ == null) {
          configMap_ = null;
          onChanged();
        } else {
          configMap_ = null;
          configMapBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public opamp.proto.Opamp.AgentConfigMap.Builder getConfigMapBuilder() {
        
        onChanged();
        return getConfigMapFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      public opamp.proto.Opamp.AgentConfigMapOrBuilder getConfigMapOrBuilder() {
        if (configMapBuilder_ != null) {
          return configMapBuilder_.getMessageOrBuilder();
        } else {
          return configMap_ == null ?
              opamp.proto.Opamp.AgentConfigMap.getDefaultInstance() : configMap_;
        }
      }
      /**
       * <pre>
       * The effective config of the Agent.
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config_map = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentConfigMap, opamp.proto.Opamp.AgentConfigMap.Builder, opamp.proto.Opamp.AgentConfigMapOrBuilder> 
          getConfigMapFieldBuilder() {
        if (configMapBuilder_ == null) {
          configMapBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.AgentConfigMap, opamp.proto.Opamp.AgentConfigMap.Builder, opamp.proto.Opamp.AgentConfigMapOrBuilder>(
                  getConfigMap(),
                  getParentForChildren(),
                  isClean());
          configMap_ = null;
        }
        return configMapBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.EffectiveConfig)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.EffectiveConfig)
    private static final opamp.proto.Opamp.EffectiveConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.EffectiveConfig();
    }

    public static opamp.proto.Opamp.EffectiveConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<EffectiveConfig>
        PARSER = new com.google.protobuf.AbstractParser<EffectiveConfig>() {
      @java.lang.Override
      public EffectiveConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new EffectiveConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<EffectiveConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<EffectiveConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.EffectiveConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RemoteConfigStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.RemoteConfigStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The hash of the remote config that was last received by this Agent in the
     * AgentRemoteConfig.config_hash field.
     * The Server SHOULD compare this hash with the config hash
     * it has for the Agent and if the hashes are different the Server MUST include
     * the remote_config field in the response in the ServerToAgent message.
     * </pre>
     *
     * <code>bytes last_remote_config_hash = 1;</code>
     * @return The lastRemoteConfigHash.
     */
    com.google.protobuf.ByteString getLastRemoteConfigHash();

    /**
     * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
     * @return The enum numeric value on the wire for status.
     */
    int getStatusValue();
    /**
     * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
     * @return The status.
     */
    opamp.proto.Opamp.RemoteConfigStatuses getStatus();

    /**
     * <pre>
     * Optional error message if status==FAILED.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     * @return The errorMessage.
     */
    java.lang.String getErrorMessage();
    /**
     * <pre>
     * Optional error message if status==FAILED.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     * @return The bytes for errorMessage.
     */
    com.google.protobuf.ByteString
        getErrorMessageBytes();
  }
  /**
   * Protobuf type {@code opamp.proto.RemoteConfigStatus}
   */
  public static final class RemoteConfigStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.RemoteConfigStatus)
      RemoteConfigStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RemoteConfigStatus.newBuilder() to construct.
    private RemoteConfigStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RemoteConfigStatus() {
      lastRemoteConfigHash_ = com.google.protobuf.ByteString.EMPTY;
      status_ = 0;
      errorMessage_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new RemoteConfigStatus();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RemoteConfigStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {

              lastRemoteConfigHash_ = input.readBytes();
              break;
            }
            case 16: {
              int rawValue = input.readEnum();

              status_ = rawValue;
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              errorMessage_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_RemoteConfigStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_RemoteConfigStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.RemoteConfigStatus.class, opamp.proto.Opamp.RemoteConfigStatus.Builder.class);
    }

    public static final int LAST_REMOTE_CONFIG_HASH_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString lastRemoteConfigHash_;
    /**
     * <pre>
     * The hash of the remote config that was last received by this Agent in the
     * AgentRemoteConfig.config_hash field.
     * The Server SHOULD compare this hash with the config hash
     * it has for the Agent and if the hashes are different the Server MUST include
     * the remote_config field in the response in the ServerToAgent message.
     * </pre>
     *
     * <code>bytes last_remote_config_hash = 1;</code>
     * @return The lastRemoteConfigHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getLastRemoteConfigHash() {
      return lastRemoteConfigHash_;
    }

    public static final int STATUS_FIELD_NUMBER = 2;
    private int status_;
    /**
     * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
     * @return The enum numeric value on the wire for status.
     */
    @java.lang.Override public int getStatusValue() {
      return status_;
    }
    /**
     * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
     * @return The status.
     */
    @java.lang.Override public opamp.proto.Opamp.RemoteConfigStatuses getStatus() {
      @SuppressWarnings("deprecation")
      opamp.proto.Opamp.RemoteConfigStatuses result = opamp.proto.Opamp.RemoteConfigStatuses.valueOf(status_);
      return result == null ? opamp.proto.Opamp.RemoteConfigStatuses.UNRECOGNIZED : result;
    }

    public static final int ERROR_MESSAGE_FIELD_NUMBER = 3;
    private volatile java.lang.Object errorMessage_;
    /**
     * <pre>
     * Optional error message if status==FAILED.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     * @return The errorMessage.
     */
    @java.lang.Override
    public java.lang.String getErrorMessage() {
      java.lang.Object ref = errorMessage_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        errorMessage_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Optional error message if status==FAILED.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     * @return The bytes for errorMessage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getErrorMessageBytes() {
      java.lang.Object ref = errorMessage_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        errorMessage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!lastRemoteConfigHash_.isEmpty()) {
        output.writeBytes(1, lastRemoteConfigHash_);
      }
      if (status_ != opamp.proto.Opamp.RemoteConfigStatuses.RemoteConfigStatuses_UNSET.getNumber()) {
        output.writeEnum(2, status_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, errorMessage_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!lastRemoteConfigHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, lastRemoteConfigHash_);
      }
      if (status_ != opamp.proto.Opamp.RemoteConfigStatuses.RemoteConfigStatuses_UNSET.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, status_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, errorMessage_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.RemoteConfigStatus)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.RemoteConfigStatus other = (opamp.proto.Opamp.RemoteConfigStatus) obj;

      if (!getLastRemoteConfigHash()
          .equals(other.getLastRemoteConfigHash())) return false;
      if (status_ != other.status_) return false;
      if (!getErrorMessage()
          .equals(other.getErrorMessage())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + LAST_REMOTE_CONFIG_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getLastRemoteConfigHash().hashCode();
      hash = (37 * hash) + STATUS_FIELD_NUMBER;
      hash = (53 * hash) + status_;
      hash = (37 * hash) + ERROR_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getErrorMessage().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.RemoteConfigStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.RemoteConfigStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.RemoteConfigStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.RemoteConfigStatus)
        opamp.proto.Opamp.RemoteConfigStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_RemoteConfigStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_RemoteConfigStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.RemoteConfigStatus.class, opamp.proto.Opamp.RemoteConfigStatus.Builder.class);
      }

      // Construct using opamp.proto.Opamp.RemoteConfigStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        lastRemoteConfigHash_ = com.google.protobuf.ByteString.EMPTY;

        status_ = 0;

        errorMessage_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_RemoteConfigStatus_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.RemoteConfigStatus getDefaultInstanceForType() {
        return opamp.proto.Opamp.RemoteConfigStatus.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.RemoteConfigStatus build() {
        opamp.proto.Opamp.RemoteConfigStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.RemoteConfigStatus buildPartial() {
        opamp.proto.Opamp.RemoteConfigStatus result = new opamp.proto.Opamp.RemoteConfigStatus(this);
        result.lastRemoteConfigHash_ = lastRemoteConfigHash_;
        result.status_ = status_;
        result.errorMessage_ = errorMessage_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.RemoteConfigStatus) {
          return mergeFrom((opamp.proto.Opamp.RemoteConfigStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.RemoteConfigStatus other) {
        if (other == opamp.proto.Opamp.RemoteConfigStatus.getDefaultInstance()) return this;
        if (other.getLastRemoteConfigHash() != com.google.protobuf.ByteString.EMPTY) {
          setLastRemoteConfigHash(other.getLastRemoteConfigHash());
        }
        if (other.status_ != 0) {
          setStatusValue(other.getStatusValue());
        }
        if (!other.getErrorMessage().isEmpty()) {
          errorMessage_ = other.errorMessage_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.RemoteConfigStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.RemoteConfigStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.ByteString lastRemoteConfigHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The hash of the remote config that was last received by this Agent in the
       * AgentRemoteConfig.config_hash field.
       * The Server SHOULD compare this hash with the config hash
       * it has for the Agent and if the hashes are different the Server MUST include
       * the remote_config field in the response in the ServerToAgent message.
       * </pre>
       *
       * <code>bytes last_remote_config_hash = 1;</code>
       * @return The lastRemoteConfigHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getLastRemoteConfigHash() {
        return lastRemoteConfigHash_;
      }
      /**
       * <pre>
       * The hash of the remote config that was last received by this Agent in the
       * AgentRemoteConfig.config_hash field.
       * The Server SHOULD compare this hash with the config hash
       * it has for the Agent and if the hashes are different the Server MUST include
       * the remote_config field in the response in the ServerToAgent message.
       * </pre>
       *
       * <code>bytes last_remote_config_hash = 1;</code>
       * @param value The lastRemoteConfigHash to set.
       * @return This builder for chaining.
       */
      public Builder setLastRemoteConfigHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        lastRemoteConfigHash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash of the remote config that was last received by this Agent in the
       * AgentRemoteConfig.config_hash field.
       * The Server SHOULD compare this hash with the config hash
       * it has for the Agent and if the hashes are different the Server MUST include
       * the remote_config field in the response in the ServerToAgent message.
       * </pre>
       *
       * <code>bytes last_remote_config_hash = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearLastRemoteConfigHash() {
        
        lastRemoteConfigHash_ = getDefaultInstance().getLastRemoteConfigHash();
        onChanged();
        return this;
      }

      private int status_ = 0;
      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       * @return The enum numeric value on the wire for status.
       */
      @java.lang.Override public int getStatusValue() {
        return status_;
      }
      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       * @param value The enum numeric value on the wire for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusValue(int value) {
        
        status_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       * @return The status.
       */
      @java.lang.Override
      public opamp.proto.Opamp.RemoteConfigStatuses getStatus() {
        @SuppressWarnings("deprecation")
        opamp.proto.Opamp.RemoteConfigStatuses result = opamp.proto.Opamp.RemoteConfigStatuses.valueOf(status_);
        return result == null ? opamp.proto.Opamp.RemoteConfigStatuses.UNRECOGNIZED : result;
      }
      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(opamp.proto.Opamp.RemoteConfigStatuses value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        status_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.RemoteConfigStatuses status = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        
        status_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object errorMessage_ = "";
      /**
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @return The errorMessage.
       */
      public java.lang.String getErrorMessage() {
        java.lang.Object ref = errorMessage_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          errorMessage_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @return The bytes for errorMessage.
       */
      public com.google.protobuf.ByteString
          getErrorMessageBytes() {
        java.lang.Object ref = errorMessage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          errorMessage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @param value The errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        errorMessage_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearErrorMessage() {
        
        errorMessage_ = getDefaultInstance().getErrorMessage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional error message if status==FAILED.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @param value The bytes for errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        errorMessage_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.RemoteConfigStatus)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.RemoteConfigStatus)
    private static final opamp.proto.Opamp.RemoteConfigStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.RemoteConfigStatus();
    }

    public static opamp.proto.Opamp.RemoteConfigStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RemoteConfigStatus>
        PARSER = new com.google.protobuf.AbstractParser<RemoteConfigStatus>() {
      @java.lang.Override
      public RemoteConfigStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RemoteConfigStatus(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RemoteConfigStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RemoteConfigStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.RemoteConfigStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PackageStatusesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.PackageStatuses)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    int getPackagesCount();
    /**
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    boolean containsPackages(
        java.lang.String key);
    /**
     * Use {@link #getPackagesMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus>
    getPackages();
    /**
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus>
    getPackagesMap();
    /**
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */

    opamp.proto.Opamp.PackageStatus getPackagesOrDefault(
        java.lang.String key,
        opamp.proto.Opamp.PackageStatus defaultValue);
    /**
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */

    opamp.proto.Opamp.PackageStatus getPackagesOrThrow(
        java.lang.String key);

    /**
     * <pre>
     * The aggregate hash of all packages that this Agent previously received from the
     * Server via PackagesAvailable message.
     * The Server SHOULD compare this hash to the aggregate hash of all packages that
     * it has for this Agent and if the hashes are different the Server SHOULD send
     * an PackagesAvailable message to the Agent.
     * </pre>
     *
     * <code>bytes server_provided_all_packages_hash = 2;</code>
     * @return The serverProvidedAllPackagesHash.
     */
    com.google.protobuf.ByteString getServerProvidedAllPackagesHash();

    /**
     * <pre>
     * This field is set if the Agent encountered an error when processing the
     * PackagesAvailable message and that error is not related to any particular single
     * package.
     * The field must be unset is there were no processing errors.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     * @return The errorMessage.
     */
    java.lang.String getErrorMessage();
    /**
     * <pre>
     * This field is set if the Agent encountered an error when processing the
     * PackagesAvailable message and that error is not related to any particular single
     * package.
     * The field must be unset is there were no processing errors.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     * @return The bytes for errorMessage.
     */
    com.google.protobuf.ByteString
        getErrorMessageBytes();
  }
  /**
   * <pre>
   * The PackageStatuses message describes the status of all packages that the Agent
   * has or was offered.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.PackageStatuses}
   */
  public static final class PackageStatuses extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.PackageStatuses)
      PackageStatusesOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PackageStatuses.newBuilder() to construct.
    private PackageStatuses(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PackageStatuses() {
      serverProvidedAllPackagesHash_ = com.google.protobuf.ByteString.EMPTY;
      errorMessage_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PackageStatuses();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PackageStatuses(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                packages_ = com.google.protobuf.MapField.newMapField(
                    PackagesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.String, opamp.proto.Opamp.PackageStatus>
              packages__ = input.readMessage(
                  PackagesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              packages_.getMutableMap().put(
                  packages__.getKey(), packages__.getValue());
              break;
            }
            case 18: {

              serverProvidedAllPackagesHash_ = input.readBytes();
              break;
            }
            case 26: {
              java.lang.String s = input.readStringRequireUtf8();

              errorMessage_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatuses_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetPackages();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatuses_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.PackageStatuses.class, opamp.proto.Opamp.PackageStatuses.Builder.class);
    }

    public static final int PACKAGES_FIELD_NUMBER = 1;
    private static final class PackagesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, opamp.proto.Opamp.PackageStatus> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, opamp.proto.Opamp.PackageStatus>newDefaultInstance(
                  opamp.proto.Opamp.internal_static_opamp_proto_PackageStatuses_PackagesEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  opamp.proto.Opamp.PackageStatus.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.String, opamp.proto.Opamp.PackageStatus> packages_;
    private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.PackageStatus>
    internalGetPackages() {
      if (packages_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            PackagesDefaultEntryHolder.defaultEntry);
      }
      return packages_;
    }

    public int getPackagesCount() {
      return internalGetPackages().getMap().size();
    }
    /**
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */

    @java.lang.Override
    public boolean containsPackages(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetPackages().getMap().containsKey(key);
    }
    /**
     * Use {@link #getPackagesMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus> getPackages() {
      return getPackagesMap();
    }
    /**
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus> getPackagesMap() {
      return internalGetPackages().getMap();
    }
    /**
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    @java.lang.Override

    public opamp.proto.Opamp.PackageStatus getPackagesOrDefault(
        java.lang.String key,
        opamp.proto.Opamp.PackageStatus defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus> map =
          internalGetPackages().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * A map of PackageStatus messages, where the keys are package names.
     * The key MUST match the name field of PackageStatus message.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
     */
    @java.lang.Override

    public opamp.proto.Opamp.PackageStatus getPackagesOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus> map =
          internalGetPackages().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int SERVER_PROVIDED_ALL_PACKAGES_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString serverProvidedAllPackagesHash_;
    /**
     * <pre>
     * The aggregate hash of all packages that this Agent previously received from the
     * Server via PackagesAvailable message.
     * The Server SHOULD compare this hash to the aggregate hash of all packages that
     * it has for this Agent and if the hashes are different the Server SHOULD send
     * an PackagesAvailable message to the Agent.
     * </pre>
     *
     * <code>bytes server_provided_all_packages_hash = 2;</code>
     * @return The serverProvidedAllPackagesHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getServerProvidedAllPackagesHash() {
      return serverProvidedAllPackagesHash_;
    }

    public static final int ERROR_MESSAGE_FIELD_NUMBER = 3;
    private volatile java.lang.Object errorMessage_;
    /**
     * <pre>
     * This field is set if the Agent encountered an error when processing the
     * PackagesAvailable message and that error is not related to any particular single
     * package.
     * The field must be unset is there were no processing errors.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     * @return The errorMessage.
     */
    @java.lang.Override
    public java.lang.String getErrorMessage() {
      java.lang.Object ref = errorMessage_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        errorMessage_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * This field is set if the Agent encountered an error when processing the
     * PackagesAvailable message and that error is not related to any particular single
     * package.
     * The field must be unset is there were no processing errors.
     * </pre>
     *
     * <code>string error_message = 3;</code>
     * @return The bytes for errorMessage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getErrorMessageBytes() {
      java.lang.Object ref = errorMessage_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        errorMessage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetPackages(),
          PackagesDefaultEntryHolder.defaultEntry,
          1);
      if (!serverProvidedAllPackagesHash_.isEmpty()) {
        output.writeBytes(2, serverProvidedAllPackagesHash_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, errorMessage_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, opamp.proto.Opamp.PackageStatus> entry
           : internalGetPackages().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, opamp.proto.Opamp.PackageStatus>
        packages__ = PackagesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, packages__);
      }
      if (!serverProvidedAllPackagesHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, serverProvidedAllPackagesHash_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, errorMessage_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.PackageStatuses)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.PackageStatuses other = (opamp.proto.Opamp.PackageStatuses) obj;

      if (!internalGetPackages().equals(
          other.internalGetPackages())) return false;
      if (!getServerProvidedAllPackagesHash()
          .equals(other.getServerProvidedAllPackagesHash())) return false;
      if (!getErrorMessage()
          .equals(other.getErrorMessage())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetPackages().getMap().isEmpty()) {
        hash = (37 * hash) + PACKAGES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetPackages().hashCode();
      }
      hash = (37 * hash) + SERVER_PROVIDED_ALL_PACKAGES_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getServerProvidedAllPackagesHash().hashCode();
      hash = (37 * hash) + ERROR_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getErrorMessage().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.PackageStatuses parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackageStatuses parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatuses parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackageStatuses parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatuses parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackageStatuses parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatuses parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackageStatuses parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatuses parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackageStatuses parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatuses parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackageStatuses parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.PackageStatuses prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The PackageStatuses message describes the status of all packages that the Agent
     * has or was offered.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.PackageStatuses}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.PackageStatuses)
        opamp.proto.Opamp.PackageStatusesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatuses_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetPackages();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutablePackages();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatuses_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.PackageStatuses.class, opamp.proto.Opamp.PackageStatuses.Builder.class);
      }

      // Construct using opamp.proto.Opamp.PackageStatuses.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        internalGetMutablePackages().clear();
        serverProvidedAllPackagesHash_ = com.google.protobuf.ByteString.EMPTY;

        errorMessage_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatuses_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackageStatuses getDefaultInstanceForType() {
        return opamp.proto.Opamp.PackageStatuses.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackageStatuses build() {
        opamp.proto.Opamp.PackageStatuses result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackageStatuses buildPartial() {
        opamp.proto.Opamp.PackageStatuses result = new opamp.proto.Opamp.PackageStatuses(this);
        int from_bitField0_ = bitField0_;
        result.packages_ = internalGetPackages();
        result.packages_.makeImmutable();
        result.serverProvidedAllPackagesHash_ = serverProvidedAllPackagesHash_;
        result.errorMessage_ = errorMessage_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.PackageStatuses) {
          return mergeFrom((opamp.proto.Opamp.PackageStatuses)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.PackageStatuses other) {
        if (other == opamp.proto.Opamp.PackageStatuses.getDefaultInstance()) return this;
        internalGetMutablePackages().mergeFrom(
            other.internalGetPackages());
        if (other.getServerProvidedAllPackagesHash() != com.google.protobuf.ByteString.EMPTY) {
          setServerProvidedAllPackagesHash(other.getServerProvidedAllPackagesHash());
        }
        if (!other.getErrorMessage().isEmpty()) {
          errorMessage_ = other.errorMessage_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.PackageStatuses parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.PackageStatuses) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.String, opamp.proto.Opamp.PackageStatus> packages_;
      private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.PackageStatus>
      internalGetPackages() {
        if (packages_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              PackagesDefaultEntryHolder.defaultEntry);
        }
        return packages_;
      }
      private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.PackageStatus>
      internalGetMutablePackages() {
        onChanged();;
        if (packages_ == null) {
          packages_ = com.google.protobuf.MapField.newMapField(
              PackagesDefaultEntryHolder.defaultEntry);
        }
        if (!packages_.isMutable()) {
          packages_ = packages_.copy();
        }
        return packages_;
      }

      public int getPackagesCount() {
        return internalGetPackages().getMap().size();
      }
      /**
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */

      @java.lang.Override
      public boolean containsPackages(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetPackages().getMap().containsKey(key);
      }
      /**
       * Use {@link #getPackagesMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus> getPackages() {
        return getPackagesMap();
      }
      /**
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus> getPackagesMap() {
        return internalGetPackages().getMap();
      }
      /**
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      @java.lang.Override

      public opamp.proto.Opamp.PackageStatus getPackagesOrDefault(
          java.lang.String key,
          opamp.proto.Opamp.PackageStatus defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus> map =
            internalGetPackages().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      @java.lang.Override

      public opamp.proto.Opamp.PackageStatus getPackagesOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus> map =
            internalGetPackages().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearPackages() {
        internalGetMutablePackages().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */

      public Builder removePackages(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutablePackages().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus>
      getMutablePackages() {
        return internalGetMutablePackages().getMutableMap();
      }
      /**
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */
      public Builder putPackages(
          java.lang.String key,
          opamp.proto.Opamp.PackageStatus value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) {
  throw new NullPointerException("map value");
}

        internalGetMutablePackages().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * A map of PackageStatus messages, where the keys are package names.
       * The key MUST match the name field of PackageStatus message.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.PackageStatus&gt; packages = 1;</code>
       */

      public Builder putAllPackages(
          java.util.Map<java.lang.String, opamp.proto.Opamp.PackageStatus> values) {
        internalGetMutablePackages().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.ByteString serverProvidedAllPackagesHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The aggregate hash of all packages that this Agent previously received from the
       * Server via PackagesAvailable message.
       * The Server SHOULD compare this hash to the aggregate hash of all packages that
       * it has for this Agent and if the hashes are different the Server SHOULD send
       * an PackagesAvailable message to the Agent.
       * </pre>
       *
       * <code>bytes server_provided_all_packages_hash = 2;</code>
       * @return The serverProvidedAllPackagesHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getServerProvidedAllPackagesHash() {
        return serverProvidedAllPackagesHash_;
      }
      /**
       * <pre>
       * The aggregate hash of all packages that this Agent previously received from the
       * Server via PackagesAvailable message.
       * The Server SHOULD compare this hash to the aggregate hash of all packages that
       * it has for this Agent and if the hashes are different the Server SHOULD send
       * an PackagesAvailable message to the Agent.
       * </pre>
       *
       * <code>bytes server_provided_all_packages_hash = 2;</code>
       * @param value The serverProvidedAllPackagesHash to set.
       * @return This builder for chaining.
       */
      public Builder setServerProvidedAllPackagesHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        serverProvidedAllPackagesHash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The aggregate hash of all packages that this Agent previously received from the
       * Server via PackagesAvailable message.
       * The Server SHOULD compare this hash to the aggregate hash of all packages that
       * it has for this Agent and if the hashes are different the Server SHOULD send
       * an PackagesAvailable message to the Agent.
       * </pre>
       *
       * <code>bytes server_provided_all_packages_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearServerProvidedAllPackagesHash() {
        
        serverProvidedAllPackagesHash_ = getDefaultInstance().getServerProvidedAllPackagesHash();
        onChanged();
        return this;
      }

      private java.lang.Object errorMessage_ = "";
      /**
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @return The errorMessage.
       */
      public java.lang.String getErrorMessage() {
        java.lang.Object ref = errorMessage_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          errorMessage_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @return The bytes for errorMessage.
       */
      public com.google.protobuf.ByteString
          getErrorMessageBytes() {
        java.lang.Object ref = errorMessage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          errorMessage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @param value The errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        errorMessage_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearErrorMessage() {
        
        errorMessage_ = getDefaultInstance().getErrorMessage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is set if the Agent encountered an error when processing the
       * PackagesAvailable message and that error is not related to any particular single
       * package.
       * The field must be unset is there were no processing errors.
       * </pre>
       *
       * <code>string error_message = 3;</code>
       * @param value The bytes for errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        errorMessage_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.PackageStatuses)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.PackageStatuses)
    private static final opamp.proto.Opamp.PackageStatuses DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.PackageStatuses();
    }

    public static opamp.proto.Opamp.PackageStatuses getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackageStatuses>
        PARSER = new com.google.protobuf.AbstractParser<PackageStatuses>() {
      @java.lang.Override
      public PackageStatuses parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PackageStatuses(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PackageStatuses> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PackageStatuses> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.PackageStatuses getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PackageStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.PackageStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Package name. MUST be always set and MUST match the key in the packages field
     * of PackageStatuses message.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Package name. MUST be always set and MUST match the key in the packages field
     * of PackageStatuses message.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * The version of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case
     * for example if the package was offered by the Server but failed to install
     * and the Agent did not have this package previously.
     * </pre>
     *
     * <code>string agent_has_version = 2;</code>
     * @return The agentHasVersion.
     */
    java.lang.String getAgentHasVersion();
    /**
     * <pre>
     * The version of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case
     * for example if the package was offered by the Server but failed to install
     * and the Agent did not have this package previously.
     * </pre>
     *
     * <code>string agent_has_version = 2;</code>
     * @return The bytes for agentHasVersion.
     */
    com.google.protobuf.ByteString
        getAgentHasVersionBytes();

    /**
     * <pre>
     * The hash of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case for
     * example if the package was offered by the Server but failed to install and the
     * Agent did not have this package previously.
     * </pre>
     *
     * <code>bytes agent_has_hash = 3;</code>
     * @return The agentHasHash.
     */
    com.google.protobuf.ByteString getAgentHasHash();

    /**
     * <pre>
     * The version of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier offer
     * from the Server to install this package.
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     * Note that it is possible for both agent_has_version and server_offered_version
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the Server
     * offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>string server_offered_version = 4;</code>
     * @return The serverOfferedVersion.
     */
    java.lang.String getServerOfferedVersion();
    /**
     * <pre>
     * The version of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier offer
     * from the Server to install this package.
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     * Note that it is possible for both agent_has_version and server_offered_version
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the Server
     * offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>string server_offered_version = 4;</code>
     * @return The bytes for serverOfferedVersion.
     */
    com.google.protobuf.ByteString
        getServerOfferedVersionBytes();

    /**
     * <pre>
     * The hash of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier
     * offer from the Server to install this package.
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     * Note that it is possible for both agent_has_hash and server_offered_hash
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the
     * Server offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>bytes server_offered_hash = 5;</code>
     * @return The serverOfferedHash.
     */
    com.google.protobuf.ByteString getServerOfferedHash();

    /**
     * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
     * @return The enum numeric value on the wire for status.
     */
    int getStatusValue();
    /**
     * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
     * @return The status.
     */
    opamp.proto.Opamp.PackageStatusEnum getStatus();

    /**
     * <pre>
     * Error message if the status is erroneous.
     * </pre>
     *
     * <code>string error_message = 7;</code>
     * @return The errorMessage.
     */
    java.lang.String getErrorMessage();
    /**
     * <pre>
     * Error message if the status is erroneous.
     * </pre>
     *
     * <code>string error_message = 7;</code>
     * @return The bytes for errorMessage.
     */
    com.google.protobuf.ByteString
        getErrorMessageBytes();
  }
  /**
   * <pre>
   * The status of a single package.
   * </pre>
   *
   * Protobuf type {@code opamp.proto.PackageStatus}
   */
  public static final class PackageStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.PackageStatus)
      PackageStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PackageStatus.newBuilder() to construct.
    private PackageStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PackageStatus() {
      name_ = "";
      agentHasVersion_ = "";
      agentHasHash_ = com.google.protobuf.ByteString.EMPTY;
      serverOfferedVersion_ = "";
      serverOfferedHash_ = com.google.protobuf.ByteString.EMPTY;
      status_ = 0;
      errorMessage_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PackageStatus();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private PackageStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              agentHasVersion_ = s;
              break;
            }
            case 26: {

              agentHasHash_ = input.readBytes();
              break;
            }
            case 34: {
              java.lang.String s = input.readStringRequireUtf8();

              serverOfferedVersion_ = s;
              break;
            }
            case 42: {

              serverOfferedHash_ = input.readBytes();
              break;
            }
            case 48: {
              int rawValue = input.readEnum();

              status_ = rawValue;
              break;
            }
            case 58: {
              java.lang.String s = input.readStringRequireUtf8();

              errorMessage_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatus_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.PackageStatus.class, opamp.proto.Opamp.PackageStatus.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    private volatile java.lang.Object name_;
    /**
     * <pre>
     * Package name. MUST be always set and MUST match the key in the packages field
     * of PackageStatuses message.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Package name. MUST be always set and MUST match the key in the packages field
     * of PackageStatuses message.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENT_HAS_VERSION_FIELD_NUMBER = 2;
    private volatile java.lang.Object agentHasVersion_;
    /**
     * <pre>
     * The version of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case
     * for example if the package was offered by the Server but failed to install
     * and the Agent did not have this package previously.
     * </pre>
     *
     * <code>string agent_has_version = 2;</code>
     * @return The agentHasVersion.
     */
    @java.lang.Override
    public java.lang.String getAgentHasVersion() {
      java.lang.Object ref = agentHasVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        agentHasVersion_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The version of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case
     * for example if the package was offered by the Server but failed to install
     * and the Agent did not have this package previously.
     * </pre>
     *
     * <code>string agent_has_version = 2;</code>
     * @return The bytes for agentHasVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getAgentHasVersionBytes() {
      java.lang.Object ref = agentHasVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        agentHasVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int AGENT_HAS_HASH_FIELD_NUMBER = 3;
    private com.google.protobuf.ByteString agentHasHash_;
    /**
     * <pre>
     * The hash of the package that the Agent has.
     * MUST be set if the Agent has this package.
     * MUST be empty if the Agent does not have this package. This may be the case for
     * example if the package was offered by the Server but failed to install and the
     * Agent did not have this package previously.
     * </pre>
     *
     * <code>bytes agent_has_hash = 3;</code>
     * @return The agentHasHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getAgentHasHash() {
      return agentHasHash_;
    }

    public static final int SERVER_OFFERED_VERSION_FIELD_NUMBER = 4;
    private volatile java.lang.Object serverOfferedVersion_;
    /**
     * <pre>
     * The version of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier offer
     * from the Server to install this package.
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     * Note that it is possible for both agent_has_version and server_offered_version
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the Server
     * offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>string server_offered_version = 4;</code>
     * @return The serverOfferedVersion.
     */
    @java.lang.Override
    public java.lang.String getServerOfferedVersion() {
      java.lang.Object ref = serverOfferedVersion_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        serverOfferedVersion_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The version of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier offer
     * from the Server to install this package.
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     * Note that it is possible for both agent_has_version and server_offered_version
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the Server
     * offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>string server_offered_version = 4;</code>
     * @return The bytes for serverOfferedVersion.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getServerOfferedVersionBytes() {
      java.lang.Object ref = serverOfferedVersion_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        serverOfferedVersion_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SERVER_OFFERED_HASH_FIELD_NUMBER = 5;
    private com.google.protobuf.ByteString serverOfferedHash_;
    /**
     * <pre>
     * The hash of the package that the Server offered to the Agent.
     * MUST be set if the installation of the package is initiated by an earlier
     * offer from the Server to install this package.
     * MUST be empty if the Agent has this package but it was installed locally and
     * was not offered by the Server.
     * Note that it is possible for both agent_has_hash and server_offered_hash
     * fields to be set and to have different values. This is for example possible if
     * the Agent already has a version of the package successfully installed, the
     * Server offers a different version, but the Agent fails to install that version.
     * </pre>
     *
     * <code>bytes server_offered_hash = 5;</code>
     * @return The serverOfferedHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getServerOfferedHash() {
      return serverOfferedHash_;
    }

    public static final int STATUS_FIELD_NUMBER = 6;
    private int status_;
    /**
     * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
     * @return The enum numeric value on the wire for status.
     */
    @java.lang.Override public int getStatusValue() {
      return status_;
    }
    /**
     * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
     * @return The status.
     */
    @java.lang.Override public opamp.proto.Opamp.PackageStatusEnum getStatus() {
      @SuppressWarnings("deprecation")
      opamp.proto.Opamp.PackageStatusEnum result = opamp.proto.Opamp.PackageStatusEnum.valueOf(status_);
      return result == null ? opamp.proto.Opamp.PackageStatusEnum.UNRECOGNIZED : result;
    }

    public static final int ERROR_MESSAGE_FIELD_NUMBER = 7;
    private volatile java.lang.Object errorMessage_;
    /**
     * <pre>
     * Error message if the status is erroneous.
     * </pre>
     *
     * <code>string error_message = 7;</code>
     * @return The errorMessage.
     */
    @java.lang.Override
    public java.lang.String getErrorMessage() {
      java.lang.Object ref = errorMessage_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        errorMessage_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Error message if the status is erroneous.
     * </pre>
     *
     * <code>string error_message = 7;</code>
     * @return The bytes for errorMessage.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getErrorMessageBytes() {
      java.lang.Object ref = errorMessage_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        errorMessage_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agentHasVersion_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, agentHasVersion_);
      }
      if (!agentHasHash_.isEmpty()) {
        output.writeBytes(3, agentHasHash_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serverOfferedVersion_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 4, serverOfferedVersion_);
      }
      if (!serverOfferedHash_.isEmpty()) {
        output.writeBytes(5, serverOfferedHash_);
      }
      if (status_ != opamp.proto.Opamp.PackageStatusEnum.PackageStatusEnum_Installed.getNumber()) {
        output.writeEnum(6, status_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 7, errorMessage_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(agentHasVersion_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, agentHasVersion_);
      }
      if (!agentHasHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(3, agentHasHash_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(serverOfferedVersion_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(4, serverOfferedVersion_);
      }
      if (!serverOfferedHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(5, serverOfferedHash_);
      }
      if (status_ != opamp.proto.Opamp.PackageStatusEnum.PackageStatusEnum_Installed.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(6, status_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(errorMessage_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(7, errorMessage_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.PackageStatus)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.PackageStatus other = (opamp.proto.Opamp.PackageStatus) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (!getAgentHasVersion()
          .equals(other.getAgentHasVersion())) return false;
      if (!getAgentHasHash()
          .equals(other.getAgentHasHash())) return false;
      if (!getServerOfferedVersion()
          .equals(other.getServerOfferedVersion())) return false;
      if (!getServerOfferedHash()
          .equals(other.getServerOfferedHash())) return false;
      if (status_ != other.status_) return false;
      if (!getErrorMessage()
          .equals(other.getErrorMessage())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + AGENT_HAS_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getAgentHasVersion().hashCode();
      hash = (37 * hash) + AGENT_HAS_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getAgentHasHash().hashCode();
      hash = (37 * hash) + SERVER_OFFERED_VERSION_FIELD_NUMBER;
      hash = (53 * hash) + getServerOfferedVersion().hashCode();
      hash = (37 * hash) + SERVER_OFFERED_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getServerOfferedHash().hashCode();
      hash = (37 * hash) + STATUS_FIELD_NUMBER;
      hash = (53 * hash) + status_;
      hash = (37 * hash) + ERROR_MESSAGE_FIELD_NUMBER;
      hash = (53 * hash) + getErrorMessage().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.PackageStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackageStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackageStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.PackageStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackageStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackageStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.PackageStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.PackageStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.PackageStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The status of a single package.
     * </pre>
     *
     * Protobuf type {@code opamp.proto.PackageStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.PackageStatus)
        opamp.proto.Opamp.PackageStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatus_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.PackageStatus.class, opamp.proto.Opamp.PackageStatus.Builder.class);
      }

      // Construct using opamp.proto.Opamp.PackageStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        name_ = "";

        agentHasVersion_ = "";

        agentHasHash_ = com.google.protobuf.ByteString.EMPTY;

        serverOfferedVersion_ = "";

        serverOfferedHash_ = com.google.protobuf.ByteString.EMPTY;

        status_ = 0;

        errorMessage_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_PackageStatus_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackageStatus getDefaultInstanceForType() {
        return opamp.proto.Opamp.PackageStatus.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackageStatus build() {
        opamp.proto.Opamp.PackageStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.PackageStatus buildPartial() {
        opamp.proto.Opamp.PackageStatus result = new opamp.proto.Opamp.PackageStatus(this);
        result.name_ = name_;
        result.agentHasVersion_ = agentHasVersion_;
        result.agentHasHash_ = agentHasHash_;
        result.serverOfferedVersion_ = serverOfferedVersion_;
        result.serverOfferedHash_ = serverOfferedHash_;
        result.status_ = status_;
        result.errorMessage_ = errorMessage_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.PackageStatus) {
          return mergeFrom((opamp.proto.Opamp.PackageStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.PackageStatus other) {
        if (other == opamp.proto.Opamp.PackageStatus.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (!other.getAgentHasVersion().isEmpty()) {
          agentHasVersion_ = other.agentHasVersion_;
          onChanged();
        }
        if (other.getAgentHasHash() != com.google.protobuf.ByteString.EMPTY) {
          setAgentHasHash(other.getAgentHasHash());
        }
        if (!other.getServerOfferedVersion().isEmpty()) {
          serverOfferedVersion_ = other.serverOfferedVersion_;
          onChanged();
        }
        if (other.getServerOfferedHash() != com.google.protobuf.ByteString.EMPTY) {
          setServerOfferedHash(other.getServerOfferedHash());
        }
        if (other.status_ != 0) {
          setStatusValue(other.getStatusValue());
        }
        if (!other.getErrorMessage().isEmpty()) {
          errorMessage_ = other.errorMessage_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.PackageStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.PackageStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Package name. MUST be always set and MUST match the key in the packages field
       * of PackageStatuses message.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private java.lang.Object agentHasVersion_ = "";
      /**
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       * @return The agentHasVersion.
       */
      public java.lang.String getAgentHasVersion() {
        java.lang.Object ref = agentHasVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          agentHasVersion_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       * @return The bytes for agentHasVersion.
       */
      public com.google.protobuf.ByteString
          getAgentHasVersionBytes() {
        java.lang.Object ref = agentHasVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          agentHasVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       * @param value The agentHasVersion to set.
       * @return This builder for chaining.
       */
      public Builder setAgentHasVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agentHasVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgentHasVersion() {
        
        agentHasVersion_ = getDefaultInstance().getAgentHasVersion();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The version of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case
       * for example if the package was offered by the Server but failed to install
       * and the Agent did not have this package previously.
       * </pre>
       *
       * <code>string agent_has_version = 2;</code>
       * @param value The bytes for agentHasVersion to set.
       * @return This builder for chaining.
       */
      public Builder setAgentHasVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        agentHasVersion_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString agentHasHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The hash of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case for
       * example if the package was offered by the Server but failed to install and the
       * Agent did not have this package previously.
       * </pre>
       *
       * <code>bytes agent_has_hash = 3;</code>
       * @return The agentHasHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getAgentHasHash() {
        return agentHasHash_;
      }
      /**
       * <pre>
       * The hash of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case for
       * example if the package was offered by the Server but failed to install and the
       * Agent did not have this package previously.
       * </pre>
       *
       * <code>bytes agent_has_hash = 3;</code>
       * @param value The agentHasHash to set.
       * @return This builder for chaining.
       */
      public Builder setAgentHasHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        agentHasHash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash of the package that the Agent has.
       * MUST be set if the Agent has this package.
       * MUST be empty if the Agent does not have this package. This may be the case for
       * example if the package was offered by the Server but failed to install and the
       * Agent did not have this package previously.
       * </pre>
       *
       * <code>bytes agent_has_hash = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearAgentHasHash() {
        
        agentHasHash_ = getDefaultInstance().getAgentHasHash();
        onChanged();
        return this;
      }

      private java.lang.Object serverOfferedVersion_ = "";
      /**
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       * @return The serverOfferedVersion.
       */
      public java.lang.String getServerOfferedVersion() {
        java.lang.Object ref = serverOfferedVersion_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          serverOfferedVersion_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       * @return The bytes for serverOfferedVersion.
       */
      public com.google.protobuf.ByteString
          getServerOfferedVersionBytes() {
        java.lang.Object ref = serverOfferedVersion_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          serverOfferedVersion_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       * @param value The serverOfferedVersion to set.
       * @return This builder for chaining.
       */
      public Builder setServerOfferedVersion(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        serverOfferedVersion_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearServerOfferedVersion() {
        
        serverOfferedVersion_ = getDefaultInstance().getServerOfferedVersion();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The version of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier offer
       * from the Server to install this package.
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       * Note that it is possible for both agent_has_version and server_offered_version
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the Server
       * offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>string server_offered_version = 4;</code>
       * @param value The bytes for serverOfferedVersion to set.
       * @return This builder for chaining.
       */
      public Builder setServerOfferedVersionBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        serverOfferedVersion_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.ByteString serverOfferedHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * The hash of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier
       * offer from the Server to install this package.
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       * Note that it is possible for both agent_has_hash and server_offered_hash
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the
       * Server offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>bytes server_offered_hash = 5;</code>
       * @return The serverOfferedHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getServerOfferedHash() {
        return serverOfferedHash_;
      }
      /**
       * <pre>
       * The hash of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier
       * offer from the Server to install this package.
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       * Note that it is possible for both agent_has_hash and server_offered_hash
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the
       * Server offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>bytes server_offered_hash = 5;</code>
       * @param value The serverOfferedHash to set.
       * @return This builder for chaining.
       */
      public Builder setServerOfferedHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        serverOfferedHash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The hash of the package that the Server offered to the Agent.
       * MUST be set if the installation of the package is initiated by an earlier
       * offer from the Server to install this package.
       * MUST be empty if the Agent has this package but it was installed locally and
       * was not offered by the Server.
       * Note that it is possible for both agent_has_hash and server_offered_hash
       * fields to be set and to have different values. This is for example possible if
       * the Agent already has a version of the package successfully installed, the
       * Server offers a different version, but the Agent fails to install that version.
       * </pre>
       *
       * <code>bytes server_offered_hash = 5;</code>
       * @return This builder for chaining.
       */
      public Builder clearServerOfferedHash() {
        
        serverOfferedHash_ = getDefaultInstance().getServerOfferedHash();
        onChanged();
        return this;
      }

      private int status_ = 0;
      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       * @return The enum numeric value on the wire for status.
       */
      @java.lang.Override public int getStatusValue() {
        return status_;
      }
      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       * @param value The enum numeric value on the wire for status to set.
       * @return This builder for chaining.
       */
      public Builder setStatusValue(int value) {
        
        status_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       * @return The status.
       */
      @java.lang.Override
      public opamp.proto.Opamp.PackageStatusEnum getStatus() {
        @SuppressWarnings("deprecation")
        opamp.proto.Opamp.PackageStatusEnum result = opamp.proto.Opamp.PackageStatusEnum.valueOf(status_);
        return result == null ? opamp.proto.Opamp.PackageStatusEnum.UNRECOGNIZED : result;
      }
      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       * @param value The status to set.
       * @return This builder for chaining.
       */
      public Builder setStatus(opamp.proto.Opamp.PackageStatusEnum value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        status_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>.opamp.proto.PackageStatusEnum status = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearStatus() {
        
        status_ = 0;
        onChanged();
        return this;
      }

      private java.lang.Object errorMessage_ = "";
      /**
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       * @return The errorMessage.
       */
      public java.lang.String getErrorMessage() {
        java.lang.Object ref = errorMessage_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          errorMessage_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       * @return The bytes for errorMessage.
       */
      public com.google.protobuf.ByteString
          getErrorMessageBytes() {
        java.lang.Object ref = errorMessage_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          errorMessage_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       * @param value The errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessage(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        errorMessage_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearErrorMessage() {
        
        errorMessage_ = getDefaultInstance().getErrorMessage();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Error message if the status is erroneous.
       * </pre>
       *
       * <code>string error_message = 7;</code>
       * @param value The bytes for errorMessage to set.
       * @return This builder for chaining.
       */
      public Builder setErrorMessageBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        errorMessage_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.PackageStatus)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.PackageStatus)
    private static final opamp.proto.Opamp.PackageStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.PackageStatus();
    }

    public static opamp.proto.Opamp.PackageStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackageStatus>
        PARSER = new com.google.protobuf.AbstractParser<PackageStatus>() {
      @java.lang.Override
      public PackageStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new PackageStatus(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<PackageStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PackageStatus> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.PackageStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AgentIdentificationOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentIdentification)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * When new_instance_uid is set, Agent MUST update instance_uid
     * to the value provided and use it for all further communication.
     * </pre>
     *
     * <code>string new_instance_uid = 1;</code>
     * @return The newInstanceUid.
     */
    java.lang.String getNewInstanceUid();
    /**
     * <pre>
     * When new_instance_uid is set, Agent MUST update instance_uid
     * to the value provided and use it for all further communication.
     * </pre>
     *
     * <code>string new_instance_uid = 1;</code>
     * @return The bytes for newInstanceUid.
     */
    com.google.protobuf.ByteString
        getNewInstanceUidBytes();
  }
  /**
   * <pre>
   * Properties related to identification of the Agent, which can be overridden
   * by the Server if needed
   * </pre>
   *
   * Protobuf type {@code opamp.proto.AgentIdentification}
   */
  public static final class AgentIdentification extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentIdentification)
      AgentIdentificationOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AgentIdentification.newBuilder() to construct.
    private AgentIdentification(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AgentIdentification() {
      newInstanceUid_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AgentIdentification();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AgentIdentification(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              java.lang.String s = input.readStringRequireUtf8();

              newInstanceUid_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentIdentification_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentIdentification_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.AgentIdentification.class, opamp.proto.Opamp.AgentIdentification.Builder.class);
    }

    public static final int NEW_INSTANCE_UID_FIELD_NUMBER = 1;
    private volatile java.lang.Object newInstanceUid_;
    /**
     * <pre>
     * When new_instance_uid is set, Agent MUST update instance_uid
     * to the value provided and use it for all further communication.
     * </pre>
     *
     * <code>string new_instance_uid = 1;</code>
     * @return The newInstanceUid.
     */
    @java.lang.Override
    public java.lang.String getNewInstanceUid() {
      java.lang.Object ref = newInstanceUid_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        newInstanceUid_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * When new_instance_uid is set, Agent MUST update instance_uid
     * to the value provided and use it for all further communication.
     * </pre>
     *
     * <code>string new_instance_uid = 1;</code>
     * @return The bytes for newInstanceUid.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNewInstanceUidBytes() {
      java.lang.Object ref = newInstanceUid_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        newInstanceUid_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(newInstanceUid_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, newInstanceUid_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(newInstanceUid_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, newInstanceUid_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.AgentIdentification)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.AgentIdentification other = (opamp.proto.Opamp.AgentIdentification) obj;

      if (!getNewInstanceUid()
          .equals(other.getNewInstanceUid())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NEW_INSTANCE_UID_FIELD_NUMBER;
      hash = (53 * hash) + getNewInstanceUid().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.AgentIdentification parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentIdentification parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentIdentification parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentIdentification parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentIdentification parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentIdentification parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentIdentification parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentIdentification parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentIdentification parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentIdentification parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentIdentification parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentIdentification parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.AgentIdentification prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Properties related to identification of the Agent, which can be overridden
     * by the Server if needed
     * </pre>
     *
     * Protobuf type {@code opamp.proto.AgentIdentification}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentIdentification)
        opamp.proto.Opamp.AgentIdentificationOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentIdentification_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentIdentification_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.AgentIdentification.class, opamp.proto.Opamp.AgentIdentification.Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentIdentification.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        newInstanceUid_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentIdentification_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentIdentification getDefaultInstanceForType() {
        return opamp.proto.Opamp.AgentIdentification.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentIdentification build() {
        opamp.proto.Opamp.AgentIdentification result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentIdentification buildPartial() {
        opamp.proto.Opamp.AgentIdentification result = new opamp.proto.Opamp.AgentIdentification(this);
        result.newInstanceUid_ = newInstanceUid_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.AgentIdentification) {
          return mergeFrom((opamp.proto.Opamp.AgentIdentification)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.AgentIdentification other) {
        if (other == opamp.proto.Opamp.AgentIdentification.getDefaultInstance()) return this;
        if (!other.getNewInstanceUid().isEmpty()) {
          newInstanceUid_ = other.newInstanceUid_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.AgentIdentification parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.AgentIdentification) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private java.lang.Object newInstanceUid_ = "";
      /**
       * <pre>
       * When new_instance_uid is set, Agent MUST update instance_uid
       * to the value provided and use it for all further communication.
       * </pre>
       *
       * <code>string new_instance_uid = 1;</code>
       * @return The newInstanceUid.
       */
      public java.lang.String getNewInstanceUid() {
        java.lang.Object ref = newInstanceUid_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          newInstanceUid_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * When new_instance_uid is set, Agent MUST update instance_uid
       * to the value provided and use it for all further communication.
       * </pre>
       *
       * <code>string new_instance_uid = 1;</code>
       * @return The bytes for newInstanceUid.
       */
      public com.google.protobuf.ByteString
          getNewInstanceUidBytes() {
        java.lang.Object ref = newInstanceUid_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          newInstanceUid_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * When new_instance_uid is set, Agent MUST update instance_uid
       * to the value provided and use it for all further communication.
       * </pre>
       *
       * <code>string new_instance_uid = 1;</code>
       * @param value The newInstanceUid to set.
       * @return This builder for chaining.
       */
      public Builder setNewInstanceUid(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        newInstanceUid_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When new_instance_uid is set, Agent MUST update instance_uid
       * to the value provided and use it for all further communication.
       * </pre>
       *
       * <code>string new_instance_uid = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearNewInstanceUid() {
        
        newInstanceUid_ = getDefaultInstance().getNewInstanceUid();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * When new_instance_uid is set, Agent MUST update instance_uid
       * to the value provided and use it for all further communication.
       * </pre>
       *
       * <code>string new_instance_uid = 1;</code>
       * @param value The bytes for newInstanceUid to set.
       * @return This builder for chaining.
       */
      public Builder setNewInstanceUidBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        newInstanceUid_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentIdentification)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentIdentification)
    private static final opamp.proto.Opamp.AgentIdentification DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.AgentIdentification();
    }

    public static opamp.proto.Opamp.AgentIdentification getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentIdentification>
        PARSER = new com.google.protobuf.AbstractParser<AgentIdentification>() {
      @java.lang.Override
      public AgentIdentification parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AgentIdentification(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AgentIdentification> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AgentIdentification> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.AgentIdentification getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AgentRemoteConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentRemoteConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     * @return Whether the config field is set.
     */
    boolean hasConfig();
    /**
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     * @return The config.
     */
    opamp.proto.Opamp.AgentConfigMap getConfig();
    /**
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     */
    opamp.proto.Opamp.AgentConfigMapOrBuilder getConfigOrBuilder();

    /**
     * <pre>
     * Hash of "config". The Agent SHOULD include this value in subsequent
     * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
     * allows the management Server to identify that a new config is available for the Agent.
     * This field MUST be always set if the management Server supports remote configuration
     * of agents.
     * Management Server must choose a hashing function that guarantees lack of hash
     * collisions in practice.
     * </pre>
     *
     * <code>bytes config_hash = 2;</code>
     * @return The configHash.
     */
    com.google.protobuf.ByteString getConfigHash();
  }
  /**
   * Protobuf type {@code opamp.proto.AgentRemoteConfig}
   */
  public static final class AgentRemoteConfig extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentRemoteConfig)
      AgentRemoteConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AgentRemoteConfig.newBuilder() to construct.
    private AgentRemoteConfig(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AgentRemoteConfig() {
      configHash_ = com.google.protobuf.ByteString.EMPTY;
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AgentRemoteConfig();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AgentRemoteConfig(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              opamp.proto.Opamp.AgentConfigMap.Builder subBuilder = null;
              if (config_ != null) {
                subBuilder = config_.toBuilder();
              }
              config_ = input.readMessage(opamp.proto.Opamp.AgentConfigMap.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(config_);
                config_ = subBuilder.buildPartial();
              }

              break;
            }
            case 18: {

              configHash_ = input.readBytes();
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentRemoteConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentRemoteConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.AgentRemoteConfig.class, opamp.proto.Opamp.AgentRemoteConfig.Builder.class);
    }

    public static final int CONFIG_FIELD_NUMBER = 1;
    private opamp.proto.Opamp.AgentConfigMap config_;
    /**
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     * @return Whether the config field is set.
     */
    @java.lang.Override
    public boolean hasConfig() {
      return config_ != null;
    }
    /**
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     * @return The config.
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentConfigMap getConfig() {
      return config_ == null ? opamp.proto.Opamp.AgentConfigMap.getDefaultInstance() : config_;
    }
    /**
     * <pre>
     * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
     * set if the config for this Agent has not changed since it was last requested (i.e.
     * AgentConfigRequest.last_remote_config_hash field is equal to
     * AgentConfigResponse.config_hash field).
     * </pre>
     *
     * <code>.opamp.proto.AgentConfigMap config = 1;</code>
     */
    @java.lang.Override
    public opamp.proto.Opamp.AgentConfigMapOrBuilder getConfigOrBuilder() {
      return getConfig();
    }

    public static final int CONFIG_HASH_FIELD_NUMBER = 2;
    private com.google.protobuf.ByteString configHash_;
    /**
     * <pre>
     * Hash of "config". The Agent SHOULD include this value in subsequent
     * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
     * allows the management Server to identify that a new config is available for the Agent.
     * This field MUST be always set if the management Server supports remote configuration
     * of agents.
     * Management Server must choose a hashing function that guarantees lack of hash
     * collisions in practice.
     * </pre>
     *
     * <code>bytes config_hash = 2;</code>
     * @return The configHash.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getConfigHash() {
      return configHash_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (config_ != null) {
        output.writeMessage(1, getConfig());
      }
      if (!configHash_.isEmpty()) {
        output.writeBytes(2, configHash_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (config_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getConfig());
      }
      if (!configHash_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(2, configHash_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.AgentRemoteConfig)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.AgentRemoteConfig other = (opamp.proto.Opamp.AgentRemoteConfig) obj;

      if (hasConfig() != other.hasConfig()) return false;
      if (hasConfig()) {
        if (!getConfig()
            .equals(other.getConfig())) return false;
      }
      if (!getConfigHash()
          .equals(other.getConfigHash())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasConfig()) {
        hash = (37 * hash) + CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getConfig().hashCode();
      }
      hash = (37 * hash) + CONFIG_HASH_FIELD_NUMBER;
      hash = (53 * hash) + getConfigHash().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentRemoteConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.AgentRemoteConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.AgentRemoteConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentRemoteConfig)
        opamp.proto.Opamp.AgentRemoteConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentRemoteConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentRemoteConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.AgentRemoteConfig.class, opamp.proto.Opamp.AgentRemoteConfig.Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentRemoteConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        if (configBuilder_ == null) {
          config_ = null;
        } else {
          config_ = null;
          configBuilder_ = null;
        }
        configHash_ = com.google.protobuf.ByteString.EMPTY;

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentRemoteConfig_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentRemoteConfig getDefaultInstanceForType() {
        return opamp.proto.Opamp.AgentRemoteConfig.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentRemoteConfig build() {
        opamp.proto.Opamp.AgentRemoteConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentRemoteConfig buildPartial() {
        opamp.proto.Opamp.AgentRemoteConfig result = new opamp.proto.Opamp.AgentRemoteConfig(this);
        if (configBuilder_ == null) {
          result.config_ = config_;
        } else {
          result.config_ = configBuilder_.build();
        }
        result.configHash_ = configHash_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.AgentRemoteConfig) {
          return mergeFrom((opamp.proto.Opamp.AgentRemoteConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.AgentRemoteConfig other) {
        if (other == opamp.proto.Opamp.AgentRemoteConfig.getDefaultInstance()) return this;
        if (other.hasConfig()) {
          mergeConfig(other.getConfig());
        }
        if (other.getConfigHash() != com.google.protobuf.ByteString.EMPTY) {
          setConfigHash(other.getConfigHash());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.AgentRemoteConfig parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.AgentRemoteConfig) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private opamp.proto.Opamp.AgentConfigMap config_;
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentConfigMap, opamp.proto.Opamp.AgentConfigMap.Builder, opamp.proto.Opamp.AgentConfigMapOrBuilder> configBuilder_;
      /**
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       * @return Whether the config field is set.
       */
      public boolean hasConfig() {
        return configBuilder_ != null || config_ != null;
      }
      /**
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       * @return The config.
       */
      public opamp.proto.Opamp.AgentConfigMap getConfig() {
        if (configBuilder_ == null) {
          return config_ == null ? opamp.proto.Opamp.AgentConfigMap.getDefaultInstance() : config_;
        } else {
          return configBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public Builder setConfig(opamp.proto.Opamp.AgentConfigMap value) {
        if (configBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          config_ = value;
          onChanged();
        } else {
          configBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public Builder setConfig(
          opamp.proto.Opamp.AgentConfigMap.Builder builderForValue) {
        if (configBuilder_ == null) {
          config_ = builderForValue.build();
          onChanged();
        } else {
          configBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public Builder mergeConfig(opamp.proto.Opamp.AgentConfigMap value) {
        if (configBuilder_ == null) {
          if (config_ != null) {
            config_ =
              opamp.proto.Opamp.AgentConfigMap.newBuilder(config_).mergeFrom(value).buildPartial();
          } else {
            config_ = value;
          }
          onChanged();
        } else {
          configBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public Builder clearConfig() {
        if (configBuilder_ == null) {
          config_ = null;
          onChanged();
        } else {
          config_ = null;
          configBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public opamp.proto.Opamp.AgentConfigMap.Builder getConfigBuilder() {
        
        onChanged();
        return getConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      public opamp.proto.Opamp.AgentConfigMapOrBuilder getConfigOrBuilder() {
        if (configBuilder_ != null) {
          return configBuilder_.getMessageOrBuilder();
        } else {
          return config_ == null ?
              opamp.proto.Opamp.AgentConfigMap.getDefaultInstance() : config_;
        }
      }
      /**
       * <pre>
       * Agent config offered by the management Server to the Agent instance. SHOULD NOT be
       * set if the config for this Agent has not changed since it was last requested (i.e.
       * AgentConfigRequest.last_remote_config_hash field is equal to
       * AgentConfigResponse.config_hash field).
       * </pre>
       *
       * <code>.opamp.proto.AgentConfigMap config = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          opamp.proto.Opamp.AgentConfigMap, opamp.proto.Opamp.AgentConfigMap.Builder, opamp.proto.Opamp.AgentConfigMapOrBuilder> 
          getConfigFieldBuilder() {
        if (configBuilder_ == null) {
          configBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              opamp.proto.Opamp.AgentConfigMap, opamp.proto.Opamp.AgentConfigMap.Builder, opamp.proto.Opamp.AgentConfigMapOrBuilder>(
                  getConfig(),
                  getParentForChildren(),
                  isClean());
          config_ = null;
        }
        return configBuilder_;
      }

      private com.google.protobuf.ByteString configHash_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Hash of "config". The Agent SHOULD include this value in subsequent
       * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
       * allows the management Server to identify that a new config is available for the Agent.
       * This field MUST be always set if the management Server supports remote configuration
       * of agents.
       * Management Server must choose a hashing function that guarantees lack of hash
       * collisions in practice.
       * </pre>
       *
       * <code>bytes config_hash = 2;</code>
       * @return The configHash.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getConfigHash() {
        return configHash_;
      }
      /**
       * <pre>
       * Hash of "config". The Agent SHOULD include this value in subsequent
       * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
       * allows the management Server to identify that a new config is available for the Agent.
       * This field MUST be always set if the management Server supports remote configuration
       * of agents.
       * Management Server must choose a hashing function that guarantees lack of hash
       * collisions in practice.
       * </pre>
       *
       * <code>bytes config_hash = 2;</code>
       * @param value The configHash to set.
       * @return This builder for chaining.
       */
      public Builder setConfigHash(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        configHash_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Hash of "config". The Agent SHOULD include this value in subsequent
       * RemoteConfigStatus messages in the last_remote_config_hash field. This in turn
       * allows the management Server to identify that a new config is available for the Agent.
       * This field MUST be always set if the management Server supports remote configuration
       * of agents.
       * Management Server must choose a hashing function that guarantees lack of hash
       * collisions in practice.
       * </pre>
       *
       * <code>bytes config_hash = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearConfigHash() {
        
        configHash_ = getDefaultInstance().getConfigHash();
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentRemoteConfig)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentRemoteConfig)
    private static final opamp.proto.Opamp.AgentRemoteConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.AgentRemoteConfig();
    }

    public static opamp.proto.Opamp.AgentRemoteConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentRemoteConfig>
        PARSER = new com.google.protobuf.AbstractParser<AgentRemoteConfig>() {
      @java.lang.Override
      public AgentRemoteConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AgentRemoteConfig(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AgentRemoteConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AgentRemoteConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.AgentRemoteConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AgentConfigMapOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentConfigMap)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    int getConfigMapCount();
    /**
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    boolean containsConfigMap(
        java.lang.String key);
    /**
     * Use {@link #getConfigMapMap()} instead.
     */
    @java.lang.Deprecated
    java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile>
    getConfigMap();
    /**
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile>
    getConfigMapMap();
    /**
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */

    opamp.proto.Opamp.AgentConfigFile getConfigMapOrDefault(
        java.lang.String key,
        opamp.proto.Opamp.AgentConfigFile defaultValue);
    /**
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */

    opamp.proto.Opamp.AgentConfigFile getConfigMapOrThrow(
        java.lang.String key);
  }
  /**
   * Protobuf type {@code opamp.proto.AgentConfigMap}
   */
  public static final class AgentConfigMap extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentConfigMap)
      AgentConfigMapOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AgentConfigMap.newBuilder() to construct.
    private AgentConfigMap(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AgentConfigMap() {
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AgentConfigMap();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AgentConfigMap(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) != 0)) {
                configMap_ = com.google.protobuf.MapField.newMapField(
                    ConfigMapDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<java.lang.String, opamp.proto.Opamp.AgentConfigFile>
              configMap__ = input.readMessage(
                  ConfigMapDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              configMap_.getMutableMap().put(
                  configMap__.getKey(), configMap__.getValue());
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigMap_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    @java.lang.Override
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetConfigMap();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigMap_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.AgentConfigMap.class, opamp.proto.Opamp.AgentConfigMap.Builder.class);
    }

    public static final int CONFIG_MAP_FIELD_NUMBER = 1;
    private static final class ConfigMapDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          java.lang.String, opamp.proto.Opamp.AgentConfigFile> defaultEntry =
              com.google.protobuf.MapEntry
              .<java.lang.String, opamp.proto.Opamp.AgentConfigFile>newDefaultInstance(
                  opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_descriptor, 
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  opamp.proto.Opamp.AgentConfigFile.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        java.lang.String, opamp.proto.Opamp.AgentConfigFile> configMap_;
    private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.AgentConfigFile>
    internalGetConfigMap() {
      if (configMap_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ConfigMapDefaultEntryHolder.defaultEntry);
      }
      return configMap_;
    }

    public int getConfigMapCount() {
      return internalGetConfigMap().getMap().size();
    }
    /**
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */

    @java.lang.Override
    public boolean containsConfigMap(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      return internalGetConfigMap().getMap().containsKey(key);
    }
    /**
     * Use {@link #getConfigMapMap()} instead.
     */
    @java.lang.Override
    @java.lang.Deprecated
    public java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile> getConfigMap() {
      return getConfigMapMap();
    }
    /**
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    @java.lang.Override

    public java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile> getConfigMapMap() {
      return internalGetConfigMap().getMap();
    }
    /**
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    @java.lang.Override

    public opamp.proto.Opamp.AgentConfigFile getConfigMapOrDefault(
        java.lang.String key,
        opamp.proto.Opamp.AgentConfigFile defaultValue) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile> map =
          internalGetConfigMap().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * Map of configs. Keys are config file names or config section names.
     * The configuration is assumed to be a collection of one or more named config files
     * or sections.
     * For agents that use a single config file or section the map SHOULD contain a single
     * entry and the key may be an empty string.
     * </pre>
     *
     * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
     */
    @java.lang.Override

    public opamp.proto.Opamp.AgentConfigFile getConfigMapOrThrow(
        java.lang.String key) {
      if (key == null) { throw new NullPointerException("map key"); }
      java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile> map =
          internalGetConfigMap().getMap();
      if (!map.containsKey(key)) {
        throw new java.lang.IllegalArgumentException();
      }
      return map.get(key);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetConfigMap(),
          ConfigMapDefaultEntryHolder.defaultEntry,
          1);
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<java.lang.String, opamp.proto.Opamp.AgentConfigFile> entry
           : internalGetConfigMap().getMap().entrySet()) {
        com.google.protobuf.MapEntry<java.lang.String, opamp.proto.Opamp.AgentConfigFile>
        configMap__ = ConfigMapDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, configMap__);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.AgentConfigMap)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.AgentConfigMap other = (opamp.proto.Opamp.AgentConfigMap) obj;

      if (!internalGetConfigMap().equals(
          other.internalGetConfigMap())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetConfigMap().getMap().isEmpty()) {
        hash = (37 * hash) + CONFIG_MAP_FIELD_NUMBER;
        hash = (53 * hash) + internalGetConfigMap().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.AgentConfigMap parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentConfigMap parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.AgentConfigMap prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.AgentConfigMap}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentConfigMap)
        opamp.proto.Opamp.AgentConfigMapOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigMap_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetConfigMap();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableConfigMap();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigMap_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.AgentConfigMap.class, opamp.proto.Opamp.AgentConfigMap.Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentConfigMap.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        internalGetMutableConfigMap().clear();
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigMap_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentConfigMap getDefaultInstanceForType() {
        return opamp.proto.Opamp.AgentConfigMap.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentConfigMap build() {
        opamp.proto.Opamp.AgentConfigMap result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentConfigMap buildPartial() {
        opamp.proto.Opamp.AgentConfigMap result = new opamp.proto.Opamp.AgentConfigMap(this);
        int from_bitField0_ = bitField0_;
        result.configMap_ = internalGetConfigMap();
        result.configMap_.makeImmutable();
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.AgentConfigMap) {
          return mergeFrom((opamp.proto.Opamp.AgentConfigMap)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.AgentConfigMap other) {
        if (other == opamp.proto.Opamp.AgentConfigMap.getDefaultInstance()) return this;
        internalGetMutableConfigMap().mergeFrom(
            other.internalGetConfigMap());
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.AgentConfigMap parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.AgentConfigMap) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          java.lang.String, opamp.proto.Opamp.AgentConfigFile> configMap_;
      private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.AgentConfigFile>
      internalGetConfigMap() {
        if (configMap_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ConfigMapDefaultEntryHolder.defaultEntry);
        }
        return configMap_;
      }
      private com.google.protobuf.MapField<java.lang.String, opamp.proto.Opamp.AgentConfigFile>
      internalGetMutableConfigMap() {
        onChanged();;
        if (configMap_ == null) {
          configMap_ = com.google.protobuf.MapField.newMapField(
              ConfigMapDefaultEntryHolder.defaultEntry);
        }
        if (!configMap_.isMutable()) {
          configMap_ = configMap_.copy();
        }
        return configMap_;
      }

      public int getConfigMapCount() {
        return internalGetConfigMap().getMap().size();
      }
      /**
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */

      @java.lang.Override
      public boolean containsConfigMap(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        return internalGetConfigMap().getMap().containsKey(key);
      }
      /**
       * Use {@link #getConfigMapMap()} instead.
       */
      @java.lang.Override
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile> getConfigMap() {
        return getConfigMapMap();
      }
      /**
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      @java.lang.Override

      public java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile> getConfigMapMap() {
        return internalGetConfigMap().getMap();
      }
      /**
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      @java.lang.Override

      public opamp.proto.Opamp.AgentConfigFile getConfigMapOrDefault(
          java.lang.String key,
          opamp.proto.Opamp.AgentConfigFile defaultValue) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile> map =
            internalGetConfigMap().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      @java.lang.Override

      public opamp.proto.Opamp.AgentConfigFile getConfigMapOrThrow(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile> map =
            internalGetConfigMap().getMap();
        if (!map.containsKey(key)) {
          throw new java.lang.IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearConfigMap() {
        internalGetMutableConfigMap().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */

      public Builder removeConfigMap(
          java.lang.String key) {
        if (key == null) { throw new NullPointerException("map key"); }
        internalGetMutableConfigMap().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @java.lang.Deprecated
      public java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile>
      getMutableConfigMap() {
        return internalGetMutableConfigMap().getMutableMap();
      }
      /**
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */
      public Builder putConfigMap(
          java.lang.String key,
          opamp.proto.Opamp.AgentConfigFile value) {
        if (key == null) { throw new NullPointerException("map key"); }
        if (value == null) {
  throw new NullPointerException("map value");
}

        internalGetMutableConfigMap().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * Map of configs. Keys are config file names or config section names.
       * The configuration is assumed to be a collection of one or more named config files
       * or sections.
       * For agents that use a single config file or section the map SHOULD contain a single
       * entry and the key may be an empty string.
       * </pre>
       *
       * <code>map&lt;string, .opamp.proto.AgentConfigFile&gt; config_map = 1;</code>
       */

      public Builder putAllConfigMap(
          java.util.Map<java.lang.String, opamp.proto.Opamp.AgentConfigFile> values) {
        internalGetMutableConfigMap().getMutableMap()
            .putAll(values);
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentConfigMap)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentConfigMap)
    private static final opamp.proto.Opamp.AgentConfigMap DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.AgentConfigMap();
    }

    public static opamp.proto.Opamp.AgentConfigMap getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentConfigMap>
        PARSER = new com.google.protobuf.AbstractParser<AgentConfigMap>() {
      @java.lang.Override
      public AgentConfigMap parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AgentConfigMap(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AgentConfigMap> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AgentConfigMap> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.AgentConfigMap getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AgentConfigFileOrBuilder extends
      // @@protoc_insertion_point(interface_extends:opamp.proto.AgentConfigFile)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Config file or section body. The content, format and encoding depends on the Agent
     * type. The content_type field may optionally describe the MIME type of the body.
     * </pre>
     *
     * <code>bytes body = 1;</code>
     * @return The body.
     */
    com.google.protobuf.ByteString getBody();

    /**
     * <pre>
     * Optional MIME Content-Type that describes what's in the body field, for
     * example "text/yaml".
     * </pre>
     *
     * <code>string content_type = 2;</code>
     * @return The contentType.
     */
    java.lang.String getContentType();
    /**
     * <pre>
     * Optional MIME Content-Type that describes what's in the body field, for
     * example "text/yaml".
     * </pre>
     *
     * <code>string content_type = 2;</code>
     * @return The bytes for contentType.
     */
    com.google.protobuf.ByteString
        getContentTypeBytes();
  }
  /**
   * Protobuf type {@code opamp.proto.AgentConfigFile}
   */
  public static final class AgentConfigFile extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:opamp.proto.AgentConfigFile)
      AgentConfigFileOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AgentConfigFile.newBuilder() to construct.
    private AgentConfigFile(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AgentConfigFile() {
      body_ = com.google.protobuf.ByteString.EMPTY;
      contentType_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new AgentConfigFile();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AgentConfigFile(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new java.lang.NullPointerException();
      }
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            case 10: {

              body_ = input.readBytes();
              break;
            }
            case 18: {
              java.lang.String s = input.readStringRequireUtf8();

              contentType_ = s;
              break;
            }
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigFile_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigFile_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              opamp.proto.Opamp.AgentConfigFile.class, opamp.proto.Opamp.AgentConfigFile.Builder.class);
    }

    public static final int BODY_FIELD_NUMBER = 1;
    private com.google.protobuf.ByteString body_;
    /**
     * <pre>
     * Config file or section body. The content, format and encoding depends on the Agent
     * type. The content_type field may optionally describe the MIME type of the body.
     * </pre>
     *
     * <code>bytes body = 1;</code>
     * @return The body.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getBody() {
      return body_;
    }

    public static final int CONTENT_TYPE_FIELD_NUMBER = 2;
    private volatile java.lang.Object contentType_;
    /**
     * <pre>
     * Optional MIME Content-Type that describes what's in the body field, for
     * example "text/yaml".
     * </pre>
     *
     * <code>string content_type = 2;</code>
     * @return The contentType.
     */
    @java.lang.Override
    public java.lang.String getContentType() {
      java.lang.Object ref = contentType_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        contentType_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Optional MIME Content-Type that describes what's in the body field, for
     * example "text/yaml".
     * </pre>
     *
     * <code>string content_type = 2;</code>
     * @return The bytes for contentType.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getContentTypeBytes() {
      java.lang.Object ref = contentType_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        contentType_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!body_.isEmpty()) {
        output.writeBytes(1, body_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(contentType_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, contentType_);
      }
      unknownFields.writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!body_.isEmpty()) {
        size += com.google.protobuf.CodedOutputStream
          .computeBytesSize(1, body_);
      }
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(contentType_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, contentType_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof opamp.proto.Opamp.AgentConfigFile)) {
        return super.equals(obj);
      }
      opamp.proto.Opamp.AgentConfigFile other = (opamp.proto.Opamp.AgentConfigFile) obj;

      if (!getBody()
          .equals(other.getBody())) return false;
      if (!getContentType()
          .equals(other.getContentType())) return false;
      if (!unknownFields.equals(other.unknownFields)) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + BODY_FIELD_NUMBER;
      hash = (53 * hash) + getBody().hashCode();
      hash = (37 * hash) + CONTENT_TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getContentType().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static opamp.proto.Opamp.AgentConfigFile parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static opamp.proto.Opamp.AgentConfigFile parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(opamp.proto.Opamp.AgentConfigFile prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * Protobuf type {@code opamp.proto.AgentConfigFile}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:opamp.proto.AgentConfigFile)
        opamp.proto.Opamp.AgentConfigFileOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigFile_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigFile_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                opamp.proto.Opamp.AgentConfigFile.class, opamp.proto.Opamp.AgentConfigFile.Builder.class);
      }

      // Construct using opamp.proto.Opamp.AgentConfigFile.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        body_ = com.google.protobuf.ByteString.EMPTY;

        contentType_ = "";

        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return opamp.proto.Opamp.internal_static_opamp_proto_AgentConfigFile_descriptor;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentConfigFile getDefaultInstanceForType() {
        return opamp.proto.Opamp.AgentConfigFile.getDefaultInstance();
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentConfigFile build() {
        opamp.proto.Opamp.AgentConfigFile result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public opamp.proto.Opamp.AgentConfigFile buildPartial() {
        opamp.proto.Opamp.AgentConfigFile result = new opamp.proto.Opamp.AgentConfigFile(this);
        result.body_ = body_;
        result.contentType_ = contentType_;
        onBuilt();
        return result;
      }

      @java.lang.Override
      public Builder clone() {
        return super.clone();
      }
      @java.lang.Override
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.setField(field, value);
      }
      @java.lang.Override
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return super.clearField(field);
      }
      @java.lang.Override
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return super.clearOneof(oneof);
      }
      @java.lang.Override
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return super.setRepeatedField(field, index, value);
      }
      @java.lang.Override
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return super.addRepeatedField(field, value);
      }
      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof opamp.proto.Opamp.AgentConfigFile) {
          return mergeFrom((opamp.proto.Opamp.AgentConfigFile)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(opamp.proto.Opamp.AgentConfigFile other) {
        if (other == opamp.proto.Opamp.AgentConfigFile.getDefaultInstance()) return this;
        if (other.getBody() != com.google.protobuf.ByteString.EMPTY) {
          setBody(other.getBody());
        }
        if (!other.getContentType().isEmpty()) {
          contentType_ = other.contentType_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        opamp.proto.Opamp.AgentConfigFile parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (opamp.proto.Opamp.AgentConfigFile) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private com.google.protobuf.ByteString body_ = com.google.protobuf.ByteString.EMPTY;
      /**
       * <pre>
       * Config file or section body. The content, format and encoding depends on the Agent
       * type. The content_type field may optionally describe the MIME type of the body.
       * </pre>
       *
       * <code>bytes body = 1;</code>
       * @return The body.
       */
      @java.lang.Override
      public com.google.protobuf.ByteString getBody() {
        return body_;
      }
      /**
       * <pre>
       * Config file or section body. The content, format and encoding depends on the Agent
       * type. The content_type field may optionally describe the MIME type of the body.
       * </pre>
       *
       * <code>bytes body = 1;</code>
       * @param value The body to set.
       * @return This builder for chaining.
       */
      public Builder setBody(com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        body_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Config file or section body. The content, format and encoding depends on the Agent
       * type. The content_type field may optionally describe the MIME type of the body.
       * </pre>
       *
       * <code>bytes body = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearBody() {
        
        body_ = getDefaultInstance().getBody();
        onChanged();
        return this;
      }

      private java.lang.Object contentType_ = "";
      /**
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       * @return The contentType.
       */
      public java.lang.String getContentType() {
        java.lang.Object ref = contentType_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          contentType_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       * @return The bytes for contentType.
       */
      public com.google.protobuf.ByteString
          getContentTypeBytes() {
        java.lang.Object ref = contentType_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          contentType_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       * @param value The contentType to set.
       * @return This builder for chaining.
       */
      public Builder setContentType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        contentType_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearContentType() {
        
        contentType_ = getDefaultInstance().getContentType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Optional MIME Content-Type that describes what's in the body field, for
       * example "text/yaml".
       * </pre>
       *
       * <code>string content_type = 2;</code>
       * @param value The bytes for contentType to set.
       * @return This builder for chaining.
       */
      public Builder setContentTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        contentType_ = value;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:opamp.proto.AgentConfigFile)
    }

    // @@protoc_insertion_point(class_scope:opamp.proto.AgentConfigFile)
    private static final opamp.proto.Opamp.AgentConfigFile DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new opamp.proto.Opamp.AgentConfigFile();
    }

    public static opamp.proto.Opamp.AgentConfigFile getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AgentConfigFile>
        PARSER = new com.google.protobuf.AbstractParser<AgentConfigFile>() {
      @java.lang.Override
      public AgentConfigFile parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AgentConfigFile(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AgentConfigFile> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<AgentConfigFile> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public opamp.proto.Opamp.AgentConfigFile getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_AgentToServer_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentToServer_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_AgentDisconnect_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentDisconnect_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_ServerToAgent_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ServerToAgent_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_OpAMPConnectionSettings_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_OpAMPConnectionSettings_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_TelemetryConnectionSettings_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_TelemetryConnectionSettings_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_OtherConnectionSettings_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_OtherConnectionSettings_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_Headers_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_Headers_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_Header_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_Header_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_TLSCertificate_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_TLSCertificate_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_ConnectionSettingsOffers_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ConnectionSettingsOffers_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_PackagesAvailable_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackagesAvailable_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_PackagesAvailable_PackagesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackagesAvailable_PackagesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_PackageAvailable_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackageAvailable_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_DownloadableFile_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_DownloadableFile_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_ServerErrorResponse_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ServerErrorResponse_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_RetryInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_RetryInfo_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_ServerToAgentCommand_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_ServerToAgentCommand_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_AgentDescription_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentDescription_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_AgentHealth_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentHealth_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_EffectiveConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_EffectiveConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_RemoteConfigStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_RemoteConfigStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_PackageStatuses_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackageStatuses_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_PackageStatuses_PackagesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackageStatuses_PackagesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_PackageStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_PackageStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_AgentIdentification_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentIdentification_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_AgentRemoteConfig_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentRemoteConfig_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_AgentConfigMap_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentConfigMap_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_opamp_proto_AgentConfigFile_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_opamp_proto_AgentConfigFile_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\013opamp.proto\022\013opamp.proto\032\016anyvalue.pro" +
      "to\"\253\003\n\rAgentToServer\022\024\n\014instance_uid\030\001 \001" +
      "(\t\022\024\n\014sequence_num\030\002 \001(\004\0228\n\021agent_descri" +
      "ption\030\003 \001(\0132\035.opamp.proto.AgentDescripti" +
      "on\022\024\n\014capabilities\030\004 \001(\004\022(\n\006health\030\005 \001(\013" +
      "2\030.opamp.proto.AgentHealth\0226\n\020effective_" +
      "config\030\006 \001(\0132\034.opamp.proto.EffectiveConf" +
      "ig\022=\n\024remote_config_status\030\007 \001(\0132\037.opamp" +
      ".proto.RemoteConfigStatus\0226\n\020package_sta" +
      "tuses\030\010 \001(\0132\034.opamp.proto.PackageStatuse" +
      "s\0226\n\020agent_disconnect\030\t \001(\0132\034.opamp.prot" +
      "o.AgentDisconnect\022\r\n\005flags\030\n \001(\004\"\021\n\017Agen" +
      "tDisconnect\"\257\003\n\rServerToAgent\022\024\n\014instanc" +
      "e_uid\030\001 \001(\t\0228\n\016error_response\030\002 \001(\0132 .op" +
      "amp.proto.ServerErrorResponse\0225\n\rremote_" +
      "config\030\003 \001(\0132\036.opamp.proto.AgentRemoteCo" +
      "nfig\022B\n\023connection_settings\030\004 \001(\0132%.opam" +
      "p.proto.ConnectionSettingsOffers\022:\n\022pack" +
      "ages_available\030\005 \001(\0132\036.opamp.proto.Packa" +
      "gesAvailable\022\r\n\005flags\030\006 \001(\004\022\024\n\014capabilit" +
      "ies\030\007 \001(\004\022>\n\024agent_identification\030\010 \001(\0132" +
      " .opamp.proto.AgentIdentification\0222\n\007com" +
      "mand\030\t \001(\0132!.opamp.proto.ServerToAgentCo" +
      "mmand\"\220\001\n\027OpAMPConnectionSettings\022\034\n\024des" +
      "tination_endpoint\030\001 \001(\t\022%\n\007headers\030\002 \001(\013" +
      "2\024.opamp.proto.Headers\0220\n\013certificate\030\003 " +
      "\001(\0132\033.opamp.proto.TLSCertificate\"\224\001\n\033Tel" +
      "emetryConnectionSettings\022\034\n\024destination_" +
      "endpoint\030\001 \001(\t\022%\n\007headers\030\002 \001(\0132\024.opamp." +
      "proto.Headers\0220\n\013certificate\030\003 \001(\0132\033.opa" +
      "mp.proto.TLSCertificate\"\227\002\n\027OtherConnect" +
      "ionSettings\022\034\n\024destination_endpoint\030\001 \001(" +
      "\t\022%\n\007headers\030\002 \001(\0132\024.opamp.proto.Headers" +
      "\0220\n\013certificate\030\003 \001(\0132\033.opamp.proto.TLSC" +
      "ertificate\022O\n\016other_settings\030\004 \003(\01327.opa" +
      "mp.proto.OtherConnectionSettings.OtherSe" +
      "ttingsEntry\0324\n\022OtherSettingsEntry\022\013\n\003key" +
      "\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001\"/\n\007Headers\022$\n\007" +
      "headers\030\001 \003(\0132\023.opamp.proto.Header\"$\n\006He" +
      "ader\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\"P\n\016TLSC" +
      "ertificate\022\022\n\npublic_key\030\001 \001(\014\022\023\n\013privat" +
      "e_key\030\002 \001(\014\022\025\n\rca_public_key\030\003 \001(\014\"\315\003\n\030C" +
      "onnectionSettingsOffers\022\014\n\004hash\030\001 \001(\014\0223\n" +
      "\005opamp\030\002 \001(\0132$.opamp.proto.OpAMPConnecti" +
      "onSettings\022=\n\013own_metrics\030\003 \001(\0132(.opamp." +
      "proto.TelemetryConnectionSettings\022<\n\nown" +
      "_traces\030\004 \001(\0132(.opamp.proto.TelemetryCon" +
      "nectionSettings\022:\n\010own_logs\030\005 \001(\0132(.opam" +
      "p.proto.TelemetryConnectionSettings\022V\n\021o" +
      "ther_connections\030\006 \003(\0132;.opamp.proto.Con" +
      "nectionSettingsOffers.OtherConnectionsEn" +
      "try\032]\n\025OtherConnectionsEntry\022\013\n\003key\030\001 \001(" +
      "\t\0223\n\005value\030\002 \001(\0132$.opamp.proto.OtherConn" +
      "ectionSettings:\0028\001\"\276\001\n\021PackagesAvailable" +
      "\022>\n\010packages\030\001 \003(\0132,.opamp.proto.Package" +
      "sAvailable.PackagesEntry\022\031\n\021all_packages" +
      "_hash\030\002 \001(\014\032N\n\rPackagesEntry\022\013\n\003key\030\001 \001(" +
      "\t\022,\n\005value\030\002 \001(\0132\035.opamp.proto.PackageAv" +
      "ailable:\0028\001\"\206\001\n\020PackageAvailable\022&\n\004type" +
      "\030\001 \001(\0162\030.opamp.proto.PackageType\022\017\n\007vers" +
      "ion\030\002 \001(\t\022+\n\004file\030\003 \001(\0132\035.opamp.proto.Do" +
      "wnloadableFile\022\014\n\004hash\030\004 \001(\014\"Q\n\020Download" +
      "ableFile\022\024\n\014download_url\030\001 \001(\t\022\024\n\014conten" +
      "t_hash\030\002 \001(\014\022\021\n\tsignature\030\003 \001(\014\"\231\001\n\023Serv" +
      "erErrorResponse\0222\n\004type\030\001 \001(\0162$.opamp.pr" +
      "oto.ServerErrorResponseType\022\025\n\rerror_mes" +
      "sage\030\002 \001(\t\022,\n\nretry_info\030\003 \001(\0132\026.opamp.p" +
      "roto.RetryInfoH\000B\t\n\007Details\",\n\tRetryInfo" +
      "\022\037\n\027retry_after_nanoseconds\030\001 \001(\004\">\n\024Ser" +
      "verToAgentCommand\022&\n\004type\030\001 \001(\0162\030.opamp." +
      "proto.CommandType\"\204\001\n\020AgentDescription\0225" +
      "\n\026identifying_attributes\030\001 \003(\0132\025.opamp.p" +
      "roto.KeyValue\0229\n\032non_identifying_attribu" +
      "tes\030\002 \003(\0132\025.opamp.proto.KeyValue\"K\n\013Agen" +
      "tHealth\022\n\n\002up\030\001 \001(\010\022\034\n\024start_time_unix_n" +
      "ano\030\002 \001(\006\022\022\n\nlast_error\030\003 \001(\t\"B\n\017Effecti" +
      "veConfig\022/\n\nconfig_map\030\001 \001(\0132\033.opamp.pro" +
      "to.AgentConfigMap\"\177\n\022RemoteConfigStatus\022" +
      "\037\n\027last_remote_config_hash\030\001 \001(\014\0221\n\006stat" +
      "us\030\002 \001(\0162!.opamp.proto.RemoteConfigStatu" +
      "ses\022\025\n\rerror_message\030\003 \001(\t\"\336\001\n\017PackageSt" +
      "atuses\022<\n\010packages\030\001 \003(\0132*.opamp.proto.P" +
      "ackageStatuses.PackagesEntry\022)\n!server_p" +
      "rovided_all_packages_hash\030\002 \001(\014\022\025\n\rerror" +
      "_message\030\003 \001(\t\032K\n\rPackagesEntry\022\013\n\003key\030\001" +
      " \001(\t\022)\n\005value\030\002 \001(\0132\032.opamp.proto.Packag" +
      "eStatus:\0028\001\"\324\001\n\rPackageStatus\022\014\n\004name\030\001 " +
      "\001(\t\022\031\n\021agent_has_version\030\002 \001(\t\022\026\n\016agent_" +
      "has_hash\030\003 \001(\014\022\036\n\026server_offered_version" +
      "\030\004 \001(\t\022\033\n\023server_offered_hash\030\005 \001(\014\022.\n\006s" +
      "tatus\030\006 \001(\0162\036.opamp.proto.PackageStatusE" +
      "num\022\025\n\rerror_message\030\007 \001(\t\"/\n\023AgentIdent" +
      "ification\022\030\n\020new_instance_uid\030\001 \001(\t\"U\n\021A" +
      "gentRemoteConfig\022+\n\006config\030\001 \001(\0132\033.opamp" +
      ".proto.AgentConfigMap\022\023\n\013config_hash\030\002 \001" +
      "(\014\"\240\001\n\016AgentConfigMap\022>\n\nconfig_map\030\001 \003(" +
      "\0132*.opamp.proto.AgentConfigMap.ConfigMap" +
      "Entry\032N\n\016ConfigMapEntry\022\013\n\003key\030\001 \001(\t\022+\n\005" +
      "value\030\002 \001(\0132\034.opamp.proto.AgentConfigFil" +
      "e:\0028\001\"5\n\017AgentConfigFile\022\014\n\004body\030\001 \001(\014\022\024" +
      "\n\014content_type\030\002 \001(\t*c\n\022AgentToServerFla" +
      "gs\022\"\n\036AgentToServerFlags_Unspecified\020\000\022)" +
      "\n%AgentToServerFlags_RequestInstanceUid\020" +
      "\001*`\n\022ServerToAgentFlags\022\"\n\036ServerToAgent" +
      "Flags_Unspecified\020\000\022&\n\"ServerToAgentFlag" +
      "s_ReportFullState\020\001*\276\002\n\022ServerCapabiliti" +
      "es\022\"\n\036ServerCapabilities_Unspecified\020\000\022$" +
      "\n ServerCapabilities_AcceptsStatus\020\001\022)\n%" +
      "ServerCapabilities_OffersRemoteConfig\020\002\022" +
      "-\n)ServerCapabilities_AcceptsEffectiveCo" +
      "nfig\020\004\022%\n!ServerCapabilities_OffersPacka" +
      "ges\020\010\022,\n(ServerCapabilities_AcceptsPacka" +
      "gesStatus\020\020\022/\n+ServerCapabilities_Offers" +
      "ConnectionSettings\020 *>\n\013PackageType\022\030\n\024P" +
      "ackageType_TopLevel\020\000\022\025\n\021PackageType_Add" +
      "on\020\001*\217\001\n\027ServerErrorResponseType\022#\n\037Serv" +
      "erErrorResponseType_Unknown\020\000\022&\n\"ServerE" +
      "rrorResponseType_BadRequest\020\001\022\'\n#ServerE" +
      "rrorResponseType_Unavailable\020\002*&\n\013Comman" +
      "dType\022\027\n\023CommandType_Restart\020\000*\357\004\n\021Agent" +
      "Capabilities\022!\n\035AgentCapabilities_Unspec" +
      "ified\020\000\022#\n\037AgentCapabilities_ReportsStat" +
      "us\020\001\022)\n%AgentCapabilities_AcceptsRemoteC" +
      "onfig\020\002\022,\n(AgentCapabilities_ReportsEffe" +
      "ctiveConfig\020\004\022%\n!AgentCapabilities_Accep" +
      "tsPackages\020\010\022,\n(AgentCapabilities_Report" +
      "sPackageStatuses\020\020\022&\n\"AgentCapabilities_" +
      "ReportsOwnTraces\020 \022\'\n#AgentCapabilities_" +
      "ReportsOwnMetrics\020@\022%\n AgentCapabilities" +
      "_ReportsOwnLogs\020\200\001\0225\n0AgentCapabilities_" +
      "AcceptsOpAMPConnectionSettings\020\200\002\0225\n0Age" +
      "ntCapabilities_AcceptsOtherConnectionSet" +
      "tings\020\200\004\022,\n\'AgentCapabilities_AcceptsRes" +
      "tartCommand\020\200\010\022$\n\037AgentCapabilities_Repo" +
      "rtsHealth\020\200\020\022*\n%AgentCapabilities_Report" +
      "sRemoteConfig\020\200 *\234\001\n\024RemoteConfigStatuse" +
      "s\022\036\n\032RemoteConfigStatuses_UNSET\020\000\022 \n\034Rem" +
      "oteConfigStatuses_APPLIED\020\001\022!\n\035RemoteCon" +
      "figStatuses_APPLYING\020\002\022\037\n\033RemoteConfigSt" +
      "atuses_FAILED\020\003*\241\001\n\021PackageStatusEnum\022\037\n" +
      "\033PackageStatusEnum_Installed\020\000\022$\n Packag" +
      "eStatusEnum_InstallPending\020\001\022 \n\034PackageS" +
      "tatusEnum_Installing\020\002\022#\n\037PackageStatusE" +
      "num_InstallFailed\020\003B.Z,github.com/open-t" +
      "elemetry/opamp-go/protobufsb\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          opamp.proto.Anyvalue.getDescriptor(),
        });
    internal_static_opamp_proto_AgentToServer_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_opamp_proto_AgentToServer_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_AgentToServer_descriptor,
        new java.lang.String[] { "InstanceUid", "SequenceNum", "AgentDescription", "Capabilities", "Health", "EffectiveConfig", "RemoteConfigStatus", "PackageStatuses", "AgentDisconnect", "Flags", });
    internal_static_opamp_proto_AgentDisconnect_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_opamp_proto_AgentDisconnect_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_AgentDisconnect_descriptor,
        new java.lang.String[] { });
    internal_static_opamp_proto_ServerToAgent_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_opamp_proto_ServerToAgent_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_ServerToAgent_descriptor,
        new java.lang.String[] { "InstanceUid", "ErrorResponse", "RemoteConfig", "ConnectionSettings", "PackagesAvailable", "Flags", "Capabilities", "AgentIdentification", "Command", });
    internal_static_opamp_proto_OpAMPConnectionSettings_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_opamp_proto_OpAMPConnectionSettings_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_OpAMPConnectionSettings_descriptor,
        new java.lang.String[] { "DestinationEndpoint", "Headers", "Certificate", });
    internal_static_opamp_proto_TelemetryConnectionSettings_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_opamp_proto_TelemetryConnectionSettings_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_TelemetryConnectionSettings_descriptor,
        new java.lang.String[] { "DestinationEndpoint", "Headers", "Certificate", });
    internal_static_opamp_proto_OtherConnectionSettings_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_opamp_proto_OtherConnectionSettings_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_OtherConnectionSettings_descriptor,
        new java.lang.String[] { "DestinationEndpoint", "Headers", "Certificate", "OtherSettings", });
    internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_descriptor =
      internal_static_opamp_proto_OtherConnectionSettings_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_OtherConnectionSettings_OtherSettingsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_opamp_proto_Headers_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_opamp_proto_Headers_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_Headers_descriptor,
        new java.lang.String[] { "Headers", });
    internal_static_opamp_proto_Header_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_opamp_proto_Header_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_Header_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_opamp_proto_TLSCertificate_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_opamp_proto_TLSCertificate_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_TLSCertificate_descriptor,
        new java.lang.String[] { "PublicKey", "PrivateKey", "CaPublicKey", });
    internal_static_opamp_proto_ConnectionSettingsOffers_descriptor =
      getDescriptor().getMessageTypes().get(9);
    internal_static_opamp_proto_ConnectionSettingsOffers_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_ConnectionSettingsOffers_descriptor,
        new java.lang.String[] { "Hash", "Opamp", "OwnMetrics", "OwnTraces", "OwnLogs", "OtherConnections", });
    internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_descriptor =
      internal_static_opamp_proto_ConnectionSettingsOffers_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_ConnectionSettingsOffers_OtherConnectionsEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_opamp_proto_PackagesAvailable_descriptor =
      getDescriptor().getMessageTypes().get(10);
    internal_static_opamp_proto_PackagesAvailable_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_PackagesAvailable_descriptor,
        new java.lang.String[] { "Packages", "AllPackagesHash", });
    internal_static_opamp_proto_PackagesAvailable_PackagesEntry_descriptor =
      internal_static_opamp_proto_PackagesAvailable_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_PackagesAvailable_PackagesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_PackagesAvailable_PackagesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_opamp_proto_PackageAvailable_descriptor =
      getDescriptor().getMessageTypes().get(11);
    internal_static_opamp_proto_PackageAvailable_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_PackageAvailable_descriptor,
        new java.lang.String[] { "Type", "Version", "File", "Hash", });
    internal_static_opamp_proto_DownloadableFile_descriptor =
      getDescriptor().getMessageTypes().get(12);
    internal_static_opamp_proto_DownloadableFile_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_DownloadableFile_descriptor,
        new java.lang.String[] { "DownloadUrl", "ContentHash", "Signature", });
    internal_static_opamp_proto_ServerErrorResponse_descriptor =
      getDescriptor().getMessageTypes().get(13);
    internal_static_opamp_proto_ServerErrorResponse_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_ServerErrorResponse_descriptor,
        new java.lang.String[] { "Type", "ErrorMessage", "RetryInfo", "Details", });
    internal_static_opamp_proto_RetryInfo_descriptor =
      getDescriptor().getMessageTypes().get(14);
    internal_static_opamp_proto_RetryInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_RetryInfo_descriptor,
        new java.lang.String[] { "RetryAfterNanoseconds", });
    internal_static_opamp_proto_ServerToAgentCommand_descriptor =
      getDescriptor().getMessageTypes().get(15);
    internal_static_opamp_proto_ServerToAgentCommand_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_ServerToAgentCommand_descriptor,
        new java.lang.String[] { "Type", });
    internal_static_opamp_proto_AgentDescription_descriptor =
      getDescriptor().getMessageTypes().get(16);
    internal_static_opamp_proto_AgentDescription_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_AgentDescription_descriptor,
        new java.lang.String[] { "IdentifyingAttributes", "NonIdentifyingAttributes", });
    internal_static_opamp_proto_AgentHealth_descriptor =
      getDescriptor().getMessageTypes().get(17);
    internal_static_opamp_proto_AgentHealth_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_AgentHealth_descriptor,
        new java.lang.String[] { "Up", "StartTimeUnixNano", "LastError", });
    internal_static_opamp_proto_EffectiveConfig_descriptor =
      getDescriptor().getMessageTypes().get(18);
    internal_static_opamp_proto_EffectiveConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_EffectiveConfig_descriptor,
        new java.lang.String[] { "ConfigMap", });
    internal_static_opamp_proto_RemoteConfigStatus_descriptor =
      getDescriptor().getMessageTypes().get(19);
    internal_static_opamp_proto_RemoteConfigStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_RemoteConfigStatus_descriptor,
        new java.lang.String[] { "LastRemoteConfigHash", "Status", "ErrorMessage", });
    internal_static_opamp_proto_PackageStatuses_descriptor =
      getDescriptor().getMessageTypes().get(20);
    internal_static_opamp_proto_PackageStatuses_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_PackageStatuses_descriptor,
        new java.lang.String[] { "Packages", "ServerProvidedAllPackagesHash", "ErrorMessage", });
    internal_static_opamp_proto_PackageStatuses_PackagesEntry_descriptor =
      internal_static_opamp_proto_PackageStatuses_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_PackageStatuses_PackagesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_PackageStatuses_PackagesEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_opamp_proto_PackageStatus_descriptor =
      getDescriptor().getMessageTypes().get(21);
    internal_static_opamp_proto_PackageStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_PackageStatus_descriptor,
        new java.lang.String[] { "Name", "AgentHasVersion", "AgentHasHash", "ServerOfferedVersion", "ServerOfferedHash", "Status", "ErrorMessage", });
    internal_static_opamp_proto_AgentIdentification_descriptor =
      getDescriptor().getMessageTypes().get(22);
    internal_static_opamp_proto_AgentIdentification_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_AgentIdentification_descriptor,
        new java.lang.String[] { "NewInstanceUid", });
    internal_static_opamp_proto_AgentRemoteConfig_descriptor =
      getDescriptor().getMessageTypes().get(23);
    internal_static_opamp_proto_AgentRemoteConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_AgentRemoteConfig_descriptor,
        new java.lang.String[] { "Config", "ConfigHash", });
    internal_static_opamp_proto_AgentConfigMap_descriptor =
      getDescriptor().getMessageTypes().get(24);
    internal_static_opamp_proto_AgentConfigMap_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_AgentConfigMap_descriptor,
        new java.lang.String[] { "ConfigMap", });
    internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_descriptor =
      internal_static_opamp_proto_AgentConfigMap_descriptor.getNestedTypes().get(0);
    internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_AgentConfigMap_ConfigMapEntry_descriptor,
        new java.lang.String[] { "Key", "Value", });
    internal_static_opamp_proto_AgentConfigFile_descriptor =
      getDescriptor().getMessageTypes().get(25);
    internal_static_opamp_proto_AgentConfigFile_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_opamp_proto_AgentConfigFile_descriptor,
        new java.lang.String[] { "Body", "ContentType", });
    opamp.proto.Anyvalue.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
